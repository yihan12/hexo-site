{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","path":"images/avatar1.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","path":"images/bg.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","path":"images/favicon.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","path":"images/favicon1.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"6d25a1f5a28c87fc6a071e5e24a8789bc1fdec9e","modified":1691912831319},{"_id":"source/categories/index.md","hash":"604a635fd603df744a2adcfc7253e2876bab4727","modified":1691893909242},{"_id":"source/_posts/.DS_Store","hash":"eec8b21ad60e658dddfca710726ea58e8bad61eb","modified":1691985967986},{"_id":"source/_posts/js去除中括号.md","hash":"0affbf8474f798d07c216bcdac928627abe12470","modified":1691908985380},{"_id":"source/tags/index.md","hash":"e5efda02833ca720ce647161b6edb9326b8e8035","modified":1691891512600},{"_id":"source/friends/index.md","hash":"b48eb357e54258e2cc4bd7d2eaac6462de1c8bdc","modified":1691895646518},{"_id":"source/_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","hash":"d662514623227a14cb5e79500c3228626f81569c","modified":1691928034710},{"_id":"source/_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","hash":"ca943c8e0072921ed155c2c9253f2961712deb7f","modified":1691928118162},{"_id":"source/_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","hash":"da8d10ece90a0b5c19d8d5362610c545d09d7aea","modified":1691928168399},{"_id":"source/_posts/Echarts/echarts--基准线markLine.md","hash":"0c66482d620e34e7978e7a59911c3ace29ea24f4","modified":1691927943620},{"_id":"source/_posts/Echarts/echarts--上下左右的距离（grid）.md","hash":"94fafa749fd44c42abd87614466bb0a747aeda57","modified":1691927977355},{"_id":"source/_posts/Echarts/echarts折线--无数据时连线与否.md","hash":"7a5c97668fe2191c31b333499930611de715b1d1","modified":1691928199214},{"_id":"source/_posts/Echarts/echarts设置从原点开始.md","hash":"626ac6aaace9b50e1aa65895e670e871362d110e","modified":1691928074812},{"_id":"source/_posts/JavaScript/.DS_Store","hash":"6f0fa3152b188737d45f0ec14d5730366a91d58d","modified":1692235442339},{"_id":"source/_posts/Echarts/echarts折线图--无拐点，折线样式.md","hash":"120a52bb22b03d6daa4e7c124c3b432da8269074","modified":1691928219460},{"_id":"source/_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","hash":"5d70fcdbc36350ce13dbed80e0fb0704c4bafdd5","modified":1691928301261},{"_id":"source/_posts/浏览器/ 【浏览器】之同源策略.md","hash":"fe4b9908989392d203d25a62970097f2849efbf9","modified":1691911038346},{"_id":"source/_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","hash":"5902d94421783149ab8eddb8a495023fe48f8591","modified":1691928251419},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/.DS_Store","hash":"f10cf3669afa41a916e983c7530e3c246ec258d6","modified":1691985992833},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","hash":"f91b838a858d162dc86cfdee1dbf20a94251a855","modified":1691986023400},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","hash":"9563b61ced6112b269912b5e94091771f5efd564","modified":1691986086280},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","hash":"705dcb021d443419cce284eecaa27b6a2c98f8a7","modified":1691986270682},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","hash":"e820078e0404049683810c54fe864dce87c8d2db","modified":1691986351242},{"_id":"source/_posts/JavaScript/JavaScript面试/JavaScript面试.md","hash":"aca098bb501d23bed2190026886b709489a4c6d2","modified":1692235230370},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","hash":"233b3d8ef60c9c28b8a175491bd923b60ebb3c61","modified":1691986232378},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","hash":"f11edbbcbcfeead0100562f7c397da44201fb102","modified":1691986318700},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"efe35e61a73349f027d1f1466d243f6fe36f7abd","modified":1692101130121},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1692158420545},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420544},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","hash":"243059830aa31c3d85b5a1241f097ec6fca1c0d5","modified":1692158420546},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":499162500000},{"_id":"public/atom.xml","hash":"321372f4be4ebc8536ab7a23c05692139fb5bef6","modified":1692235688015},{"_id":"public/categories/index.html","hash":"209ab57fe949e8d66c653c33df1b0c9b12a814b6","modified":1692235688015},{"_id":"public/tags/index.html","hash":"5e891bf07db93af536e03bf01f67941831d65f9d","modified":1692235688015},{"_id":"public/friends/index.html","hash":"08d66a66234d65ea8318a12b648034f9e430331c","modified":1692235688015},{"_id":"public/about/index.html","hash":"97dda4f60dc0a04556d1f54ab921823ec4d62dc1","modified":1692235688015},{"_id":"public/2023/08/13/浏览器/ 【浏览器】之同源策略/index.html","hash":"c14c01c8d58eda5da841fbf3145405661ee93912","modified":1692235688015},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量/index.html","hash":"0205a908c8bca874b7b38a759512a49762f8d0db","modified":1692235688015},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值/index.html","hash":"b7e92bf2d82ea34c677194db8661bde67a5761b8","modified":1692235688015},{"_id":"public/2023/08/13/js去除中括号/index.html","hash":"dba13e5c8673da436fd99b601e333a688be66dc7","modified":1692235688015},{"_id":"public/2022/07/20/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）/index.html","hash":"6e3e41cf01107fa807dd23b63b92e46ee373a54c","modified":1692235688015},{"_id":"public/2023/08/17/JavaScript/JavaScript面试/JavaScript面试/index.html","hash":"afe05680dcd06461224ba0db50797ad3096755af","modified":1692235688015},{"_id":"public/2022/07/10/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并/index.html","hash":"9c9efebc48f89e3c23fb3e11d7de8c777fcd7658","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echats折线--拐点圆的样式（内圆外圆）/index.html","hash":"5154aba90f14f1276353978e776f49c64553e37c","modified":1692235688015},{"_id":"public/2022/07/08/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖/index.html","hash":"19f229fbe60aa48fe043d88d79fb9026d807104a","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts折线图--无拐点，折线样式/index.html","hash":"734caf6e3bf0df5b614aa032d40053b820fa8932","modified":1692235688015},{"_id":"public/2022/07/09/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流/index.html","hash":"f3dd83f22b38f66f6abff2b5e90385d709fd062c","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts折线--无数据时连线与否/index.html","hash":"de20ad33ab5ab8e5236d67ae1099a89f94045926","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts圆柱--设置柱子的borderRadius/index.html","hash":"d5a36753c42b8008a9ab3b0708eee83fc3f1691b","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts图例--选中状态（默认不显示置灰）/index.html","hash":"b34e4f2219de99aa500e89be253aee9c7cc669f0","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts设置从原点开始/index.html","hash":"259eeb419aa6adef989700896c883408a2424db3","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts柱形--设置柱子多个颜色（渐进色）/index.html","hash":"f366356466cd73394d698f0c6b324f2be2ff3138","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts--上下左右的距离（grid）/index.html","hash":"a98c41afb100dd7ab9b5b2f7afc7ce8a21252d7e","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts--基准线markLine/index.html","hash":"e7b615d3aed387c92f50dccc54ad84a39d28b185","modified":1692235688015},{"_id":"public/2022/03/10/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线/index.html","hash":"e52d74556a9ad193610cf155cb025d2b6560de78","modified":1692235688015},{"_id":"public/archives/index.html","hash":"84bbe470360fb29e7640b260dee35b6038e099c2","modified":1692235688015},{"_id":"public/archives/2022/index.html","hash":"4e21d0e902572909fabc20d30078c004675cac18","modified":1692235688015},{"_id":"public/archives/2022/page/2/index.html","hash":"1c27d66dc1696af78446f18590e38b5829e96ecf","modified":1692235688015},{"_id":"public/archives/2022/03/index.html","hash":"f05a1f4caa9530a87be1218b21264e1a5ad7bc17","modified":1692235688015},{"_id":"public/archives/page/2/index.html","hash":"027ffbc81c4861421a6a52541b37fc3cc501e77a","modified":1692235688015},{"_id":"public/archives/2023/08/index.html","hash":"c0cd0f2e1094471e1ed39a5c45ca3b1463ab0eae","modified":1692235688015},{"_id":"public/archives/2023/index.html","hash":"63e941e47827b52f407a16554c733f6decc85bfc","modified":1692235688015},{"_id":"public/categories/前端/index.html","hash":"5441e600a6c6e335a16c4f3d2fba2b8eaf0097fe","modified":1692235688015},{"_id":"public/categories/前端/page/2/index.html","hash":"21f5a9f55a6819bad2baa3d8ef7851f022fe4b3f","modified":1692235688015},{"_id":"public/categories/前端/Echarts/index.html","hash":"c7d79655cbd1396e4d7e40f93d8243b8001e09d1","modified":1692235688015},{"_id":"public/archives/2022/07/index.html","hash":"2bcafe7d0ca188936d3edf41a3e2f79bc4355c2d","modified":1692235688015},{"_id":"public/categories/前端/正则/index.html","hash":"7140d9d315f8e0a238b0ad1bb1cfb698f051a32b","modified":1692235688015},{"_id":"public/categories/前端/Echarts/symbol/index.html","hash":"b60d0282e8364c18bb19f4e519c7fe588ba55d51","modified":1692235688015},{"_id":"public/categories/前端/Echarts/borderRadius/index.html","hash":"2079414773b080589dcc3fed52384a41935775d8","modified":1692235688015},{"_id":"public/categories/前端/浏览器/index.html","hash":"cca6bbace2d53ce4664ff713fa0c9bb91498ceae","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/index.html","hash":"bbedc963db03385456b7f46a372e39cacfb04fdd","modified":1692235688015},{"_id":"public/categories/前端/Echarts/legend/index.html","hash":"86450413e914c29ed9f94fad9ab5bd626cac5f96","modified":1692235688015},{"_id":"public/categories/前端/Echarts/xAxis/index.html","hash":"270e34b23a9769feaac22cc0346cf643feb7e844","modified":1692235688015},{"_id":"public/categories/前端/Echarts/symbolSize/index.html","hash":"600b953b01e1ba8458a1bceb4791d043c718675c","modified":1692235688015},{"_id":"public/categories/前端/Echarts/grid/index.html","hash":"63105151fdec022436593db7ebb05ee671518058","modified":1692235688015},{"_id":"public/categories/前端/Echarts/itemStyle/index.html","hash":"baf1f29d20cfb80b3c9f8a40a0f073635d9b85b9","modified":1692235688015},{"_id":"public/categories/前端/Echarts/markLine/index.html","hash":"eb731170dd5c7924080baa2d05f14320acf891a9","modified":1692235688015},{"_id":"public/categories/前端/Echarts/connectNulls/index.html","hash":"dbc96cd00d0ba4102e4eefdeea5ab839f588430c","modified":1692235688015},{"_id":"public/categories/前端/浏览器/同源策略/index.html","hash":"b8bea46e45bafcb608d303becda8d9f57b3f08e0","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/ES6/index.html","hash":"8e6f408cd09ebf5482b67727ed3ac93e6f21e8f0","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/index.html","hash":"e4ece8974030bdcd91f0e23dc0ff76c441ffa9fb","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/ES6/解构/index.html","hash":"8507b76d4deb8cefb61521d61d5a0412c258d51e","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/ES6/变量/index.html","hash":"b4f9df1db3d45eef97e58467b31fcb8b2cdec93f","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/节流/index.html","hash":"c7fad7fa0ddaa08070ab8463fe705331a70ec16f","modified":1692235688015},{"_id":"public/categories/前端/Echarts/boundaryGap/index.html","hash":"d17408ecc71237dda38f83c9e2892ad32c656192","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/lodash源码分析/index.html","hash":"4d65a2facea090f1d96483fd6b83bd47f27f19b1","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/防抖/index.html","hash":"d2d0c6f6b896a6780da0396843f134e74c3bacc0","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/lodash源码分析/防抖节流/index.html","hash":"b64d61373726f8566a9a555c68437a12deeaabb3","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/数组去重/index.html","hash":"ae1107625fce015285c2365fd7b7634cd7f9b1b0","modified":1692235688015},{"_id":"public/categories/前端/JavaScript/JavaScript面试/index.html","hash":"da09690d51f43dee74c49c5c70fb0051801c9df6","modified":1692235688015},{"_id":"public/index.html","hash":"e080118294792169d8a160426833b646602106ef","modified":1692235688015},{"_id":"public/page/2/index.html","hash":"aa4311a5c416206dca67ede35fd379d8f4e4a8bc","modified":1692235688015},{"_id":"public/tags/js/index.html","hash":"5bda94824ca7d6193ab7e586c593cd0d4340bc67","modified":1692235688015},{"_id":"public/tags/正则/index.html","hash":"e20df7aaa89da2e88b692aab5b4af697fcaa7ae0","modified":1692235688015},{"_id":"public/tags/前端/index.html","hash":"e33f81e30c174036538e5af7fa8293b07819c1cd","modified":1692235688015},{"_id":"public/tags/Echarts/index.html","hash":"a2123a090e458f1c5e8e319a735d00c7a82b6560","modified":1692235688015},{"_id":"public/tags/浏览器/index.html","hash":"5bea5befd9b7b66a6eabc37ba87ee30280f0640f","modified":1692235688015},{"_id":"public/tags/JavaScript/index.html","hash":"6960b90e6f3a3e0647d4cc1e8acb01b4ce42263e","modified":1692235688015},{"_id":"public/tags/ES6/index.html","hash":"9cedde8dddf886f3bdc0dce1fef381dfe0264e07","modified":1692235688015},{"_id":"public/tags/lodash/index.html","hash":"3d7c79fe18a322feb841c12571339ead0a317469","modified":1692235688015},{"_id":"public/tags/JavaScript面试/index.html","hash":"4cd7abc294d7d0c6a509b5515ac36e5b26839ac4","modified":1692235688015},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692235688015},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692235688015},{"_id":"public/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692235688015},{"_id":"public/images/bg.jpeg","hash":"243059830aa31c3d85b5a1241f097ec6fca1c0d5","modified":1692235688015},{"_id":"public/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1692235688015},{"_id":"public/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1692235688015},{"_id":"public/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692235688015},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692235688015},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1692235688015},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692235688015},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692235688015},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692235688015},{"_id":"public/css/index.css","hash":"9a4d4bb2cc4ac0510227cd7185e3d619130e073d","modified":1692235688015},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692235688015},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692235688015}],"Category":[{"name":"前端","_id":"cllehfprd0004xw2vfjdvbhw5"},{"name":"Echarts","parent":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprj000kxw2v5zcsdck5"},{"name":"正则","parent":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprk000pxw2v99yn8few"},{"name":"symbol","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprq001oxw2va3msfmx8"},{"name":"borderRadius","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprq001sxw2v76uw16p9"},{"name":"浏览器","parent":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprr001wxw2vgv8hdysl"},{"name":"JavaScript","parent":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprr0022xw2v1m0w37b5"},{"name":"legend","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprs002gxw2v0n0q2kze"},{"name":"xAxis","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprt002mxw2vdx9fdfvi"},{"name":"symbolSize","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfpru002rxw2v00fs8j80"},{"name":"grid","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfpru002wxw2vdkx7gsrv"},{"name":"itemStyle","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfpru0031xw2v27gqb7kz"},{"name":"connectNulls","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprv0034xw2v36h1hhot"},{"name":"markLine","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprv0037xw2veudu0ll3"},{"name":"boundaryGap","parent":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprw003bxw2v0tnv3jce"},{"name":"同源策略","parent":"cllehfprr001wxw2vgv8hdysl","_id":"cllehfprw003exw2v2i9mg6yn"},{"name":"ES6","parent":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfprx003hxw2vcfoogh4b"},{"name":"JavaScript深入理解","parent":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfprx003nxw2verx34uho"},{"name":"解构","parent":"cllehfprx003hxw2vcfoogh4b","_id":"cllehfpry003uxw2v294y459z"},{"name":"变量","parent":"cllehfprx003hxw2vcfoogh4b","_id":"cllehfpry003wxw2v64ok6jie"},{"name":"节流","parent":"cllehfprx003nxw2verx34uho","_id":"cllehfprz003yxw2vaknt2uy1"},{"name":"数组去重","parent":"cllehfprx003nxw2verx34uho","_id":"cllehfprz0041xw2veqso7shf"},{"name":"防抖","parent":"cllehfprx003nxw2verx34uho","_id":"cllehfps6004ixw2v6wz10be4"},{"name":"lodash源码分析","parent":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfps6004kxw2v3h8dbkfz"},{"name":"防抖节流","parent":"cllehfps6004kxw2v3h8dbkfz","_id":"cllehfps7004pxw2v8dmc8fq7"},{"name":"JavaScript面试","parent":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfpsd004yxw2v8i30hsbc"}],"Data":[],"Page":[{"title":"categories","date":"2023-08-13T02:31:49.242Z","type":"categories","categories":null,"tags":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate:\ntype: 'categories'\ncategories:\ntags:\n---\n","updated":"2023-08-13T02:31:49.242Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllehfpr70000xw2vee9h1y0l","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"about","date":"2023-08-13T07:47:11.319Z","type":"about","categories":null,"tags":null,"_content":"\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","source":"about/index.md","raw":"---\ntitle: about\ndate:\ntype: 'about'\ncategories:\ntags:\n---\n\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","updated":"2023-08-13T07:47:11.319Z","path":"about/index.html","comments":1,"layout":"page","_id":"cllehfprc0002xw2vguiva7jf","content":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#49;&#x32;&#52;&#x35;&#53;&#48;&#x31;&#x38;&#x31;&#54;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;\">&#49;&#x32;&#52;&#x35;&#53;&#48;&#x31;&#x38;&#x31;&#54;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#49;&#x32;&#52;&#x35;&#53;&#48;&#x31;&#x38;&#x31;&#54;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;\">&#49;&#x32;&#52;&#x35;&#53;&#48;&#x31;&#x38;&#x31;&#54;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n"},{"title":"friends","date":"2023-08-13T03:00:46.518Z","type":"friends","categories":null,"tags":null,"_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate:\ntype: 'friends'\ncategories:\ntags:\n---\n","updated":"2023-08-13T03:00:46.518Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cllehfpre0006xw2vdhxq6y63","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-08-13T01:51:52.600Z","type":"tags","categories":null,"tags":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate:\ntype: 'tags'\ncategories:\ntags:\n---\n","updated":"2023-08-13T01:51:52.600Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cllehfprf0008xw2vef9wgsak","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"js去除中括号","date":"2023-08-13T01:44:43.677Z","_content":"\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","source":"_posts/js去除中括号.md","raw":"---\ntitle: js去除中括号\ndate:\ntags: [js, 正则]\ncategories: [前端, 正则]\n---\n\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","slug":"js去除中括号","published":1,"updated":"2023-08-13T06:43:05.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfpr90001xw2v4qnt6hyh","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>"},{"title":"【Echarts使用】之 grid","date":"2022-03-10T03:38:39.986Z","_content":"\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","source":"_posts/Echarts/echarts--上下左右的距离（grid）.md","raw":"---\ntitle: 【Echarts使用】之 grid\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, grid]\n---\n\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","slug":"Echarts/echarts--上下左右的距离（grid）","published":1,"updated":"2023-08-13T11:59:37.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprc0003xw2v0ycjcph6","content":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n"},{"title":"【Echarts使用】之基准线markLine","date":"2022-03-10T03:38:35.048Z","_content":"\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","source":"_posts/Echarts/echarts--基准线markLine.md","raw":"---\ntitle: 【Echarts使用】之基准线markLine\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, markLine]\n---\n\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","slug":"Echarts/echarts--基准线markLine","published":1,"updated":"2023-08-13T11:59:03.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfpre0007xw2v0k253d9f","content":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n"},{"title":"【Echarts使用】之 设置柱子borderRadius","date":"2022-03-10T03:38:56.351Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","raw":"---\ntitle: 【Echarts使用】之 设置柱子borderRadius\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, borderRadius]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","slug":"Echarts/echarts圆柱--设置柱子的borderRadius","published":1,"updated":"2023-08-13T12:02:48.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprf0009xw2v6p1pcdwp","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 图例选中状态","date":"2022-03-10T03:38:52.203Z","_content":"\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","source":"_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","raw":"---\ntitle: 【Echarts使用】之 图例选中状态\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, legend]\n---\n\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","slug":"Echarts/echarts图例--选中状态（默认不显示置灰）","published":1,"updated":"2023-08-13T12:01:58.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprf000axw2vf9at684u","content":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无拐点","date":"2022-03-10T03:39:04.601Z","_content":"\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","source":"_posts/Echarts/echarts折线图--无拐点，折线样式.md","raw":"---\ntitle: 【Echarts使用】之 无拐点\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbolSize]\n---\n\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","slug":"Echarts/echarts折线图--无拐点，折线样式","published":1,"updated":"2023-08-13T12:03:39.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprh000dxw2v3jeq7jsu","content":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置柱状图渐进式","date":"2022-03-10T03:39:08.919Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","raw":"---\ntitle: 【Echarts使用】之 设置柱状图渐进式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, itemStyle]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","slug":"Echarts/echarts柱形--设置柱子多个颜色（渐进色）","published":1,"updated":"2023-08-13T12:04:11.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprh000exw2vgnbw675l","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无数据是连线","date":"2022-03-10T03:38:59.886Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts折线--无数据时连线与否.md","raw":"---\ntitle: 【Echarts使用】之 无数据是连线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, connectNulls]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echarts折线--无数据时连线与否","published":1,"updated":"2023-08-13T12:03:19.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfpri000hxw2vdhcy7wfq","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置从原点开始","date":"2022-03-10T03:38:44.099Z","_content":"\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","source":"_posts/Echarts/echarts设置从原点开始.md","raw":"---\ntitle: 【Echarts使用】之 设置从原点开始\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, boundaryGap]\n---\n\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","slug":"Echarts/echarts设置从原点开始","published":1,"updated":"2023-08-13T12:01:14.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfpri000jxw2v1ai66ccn","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 拐点圆样式","date":"2022-03-10T03:39:13.518Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","raw":"---\ntitle: 【Echarts使用】之 拐点圆样式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbol]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echats折线--拐点圆的样式（内圆外圆）","published":1,"updated":"2023-08-13T12:05:01.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprj000nxw2v70lvbsfk","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【浏览器】之同源策略","date":"2023-08-13T06:34:46.171Z","_content":"\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","source":"_posts/浏览器/ 【浏览器】之同源策略.md","raw":"---\ntitle: 【浏览器】之同源策略\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 同源策略]\n---\n\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","slug":"浏览器/ 【浏览器】之同源策略","published":1,"updated":"2023-08-13T07:17:18.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprk000oxw2v7tnkbcwz","content":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n"},{"title":"【ES6学习笔记】之 解构赋值","date":"2023-08-13T06:23:26.686Z","_content":"\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","raw":"---\ntitle: 【ES6学习笔记】之 解构赋值\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 解构]\n---\n\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值","published":1,"updated":"2023-08-14T04:08:06.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprk000sxw2v2w4k3h8u","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n"},{"title":"【ES6学习笔记】之 变量","date":"2023-08-13T06:16:23.737Z","_content":"\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","raw":"---\ntitle: 【ES6学习笔记】之 变量\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 变量]\n---\n\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之 变量","published":1,"updated":"2023-08-14T04:07:03.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprl000uxw2v2d53ep91","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n"},{"title":"【跟着大佬学JavaScript】之节流","date":"2022-07-08T16:07:09.822Z","_content":"\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之节流\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 节流]\n---\n\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流","published":1,"updated":"2023-08-14T04:11:58.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprl000yxw2vhqoue0s8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n"},{"title":"【跟着大佬学JavaScript】之数组去重（结果对比）","date":"2022-07-20T15:36:24.591Z","_content":"\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之数组去重（结果对比）\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 数组去重]\n---\n\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）","published":1,"updated":"2023-08-14T04:11:10.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprm0010xw2v71lw0e3h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n"},{"title":"【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线","date":"2022-03-10T03:38:24.514Z","_content":"\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","source":"_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","raw":"---\ntitle: 【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, xAxis]\n---\n\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","slug":"Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线","published":1,"updated":"2023-08-13T12:00:34.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfprn0014xw2v0n8919to","content":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"【跟着大佬学JavaScript】之防抖","date":"2022-07-08T12:04:06.597Z","_content":"\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之防抖\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 防抖]\n---\n\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖","published":1,"updated":"2023-08-14T04:12:31.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfps4004fxw2veunn6k5k","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n"},{"title":"【跟着大佬学JavaScript】之lodash防抖节流合并","date":"2022-07-09T17:12:41.328Z","_content":"\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之lodash防抖节流合并\ndate:\ntags: [JavaScript, lodash]\ncategories: [前端, JavaScript, lodash源码分析, 防抖节流]\n---\n\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并","published":1,"updated":"2023-08-14T04:10:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfps6004gxw2v9o71eusi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n"},{"title":"JavaScript面试汇总","date":"2023-08-17T01:11:31.777Z","_content":"\n### 前言\n\n日常 js 面试题积累汇总。持续更新！\n\n### 1.JavaScript 的基本数据类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbel`（ES6 新增）、`BigInt`(ES10 新增)  \nObject 是 JavaScript 中所有对象的父对象  \n数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、和`String`  \n其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`  \n[js 数据类型](https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md)\n\n</p>\n</details>\n\n---\n\n### 2.JavaScript 的引用类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `Object `\n- `Function`\n- `Array`\n- `Date`\n- `RegExp`\n</p>\n</details>\n\n---\n\n### 3.Javascript 基本数据类型和引用类型的特点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.基本数据类型：值不可变；数据存放在栈区。  \n2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。\n\n</p>\n</details>\n\n---\n\n### 4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.`typeof`：不能判断 null 和区分 Array/Date/RegExp\n- 2.`instanceof`：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；\n- 3.`constructor`：无法检测 null 和 undefined；未必准确\n- 4.`Object.prototype.toString.call()`：无；全能方法；\n</p>\n</details>\n\n---\n\n### 5.JavaScript 基本数据类型和非基本数据类型的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.目前 JS 中有 6 种基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`和`Symbel`（ES6 新增）。还有一种复杂数据类型----`Object`,`Object`本质上是由一组无序的名值对组成的，`Object`、`Fuction`、`Array`则属于引用类型。\n- 2.基本数据类型是不可变的，而非基本数据类型是可变的。\n- 3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。\n- 4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。\n- 5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。\n</p>\n</details>\n\n---\n\n### 6.instanceof 操作符\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n判断对象属于某一个类，回去查找对象的 constructor 的 prototype\n\n</p>\n</details>\n\n---\n\n### 7.new 操作符的作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 新生了一个对象\n- 链接到原型(该对象继承该函数的原型，更改了原型链的指向)\n- 绑定 this\n- 返回对象\n\n```javascript\nfunction newCreate() {\n  // 创建一个空白对象\n  let obj = new Object()\n  // 获得构造函数\n  let Con = [].shift.call(arguments)\n  // 链接到原型\n  obj.__proto__ = Con.prototype\n  // 绑定this,执行构造函数\n  let result = Con.apply(obj, arguments)\n  // 确保new出来的是个对象\n  return typeof result === 'object' ? result : obj\n}\n```\n\n</p>\n</details>\n\n---\n\n### 8.作用域和作用域链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[静态作用域与动态作用域](https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md)\n\n#### 1.作用域\n\n- 种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。\n- 概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。\n- 使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。\n\n#### 2.作用域链\n\n- 一个变量的访问规则的链式操作\n- 可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量\n- 当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined\n</p>\n</details>\n\n---\n\n### 9.闭包\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.特点：\n\n- 内层作用域可以访问外层作用域的变量\n- 闭包就是可以读取其他函数内部变量的函数\n- 函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包\n- 闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量\n\n  2.优点\n\n- 使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值\n- 可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装\n- 解决 var 声明的循环语句变量无法长久保存的问题\n\n  3.缺点\n\n- 滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null\n- 由于函数闭包的变量都保存在内存中，会导致内存消耗大\n</p>\n</details>\n\n---\n\n### 10.null 和 undefined 的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`undefined`: 表示缺少值，即此处应该有值，但没有定义。\n\n- 声明一个变量,这个变量的值就自动被赋予了`undefined`;\n\n```javascript\nvar a\n// undefined\n```\n\n- 调用函数时，应该被提供的参数没有提供，该参数等于`undefined`;\n\n- 对象没有赋值的属性，该属性为`undefined`;\n\n- 函数没有返回值，默认返回`undefined`;\n\n`null`：表示没有对象，即此处不应该有值。\n\n- 作为函数的参数，表示该函数的参数不是对象;\n- 作为对象原型链的终点。\n\n其他方面的区别：  \n（1）数据类型的区别\n\n```javascript\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // Object\n```\n\n**注意：这是 JS 设计的一个失误**\n\n（2）转为数值的区别\n\n```javascript\nlet num1 = 5 + null // 5\nlet num2 = 5 + undefined // NaN\n```\n\n（3)`null !== undefined`\n\n```javascript\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\n```\n\n</p>\n</details>\n\n---\n\n### 11.原型和原型链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[原型和原型链](https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md)\n\n</p>\n</details>\n\n---\n\n### 12.var，let 和 const 有什么区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n  **变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n  `let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n</p>\n</details>\n\n---\n\n### 13.`call()`、`apply()`、`bind()`的区别和作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。\n\n区别：（接受参数的方式不同、改变 this 指向后的处理不同）  \n`call()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n`apply()`的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.apply(obj, [varl, var2， var3])\n```\n\n`bind()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n</p>\n</details>\n\n---\n\n### 14.`cookie`、`localStorage`、`sessionStorage`的异同点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n|      分类      |                                生命周期                                 |                存储容量                |                  储存位置                  |                 应用场景                 |   浏览器兼容性   |\n| :------------: | :---------------------------------------------------------------------: | :------------------------------------: | :----------------------------------------: | :--------------------------------------: | :--------------: |\n|     cookie     | 默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效) |                  4kb                   |        保存在客户端每次请求都会带上        |     用户的部分不重要信息或者登录信息     | 兼容性完全没问题 |\n|  localStorage  |                       理论上永久有效,除非主动清除                       | 4.98M(不同浏览器情况不同，safari2.49M) | 保存在客户端，不与服务端交互，节省网络流量 | 适合持久化缓存数据，比如页面的偏好配置等 | IE8+以上的浏览器 |\n| sessionStorage |           仅在当前网页会话下有效，关闭页面或浏览器后会被清除            |       4.98M(部分浏览器没有限制)        | 保存在客户端，不与服务端交互，节省网络流量 |          适合一次性临时数据缓存          | IE8+以上的浏览器 |\n\n注意点：\n\n- `localStorage`写入的时候如果超出容量会报错，但之前保存的数据不会丢失。\n- `localStorage`存储量快要满的时候，`getItem`的性能会急剧下降。\n- `webStorage(localStorage、sessionStorage)`在保存复杂数据类型时，较为依赖`JSON.stringify()`在移动端性能问题比较明显。\n</p>\n</details>\n\n---\n\n### 15.HTTP、HTTPS 有什么联系，端口号是多少？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。\n\n</p>\n</details>\n\n---\n\n### 16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。  \n在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL/TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。\n\n</p>\n</details>\n\n---\n\n### 17.HTTP/2\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。  \n> 提供更多的加密支持。  \n> 使用多路线路，允许多个消息在一个连接上同时交差。  \n> 增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。\n\n</p>\n</details>\n\n---\n\n### 18.HTTP 常见状态码\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。\n- 200 OK 表示正常返回信息。\n- 201 Created 表示请求成功并且服务器创建了新资源。\n- 202 Accepted 表示服务器已接受请求，但尚未处理。\n- 301 Moved Permanently 表示请求的网页已永久移动到新位置。\n- 302 Found 表示临时重定向。\n- 303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。\n- 304 Not Modified 表示自从上次请求后，请求网页未修改。\n- 400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。\n- 401 Unauthorized 表示请求未授权。\n- 403 Forbidden 表示禁止访问。\n- 404 Not Found 表示找不到如何与 URI 匹配的资源。\n- 500 Internet Server error 表示最常见的服务端的错误。\n- 503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。\n\n</p>\n</details>\n\n---\n\n### 19.无状态协议？如何克服无状态协议缺陷？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。  \n克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。\n\n</p>\n</details>\n\n---\n\n### 20.HTTP 请求报文和响应报文包括哪些部分？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n请求报文：\n\n- 请求行，包含请求方法、URI、HTTP 版本信息。\n- 请求首部字段。\n- 请求内容实体。\n\n响应报文：\n\n- 状态行，包括 HTTP 版本，状态码，状态码的原因短语。\n- 响应首部字段。\n- 响应内容实体。\n\n</p>\n</details>\n\n---\n\n### 21.HTTP 请求方式\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。\n- POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。\n- PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。\n- HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。\n- OPTIONS:查询相应 URI 支持的 HTTP 方法。\n\n</p>\n</details>\n\n---\n\n### 22.HTTP 首部字段包括哪些类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 通用首部字段(请求报文和响应报文都会使用的首部字段)。\n\n  > `Date`:创建报文的时间。  \n  > `Connection`:连接的管理。  \n  > `Cache-Control`:缓存机制。  \n  > `Transfer-Encoding`:报文主体的传输编码方式。\n\n- 请求首部字段（请求报文会使用的首部字段）。\n\n  > `Host`: 请求资源所在的服务器。  \n  > `Accept`: 可处理的媒体类型。  \n  > `Accept-Charset`: 可接受的字符集。  \n  > `Accept-Encoding`: 可接受的内容编码。  \n  > `Accept-Language`: 可接受的自然语言。\n\n- 响应首部字段（响应报文会使用的字段）。\n\n  > `Accept-Ranges`: 可接受的字节范围。  \n  > `Location`: 令客户端重新定向到的 URL。\n\n- 实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。\n  > `Allow`: 资源可支持的 HTTP 方法。  \n  > `Content-Type`: 实体主体的类型。  \n  > `Content-Encoding`: 实体主体使用的编码方式。  \n  > `Content-Language`: 实体主体的自然语言。  \n  > `Content-Length`: 实体主体的字节数。\n  > `Content-Range`: 实体主体的位置范围，一般用于发出部分请求时使用。\n\n</p>\n</details>\n\n---\n\n### 22.`GET`和`POST`的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `GET`一般用于获取/查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而`POST`一般用于更新资源信息，会修改服务器上的资源信息。\n- `GET`请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；`POST`把提交的数据放在 HTTP 的 requset body 中。\n- `GET`方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲`POST`是没有大小限制的。\n- 在 ASP 中，服务端获取`GET`请求参数用 Requset.QueryString;获取`POST`的请求参数用 Requset.Form。\n- `POST`比`GET`安全性更高：`GET`提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。\n\n</p>\n</details>\n\n---\n\n### 23.网站性能优化\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- [x] [网站性能优化实战](https://juejin.cn/post/6844903613790175240)\n- [x] [网站性能优化实战(二)](https://imweb.io/topic/5b4d417eee0c3b0779df96d9)\n- [x] [网站性能优化实战篇](https://segmentfault.com/a/1190000021098540)\n\n基本优化：\n\n- 图片压缩合并；\n- 代码精简、混淆；\n- 减少`iframe`使用；\n- 避免图片`src`为空；\n- 减少`HTTP`请求数；\n- 避免重定向；\n- 样式表放页头、脚本放底部；\n\n网站性能优化总结：  \n(一)网络传输性能优化————重定向——>拉取缓存——>DNS 查询——>建立 TCP 链接——>发起请求——>处理 HTML 元素——>元素加载完成\n\n- 浏览器缓存。\n- 资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！\n- 图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;\n- 网络传输性能检查工具————Page Speed。\n- 使用 CDN。\n\n(二)页面性能优化————处理 HTML 标记并构建 DOM 树——>处理 CSS 标记并构建 CSSOM 树——>将 DOM 和 CSSOM 合并成一个 render 渲染树——>根据渲染树来布局，以计算每个节点的几何信息——>将每个节点绘制在屏幕上\n\n- DOM 渲染层与 GPU 硬件加速。\n- 降低重绘和重排的频率和成本。\n\n总结：\n\n> CSS 读写分离：不用 js 操作元素样式。  \n> 通过切换 class 或使用 style.csstext 属性批量操作元素样式。  \n> DOM 元素离线更新。  \n> 将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。  \n> 压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。  \n> 图片在渲染前指定大小。  \n> 降低重绘和重排的频率和成本。\n\n</p>\n</details>\n\n---\n","source":"_posts/JavaScript/JavaScript面试/JavaScript面试.md","raw":"---\ntitle: JavaScript面试汇总\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, JavaScript面试]\n---\n\n### 前言\n\n日常 js 面试题积累汇总。持续更新！\n\n### 1.JavaScript 的基本数据类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbel`（ES6 新增）、`BigInt`(ES10 新增)  \nObject 是 JavaScript 中所有对象的父对象  \n数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、和`String`  \n其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`  \n[js 数据类型](https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md)\n\n</p>\n</details>\n\n---\n\n### 2.JavaScript 的引用类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `Object `\n- `Function`\n- `Array`\n- `Date`\n- `RegExp`\n</p>\n</details>\n\n---\n\n### 3.Javascript 基本数据类型和引用类型的特点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.基本数据类型：值不可变；数据存放在栈区。  \n2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。\n\n</p>\n</details>\n\n---\n\n### 4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.`typeof`：不能判断 null 和区分 Array/Date/RegExp\n- 2.`instanceof`：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；\n- 3.`constructor`：无法检测 null 和 undefined；未必准确\n- 4.`Object.prototype.toString.call()`：无；全能方法；\n</p>\n</details>\n\n---\n\n### 5.JavaScript 基本数据类型和非基本数据类型的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.目前 JS 中有 6 种基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`和`Symbel`（ES6 新增）。还有一种复杂数据类型----`Object`,`Object`本质上是由一组无序的名值对组成的，`Object`、`Fuction`、`Array`则属于引用类型。\n- 2.基本数据类型是不可变的，而非基本数据类型是可变的。\n- 3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。\n- 4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。\n- 5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。\n</p>\n</details>\n\n---\n\n### 6.instanceof 操作符\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n判断对象属于某一个类，回去查找对象的 constructor 的 prototype\n\n</p>\n</details>\n\n---\n\n### 7.new 操作符的作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 新生了一个对象\n- 链接到原型(该对象继承该函数的原型，更改了原型链的指向)\n- 绑定 this\n- 返回对象\n\n```javascript\nfunction newCreate() {\n  // 创建一个空白对象\n  let obj = new Object()\n  // 获得构造函数\n  let Con = [].shift.call(arguments)\n  // 链接到原型\n  obj.__proto__ = Con.prototype\n  // 绑定this,执行构造函数\n  let result = Con.apply(obj, arguments)\n  // 确保new出来的是个对象\n  return typeof result === 'object' ? result : obj\n}\n```\n\n</p>\n</details>\n\n---\n\n### 8.作用域和作用域链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[静态作用域与动态作用域](https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md)\n\n#### 1.作用域\n\n- 种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。\n- 概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。\n- 使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。\n\n#### 2.作用域链\n\n- 一个变量的访问规则的链式操作\n- 可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量\n- 当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined\n</p>\n</details>\n\n---\n\n### 9.闭包\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.特点：\n\n- 内层作用域可以访问外层作用域的变量\n- 闭包就是可以读取其他函数内部变量的函数\n- 函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包\n- 闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量\n\n  2.优点\n\n- 使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值\n- 可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装\n- 解决 var 声明的循环语句变量无法长久保存的问题\n\n  3.缺点\n\n- 滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null\n- 由于函数闭包的变量都保存在内存中，会导致内存消耗大\n</p>\n</details>\n\n---\n\n### 10.null 和 undefined 的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`undefined`: 表示缺少值，即此处应该有值，但没有定义。\n\n- 声明一个变量,这个变量的值就自动被赋予了`undefined`;\n\n```javascript\nvar a\n// undefined\n```\n\n- 调用函数时，应该被提供的参数没有提供，该参数等于`undefined`;\n\n- 对象没有赋值的属性，该属性为`undefined`;\n\n- 函数没有返回值，默认返回`undefined`;\n\n`null`：表示没有对象，即此处不应该有值。\n\n- 作为函数的参数，表示该函数的参数不是对象;\n- 作为对象原型链的终点。\n\n其他方面的区别：  \n（1）数据类型的区别\n\n```javascript\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // Object\n```\n\n**注意：这是 JS 设计的一个失误**\n\n（2）转为数值的区别\n\n```javascript\nlet num1 = 5 + null // 5\nlet num2 = 5 + undefined // NaN\n```\n\n（3)`null !== undefined`\n\n```javascript\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\n```\n\n</p>\n</details>\n\n---\n\n### 11.原型和原型链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[原型和原型链](https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md)\n\n</p>\n</details>\n\n---\n\n### 12.var，let 和 const 有什么区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n  **变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n  `let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n</p>\n</details>\n\n---\n\n### 13.`call()`、`apply()`、`bind()`的区别和作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。\n\n区别：（接受参数的方式不同、改变 this 指向后的处理不同）  \n`call()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n`apply()`的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.apply(obj, [varl, var2， var3])\n```\n\n`bind()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n</p>\n</details>\n\n---\n\n### 14.`cookie`、`localStorage`、`sessionStorage`的异同点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n|      分类      |                                生命周期                                 |                存储容量                |                  储存位置                  |                 应用场景                 |   浏览器兼容性   |\n| :------------: | :---------------------------------------------------------------------: | :------------------------------------: | :----------------------------------------: | :--------------------------------------: | :--------------: |\n|     cookie     | 默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效) |                  4kb                   |        保存在客户端每次请求都会带上        |     用户的部分不重要信息或者登录信息     | 兼容性完全没问题 |\n|  localStorage  |                       理论上永久有效,除非主动清除                       | 4.98M(不同浏览器情况不同，safari2.49M) | 保存在客户端，不与服务端交互，节省网络流量 | 适合持久化缓存数据，比如页面的偏好配置等 | IE8+以上的浏览器 |\n| sessionStorage |           仅在当前网页会话下有效，关闭页面或浏览器后会被清除            |       4.98M(部分浏览器没有限制)        | 保存在客户端，不与服务端交互，节省网络流量 |          适合一次性临时数据缓存          | IE8+以上的浏览器 |\n\n注意点：\n\n- `localStorage`写入的时候如果超出容量会报错，但之前保存的数据不会丢失。\n- `localStorage`存储量快要满的时候，`getItem`的性能会急剧下降。\n- `webStorage(localStorage、sessionStorage)`在保存复杂数据类型时，较为依赖`JSON.stringify()`在移动端性能问题比较明显。\n</p>\n</details>\n\n---\n\n### 15.HTTP、HTTPS 有什么联系，端口号是多少？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。\n\n</p>\n</details>\n\n---\n\n### 16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。  \n在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL/TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。\n\n</p>\n</details>\n\n---\n\n### 17.HTTP/2\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。  \n> 提供更多的加密支持。  \n> 使用多路线路，允许多个消息在一个连接上同时交差。  \n> 增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。\n\n</p>\n</details>\n\n---\n\n### 18.HTTP 常见状态码\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。\n- 200 OK 表示正常返回信息。\n- 201 Created 表示请求成功并且服务器创建了新资源。\n- 202 Accepted 表示服务器已接受请求，但尚未处理。\n- 301 Moved Permanently 表示请求的网页已永久移动到新位置。\n- 302 Found 表示临时重定向。\n- 303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。\n- 304 Not Modified 表示自从上次请求后，请求网页未修改。\n- 400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。\n- 401 Unauthorized 表示请求未授权。\n- 403 Forbidden 表示禁止访问。\n- 404 Not Found 表示找不到如何与 URI 匹配的资源。\n- 500 Internet Server error 表示最常见的服务端的错误。\n- 503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。\n\n</p>\n</details>\n\n---\n\n### 19.无状态协议？如何克服无状态协议缺陷？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。  \n克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。\n\n</p>\n</details>\n\n---\n\n### 20.HTTP 请求报文和响应报文包括哪些部分？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n请求报文：\n\n- 请求行，包含请求方法、URI、HTTP 版本信息。\n- 请求首部字段。\n- 请求内容实体。\n\n响应报文：\n\n- 状态行，包括 HTTP 版本，状态码，状态码的原因短语。\n- 响应首部字段。\n- 响应内容实体。\n\n</p>\n</details>\n\n---\n\n### 21.HTTP 请求方式\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。\n- POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。\n- PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。\n- HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。\n- OPTIONS:查询相应 URI 支持的 HTTP 方法。\n\n</p>\n</details>\n\n---\n\n### 22.HTTP 首部字段包括哪些类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 通用首部字段(请求报文和响应报文都会使用的首部字段)。\n\n  > `Date`:创建报文的时间。  \n  > `Connection`:连接的管理。  \n  > `Cache-Control`:缓存机制。  \n  > `Transfer-Encoding`:报文主体的传输编码方式。\n\n- 请求首部字段（请求报文会使用的首部字段）。\n\n  > `Host`: 请求资源所在的服务器。  \n  > `Accept`: 可处理的媒体类型。  \n  > `Accept-Charset`: 可接受的字符集。  \n  > `Accept-Encoding`: 可接受的内容编码。  \n  > `Accept-Language`: 可接受的自然语言。\n\n- 响应首部字段（响应报文会使用的字段）。\n\n  > `Accept-Ranges`: 可接受的字节范围。  \n  > `Location`: 令客户端重新定向到的 URL。\n\n- 实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。\n  > `Allow`: 资源可支持的 HTTP 方法。  \n  > `Content-Type`: 实体主体的类型。  \n  > `Content-Encoding`: 实体主体使用的编码方式。  \n  > `Content-Language`: 实体主体的自然语言。  \n  > `Content-Length`: 实体主体的字节数。\n  > `Content-Range`: 实体主体的位置范围，一般用于发出部分请求时使用。\n\n</p>\n</details>\n\n---\n\n### 22.`GET`和`POST`的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `GET`一般用于获取/查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而`POST`一般用于更新资源信息，会修改服务器上的资源信息。\n- `GET`请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；`POST`把提交的数据放在 HTTP 的 requset body 中。\n- `GET`方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲`POST`是没有大小限制的。\n- 在 ASP 中，服务端获取`GET`请求参数用 Requset.QueryString;获取`POST`的请求参数用 Requset.Form。\n- `POST`比`GET`安全性更高：`GET`提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。\n\n</p>\n</details>\n\n---\n\n### 23.网站性能优化\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- [x] [网站性能优化实战](https://juejin.cn/post/6844903613790175240)\n- [x] [网站性能优化实战(二)](https://imweb.io/topic/5b4d417eee0c3b0779df96d9)\n- [x] [网站性能优化实战篇](https://segmentfault.com/a/1190000021098540)\n\n基本优化：\n\n- 图片压缩合并；\n- 代码精简、混淆；\n- 减少`iframe`使用；\n- 避免图片`src`为空；\n- 减少`HTTP`请求数；\n- 避免重定向；\n- 样式表放页头、脚本放底部；\n\n网站性能优化总结：  \n(一)网络传输性能优化————重定向——>拉取缓存——>DNS 查询——>建立 TCP 链接——>发起请求——>处理 HTML 元素——>元素加载完成\n\n- 浏览器缓存。\n- 资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！\n- 图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;\n- 网络传输性能检查工具————Page Speed。\n- 使用 CDN。\n\n(二)页面性能优化————处理 HTML 标记并构建 DOM 树——>处理 CSS 标记并构建 CSSOM 树——>将 DOM 和 CSSOM 合并成一个 render 渲染树——>根据渲染树来布局，以计算每个节点的几何信息——>将每个节点绘制在屏幕上\n\n- DOM 渲染层与 GPU 硬件加速。\n- 降低重绘和重排的频率和成本。\n\n总结：\n\n> CSS 读写分离：不用 js 操作元素样式。  \n> 通过切换 class 或使用 style.csstext 属性批量操作元素样式。  \n> DOM 元素离线更新。  \n> 将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。  \n> 压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。  \n> 图片在渲染前指定大小。  \n> 降低重绘和重排的频率和成本。\n\n</p>\n</details>\n\n---\n","slug":"JavaScript/JavaScript面试/JavaScript面试","published":1,"updated":"2023-08-17T01:20:30.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllehfpsc004wxw2vhdlcbqut","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常 js 面试题积累汇总。持续更新！</p>\n<h3 id=\"1-JavaScript-的基本数据类型\"><a href=\"#1-JavaScript-的基本数据类型\" class=\"headerlink\" title=\"1.JavaScript 的基本数据类型\"></a>1.JavaScript 的基本数据类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbel</code>（ES6 新增）、<code>BigInt</code>(ES10 新增)<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、和<code>String</code><br>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code><br><a href=\"https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md\">js 数据类型</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"2-JavaScript-的引用类型\"><a href=\"#2-JavaScript-的引用类型\" class=\"headerlink\" title=\"2.JavaScript 的引用类型\"></a>2.JavaScript 的引用类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>Object </code></li>\n<li><code>Function</code></li>\n<li><code>Array</code></li>\n<li><code>Date</code></li>\n<li><code>RegExp</code></p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"3-Javascript-基本数据类型和引用类型的特点\"><a href=\"#3-Javascript-基本数据类型和引用类型的特点\" class=\"headerlink\" title=\"3.Javascript 基本数据类型和引用类型的特点\"></a>3.Javascript 基本数据类型和引用类型的特点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.基本数据类型：值不可变；数据存放在栈区。<br>2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\"><a href=\"#4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\" class=\"headerlink\" title=\"4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\"></a>4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.<code>typeof</code>：不能判断 null 和区分 Array&#x2F;Date&#x2F;RegExp</li>\n<li>2.<code>instanceof</code>：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；</li>\n<li>3.<code>constructor</code>：无法检测 null 和 undefined；未必准确</li>\n<li>4.<code>Object.prototype.toString.call()</code>：无；全能方法；</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"5-JavaScript-基本数据类型和非基本数据类型的区别\"><a href=\"#5-JavaScript-基本数据类型和非基本数据类型的区别\" class=\"headerlink\" title=\"5.JavaScript 基本数据类型和非基本数据类型的区别\"></a>5.JavaScript 基本数据类型和非基本数据类型的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.目前 JS 中有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbel</code>（ES6 新增）。还有一种复杂数据类型—-<code>Object</code>,<code>Object</code>本质上是由一组无序的名值对组成的，<code>Object</code>、<code>Fuction</code>、<code>Array</code>则属于引用类型。</li>\n<li>2.基本数据类型是不可变的，而非基本数据类型是可变的。</li>\n<li>3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。</li>\n<li>4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。</li>\n<li>5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"6-instanceof-操作符\"><a href=\"#6-instanceof-操作符\" class=\"headerlink\" title=\"6.instanceof 操作符\"></a>6.instanceof 操作符</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-5\"><a href=\"#答案-5\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>判断对象属于某一个类，回去查找对象的 constructor 的 prototype</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"7-new-操作符的作用\"><a href=\"#7-new-操作符的作用\" class=\"headerlink\" title=\"7.new 操作符的作用\"></a>7.new 操作符的作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-6\"><a href=\"#答案-6\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>新生了一个对象</li>\n<li>链接到原型(该对象继承该函数的原型，更改了原型链的指向)</li>\n<li>绑定 this</li>\n<li>返回对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">newCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个空白对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()</span><br><span class=\"line\">  <span class=\"comment\">// 获得构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">Con</span> = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 链接到原型</span></span><br><span class=\"line\">  obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Con</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\">  <span class=\"comment\">// 绑定this,执行构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title class_\">Con</span>.<span class=\"title function_\">apply</span>(obj, <span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 确保new出来的是个对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"8-作用域和作用域链\"><a href=\"#8-作用域和作用域链\" class=\"headerlink\" title=\"8.作用域和作用域链\"></a>8.作用域和作用域链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-7\"><a href=\"#答案-7\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md\">静态作用域与动态作用域</a></p>\n<h4 id=\"1-作用域\"><a href=\"#1-作用域\" class=\"headerlink\" title=\"1.作用域\"></a>1.作用域</h4><ul>\n<li>种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。</li>\n<li>概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。</li>\n<li>使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。</li>\n</ul>\n<h4 id=\"2-作用域链\"><a href=\"#2-作用域链\" class=\"headerlink\" title=\"2.作用域链\"></a>2.作用域链</h4><ul>\n<li>一个变量的访问规则的链式操作</li>\n<li>可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量</li>\n<li>当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"9-闭包\"><a href=\"#9-闭包\" class=\"headerlink\" title=\"9.闭包\"></a>9.闭包</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-8\"><a href=\"#答案-8\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.特点：</p>\n<ul>\n<li><p>内层作用域可以访问外层作用域的变量</p>\n</li>\n<li><p>闭包就是可以读取其他函数内部变量的函数</p>\n</li>\n<li><p>函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包</p>\n</li>\n<li><p>闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量</p>\n<p>2.优点</p>\n</li>\n<li><p>使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值</p>\n</li>\n<li><p>可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装</p>\n</li>\n<li><p>解决 var 声明的循环语句变量无法长久保存的问题</p>\n<p>3.缺点</p>\n</li>\n<li><p>滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null</p>\n</li>\n<li><p>由于函数闭包的变量都保存在内存中，会导致内存消耗大</p>\n</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"10-null-和-undefined-的区别\"><a href=\"#10-null-和-undefined-的区别\" class=\"headerlink\" title=\"10.null 和 undefined 的区别\"></a>10.null 和 undefined 的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-9\"><a href=\"#答案-9\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>undefined</code>: 表示缺少值，即此处应该有值，但没有定义。</p>\n<ul>\n<li>声明一个变量,这个变量的值就自动被赋予了<code>undefined</code>;</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>调用函数时，应该被提供的参数没有提供，该参数等于<code>undefined</code>;</p>\n</li>\n<li><p>对象没有赋值的属性，该属性为<code>undefined</code>;</p>\n</li>\n<li><p>函数没有返回值，默认返回<code>undefined</code>;</p>\n</li>\n</ul>\n<p><code>null</code>：表示没有对象，即此处不应该有值。</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象;</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n<p>其他方面的区别：<br>（1）数据类型的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这是 JS 设计的一个失误</strong></p>\n<p>（2）转为数值的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">5</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">5</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>（3)<code>null !== undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"11-原型和原型链\"><a href=\"#11-原型和原型链\" class=\"headerlink\" title=\"11.原型和原型链\"></a>11.原型和原型链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-10\"><a href=\"#答案-10\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md\">原型和原型链</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"12-var，let-和-const-有什么区别\"><a href=\"#12-var，let-和-const-有什么区别\" class=\"headerlink\" title=\"12.var，let 和 const 有什么区别\"></a>12.var，let 和 const 有什么区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-11\"><a href=\"#答案-11\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：<br><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</li>\n</ul>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"13-call-、apply-、bind-的区别和作用\"><a href=\"#13-call-、apply-、bind-的区别和作用\" class=\"headerlink\" title=\"13.call()、apply()、bind()的区别和作用\"></a>13.<code>call()</code>、<code>apply()</code>、<code>bind()</code>的区别和作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-12\"><a href=\"#答案-12\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。</p>\n</blockquote>\n<p>区别：（接受参数的方式不同、改变 this 指向后的处理不同）<br><code>call()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n<p><code>apply()</code>的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">apply</span>(obj, [varl, var2， var3])</span><br></pre></td></tr></table></figure>\n\n<p><code>bind()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"14-cookie、localStorage、sessionStorage的异同点\"><a href=\"#14-cookie、localStorage、sessionStorage的异同点\" class=\"headerlink\" title=\"14.cookie、localStorage、sessionStorage的异同点\"></a>14.<code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>的异同点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-13\"><a href=\"#答案-13\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"center\">生命周期</th>\n<th align=\"center\">存储容量</th>\n<th align=\"center\">储存位置</th>\n<th align=\"center\">应用场景</th>\n<th align=\"center\">浏览器兼容性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cookie</td>\n<td align=\"center\">默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效)</td>\n<td align=\"center\">4kb</td>\n<td align=\"center\">保存在客户端每次请求都会带上</td>\n<td align=\"center\">用户的部分不重要信息或者登录信息</td>\n<td align=\"center\">兼容性完全没问题</td>\n</tr>\n<tr>\n<td align=\"center\">localStorage</td>\n<td align=\"center\">理论上永久有效,除非主动清除</td>\n<td align=\"center\">4.98M(不同浏览器情况不同，safari2.49M)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合持久化缓存数据，比如页面的偏好配置等</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n<tr>\n<td align=\"center\">sessionStorage</td>\n<td align=\"center\">仅在当前网页会话下有效，关闭页面或浏览器后会被清除</td>\n<td align=\"center\">4.98M(部分浏览器没有限制)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合一次性临时数据缓存</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><code>localStorage</code>写入的时候如果超出容量会报错，但之前保存的数据不会丢失。</li>\n<li><code>localStorage</code>存储量快要满的时候，<code>getItem</code>的性能会急剧下降。</li>\n<li><code>webStorage(localStorage、sessionStorage)</code>在保存复杂数据类型时，较为依赖<code>JSON.stringify()</code>在移动端性能问题比较明显。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"15-HTTP、HTTPS-有什么联系，端口号是多少？\"><a href=\"#15-HTTP、HTTPS-有什么联系，端口号是多少？\" class=\"headerlink\" title=\"15.HTTP、HTTPS 有什么联系，端口号是多少？\"></a>15.HTTP、HTTPS 有什么联系，端口号是多少？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-14\"><a href=\"#答案-14\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\"><a href=\"#16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\" class=\"headerlink\" title=\"16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\"></a>16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-15\"><a href=\"#答案-15\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。<br>在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL&#x2F;TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"17-HTTP-2\"><a href=\"#17-HTTP-2\" class=\"headerlink\" title=\"17.HTTP&#x2F;2\"></a>17.HTTP&#x2F;2</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-16\"><a href=\"#答案-16\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。<br>提供更多的加密支持。<br>使用多路线路，允许多个消息在一个连接上同时交差。<br>增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n<h3 id=\"18-HTTP-常见状态码\"><a href=\"#18-HTTP-常见状态码\" class=\"headerlink\" title=\"18.HTTP 常见状态码\"></a>18.HTTP 常见状态码</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-17\"><a href=\"#答案-17\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。</li>\n<li>200 OK 表示正常返回信息。</li>\n<li>201 Created 表示请求成功并且服务器创建了新资源。</li>\n<li>202 Accepted 表示服务器已接受请求，但尚未处理。</li>\n<li>301 Moved Permanently 表示请求的网页已永久移动到新位置。</li>\n<li>302 Found 表示临时重定向。</li>\n<li>303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 表示自从上次请求后，请求网页未修改。</li>\n<li>400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 表示请求未授权。</li>\n<li>403 Forbidden 表示禁止访问。</li>\n<li>404 Not Found 表示找不到如何与 URI 匹配的资源。</li>\n<li>500 Internet Server error 表示最常见的服务端的错误。</li>\n<li>503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"19-无状态协议？如何克服无状态协议缺陷？\"><a href=\"#19-无状态协议？如何克服无状态协议缺陷？\" class=\"headerlink\" title=\"19.无状态协议？如何克服无状态协议缺陷？\"></a>19.无状态协议？如何克服无状态协议缺陷？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-18\"><a href=\"#答案-18\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。<br>克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"20-HTTP-请求报文和响应报文包括哪些部分？\"><a href=\"#20-HTTP-请求报文和响应报文包括哪些部分？\" class=\"headerlink\" title=\"20.HTTP 请求报文和响应报文包括哪些部分？\"></a>20.HTTP 请求报文和响应报文包括哪些部分？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-19\"><a href=\"#答案-19\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>请求报文：</p>\n<ul>\n<li>请求行，包含请求方法、URI、HTTP 版本信息。</li>\n<li>请求首部字段。</li>\n<li>请求内容实体。</li>\n</ul>\n<p>响应报文：</p>\n<ul>\n<li>状态行，包括 HTTP 版本，状态码，状态码的原因短语。</li>\n<li>响应首部字段。</li>\n<li>响应内容实体。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"21-HTTP-请求方式\"><a href=\"#21-HTTP-请求方式\" class=\"headerlink\" title=\"21.HTTP 请求方式\"></a>21.HTTP 请求方式</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-20\"><a href=\"#答案-20\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。</li>\n<li>POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。</li>\n<li>PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。</li>\n<li>HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li>DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。</li>\n<li>OPTIONS:查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-HTTP-首部字段包括哪些类型\"><a href=\"#22-HTTP-首部字段包括哪些类型\" class=\"headerlink\" title=\"22.HTTP 首部字段包括哪些类型\"></a>22.HTTP 首部字段包括哪些类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-21\"><a href=\"#答案-21\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><p>通用首部字段(请求报文和响应报文都会使用的首部字段)。</p>\n<blockquote>\n<p><code>Date</code>:创建报文的时间。<br><code>Connection</code>:连接的管理。<br><code>Cache-Control</code>:缓存机制。<br><code>Transfer-Encoding</code>:报文主体的传输编码方式。</p>\n</blockquote>\n</li>\n<li><p>请求首部字段（请求报文会使用的首部字段）。</p>\n<blockquote>\n<p><code>Host</code>: 请求资源所在的服务器。<br><code>Accept</code>: 可处理的媒体类型。<br><code>Accept-Charset</code>: 可接受的字符集。<br><code>Accept-Encoding</code>: 可接受的内容编码。<br><code>Accept-Language</code>: 可接受的自然语言。</p>\n</blockquote>\n</li>\n<li><p>响应首部字段（响应报文会使用的字段）。</p>\n<blockquote>\n<p><code>Accept-Ranges</code>: 可接受的字节范围。<br><code>Location</code>: 令客户端重新定向到的 URL。</p>\n</blockquote>\n</li>\n<li><p>实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。</p>\n<blockquote>\n<p><code>Allow</code>: 资源可支持的 HTTP 方法。<br><code>Content-Type</code>: 实体主体的类型。<br><code>Content-Encoding</code>: 实体主体使用的编码方式。<br><code>Content-Language</code>: 实体主体的自然语言。<br><code>Content-Length</code>: 实体主体的字节数。<br><code>Content-Range</code>: 实体主体的位置范围，一般用于发出部分请求时使用。</p>\n</blockquote>\n</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-GET和POST的区别\"><a href=\"#22-GET和POST的区别\" class=\"headerlink\" title=\"22.GET和POST的区别\"></a>22.<code>GET</code>和<code>POST</code>的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-22\"><a href=\"#答案-22\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>GET</code>一般用于获取&#x2F;查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而<code>POST</code>一般用于更新资源信息，会修改服务器上的资源信息。</li>\n<li><code>GET</code>请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；<code>POST</code>把提交的数据放在 HTTP 的 requset body 中。</li>\n<li><code>GET</code>方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲<code>POST</code>是没有大小限制的。</li>\n<li>在 ASP 中，服务端获取<code>GET</code>请求参数用 Requset.QueryString;获取<code>POST</code>的请求参数用 Requset.Form。</li>\n<li><code>POST</code>比<code>GET</code>安全性更高：<code>GET</code>提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"23-网站性能优化\"><a href=\"#23-网站性能优化\" class=\"headerlink\" title=\"23.网站性能优化\"></a>23.网站性能优化</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-23\"><a href=\"#答案-23\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://juejin.cn/post/6844903613790175240\">网站性能优化实战</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://imweb.io/topic/5b4d417eee0c3b0779df96d9\">网站性能优化实战(二)</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://segmentfault.com/a/1190000021098540\">网站性能优化实战篇</a></li>\n</ul>\n<p>基本优化：</p>\n<ul>\n<li>图片压缩合并；</li>\n<li>代码精简、混淆；</li>\n<li>减少<code>iframe</code>使用；</li>\n<li>避免图片<code>src</code>为空；</li>\n<li>减少<code>HTTP</code>请求数；</li>\n<li>避免重定向；</li>\n<li>样式表放页头、脚本放底部；</li>\n</ul>\n<p>网站性能优化总结：<br>(一)网络传输性能优化————重定向——&gt;拉取缓存——&gt;DNS 查询——&gt;建立 TCP 链接——&gt;发起请求——&gt;处理 HTML 元素——&gt;元素加载完成</p>\n<ul>\n<li>浏览器缓存。</li>\n<li>资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！</li>\n<li>图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;</li>\n<li>网络传输性能检查工具————Page Speed。</li>\n<li>使用 CDN。</li>\n</ul>\n<p>(二)页面性能优化————处理 HTML 标记并构建 DOM 树——&gt;处理 CSS 标记并构建 CSSOM 树——&gt;将 DOM 和 CSSOM 合并成一个 render 渲染树——&gt;根据渲染树来布局，以计算每个节点的几何信息——&gt;将每个节点绘制在屏幕上</p>\n<ul>\n<li>DOM 渲染层与 GPU 硬件加速。</li>\n<li>降低重绘和重排的频率和成本。</li>\n</ul>\n<p>总结：</p>\n<blockquote>\n<p>CSS 读写分离：不用 js 操作元素样式。<br>通过切换 class 或使用 style.csstext 属性批量操作元素样式。<br>DOM 元素离线更新。<br>将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。<br>压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。<br>图片在渲染前指定大小。<br>降低重绘和重排的频率和成本。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常 js 面试题积累汇总。持续更新！</p>\n<h3 id=\"1-JavaScript-的基本数据类型\"><a href=\"#1-JavaScript-的基本数据类型\" class=\"headerlink\" title=\"1.JavaScript 的基本数据类型\"></a>1.JavaScript 的基本数据类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbel</code>（ES6 新增）、<code>BigInt</code>(ES10 新增)<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、和<code>String</code><br>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code><br><a href=\"https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md\">js 数据类型</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"2-JavaScript-的引用类型\"><a href=\"#2-JavaScript-的引用类型\" class=\"headerlink\" title=\"2.JavaScript 的引用类型\"></a>2.JavaScript 的引用类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>Object </code></li>\n<li><code>Function</code></li>\n<li><code>Array</code></li>\n<li><code>Date</code></li>\n<li><code>RegExp</code></p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"3-Javascript-基本数据类型和引用类型的特点\"><a href=\"#3-Javascript-基本数据类型和引用类型的特点\" class=\"headerlink\" title=\"3.Javascript 基本数据类型和引用类型的特点\"></a>3.Javascript 基本数据类型和引用类型的特点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.基本数据类型：值不可变；数据存放在栈区。<br>2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\"><a href=\"#4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\" class=\"headerlink\" title=\"4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\"></a>4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.<code>typeof</code>：不能判断 null 和区分 Array&#x2F;Date&#x2F;RegExp</li>\n<li>2.<code>instanceof</code>：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；</li>\n<li>3.<code>constructor</code>：无法检测 null 和 undefined；未必准确</li>\n<li>4.<code>Object.prototype.toString.call()</code>：无；全能方法；</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"5-JavaScript-基本数据类型和非基本数据类型的区别\"><a href=\"#5-JavaScript-基本数据类型和非基本数据类型的区别\" class=\"headerlink\" title=\"5.JavaScript 基本数据类型和非基本数据类型的区别\"></a>5.JavaScript 基本数据类型和非基本数据类型的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.目前 JS 中有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbel</code>（ES6 新增）。还有一种复杂数据类型—-<code>Object</code>,<code>Object</code>本质上是由一组无序的名值对组成的，<code>Object</code>、<code>Fuction</code>、<code>Array</code>则属于引用类型。</li>\n<li>2.基本数据类型是不可变的，而非基本数据类型是可变的。</li>\n<li>3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。</li>\n<li>4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。</li>\n<li>5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"6-instanceof-操作符\"><a href=\"#6-instanceof-操作符\" class=\"headerlink\" title=\"6.instanceof 操作符\"></a>6.instanceof 操作符</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-5\"><a href=\"#答案-5\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>判断对象属于某一个类，回去查找对象的 constructor 的 prototype</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"7-new-操作符的作用\"><a href=\"#7-new-操作符的作用\" class=\"headerlink\" title=\"7.new 操作符的作用\"></a>7.new 操作符的作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-6\"><a href=\"#答案-6\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>新生了一个对象</li>\n<li>链接到原型(该对象继承该函数的原型，更改了原型链的指向)</li>\n<li>绑定 this</li>\n<li>返回对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">newCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个空白对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()</span><br><span class=\"line\">  <span class=\"comment\">// 获得构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">Con</span> = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 链接到原型</span></span><br><span class=\"line\">  obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Con</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\">  <span class=\"comment\">// 绑定this,执行构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title class_\">Con</span>.<span class=\"title function_\">apply</span>(obj, <span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 确保new出来的是个对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"8-作用域和作用域链\"><a href=\"#8-作用域和作用域链\" class=\"headerlink\" title=\"8.作用域和作用域链\"></a>8.作用域和作用域链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-7\"><a href=\"#答案-7\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md\">静态作用域与动态作用域</a></p>\n<h4 id=\"1-作用域\"><a href=\"#1-作用域\" class=\"headerlink\" title=\"1.作用域\"></a>1.作用域</h4><ul>\n<li>种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。</li>\n<li>概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。</li>\n<li>使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。</li>\n</ul>\n<h4 id=\"2-作用域链\"><a href=\"#2-作用域链\" class=\"headerlink\" title=\"2.作用域链\"></a>2.作用域链</h4><ul>\n<li>一个变量的访问规则的链式操作</li>\n<li>可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量</li>\n<li>当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"9-闭包\"><a href=\"#9-闭包\" class=\"headerlink\" title=\"9.闭包\"></a>9.闭包</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-8\"><a href=\"#答案-8\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.特点：</p>\n<ul>\n<li><p>内层作用域可以访问外层作用域的变量</p>\n</li>\n<li><p>闭包就是可以读取其他函数内部变量的函数</p>\n</li>\n<li><p>函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包</p>\n</li>\n<li><p>闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量</p>\n<p>2.优点</p>\n</li>\n<li><p>使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值</p>\n</li>\n<li><p>可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装</p>\n</li>\n<li><p>解决 var 声明的循环语句变量无法长久保存的问题</p>\n<p>3.缺点</p>\n</li>\n<li><p>滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null</p>\n</li>\n<li><p>由于函数闭包的变量都保存在内存中，会导致内存消耗大</p>\n</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"10-null-和-undefined-的区别\"><a href=\"#10-null-和-undefined-的区别\" class=\"headerlink\" title=\"10.null 和 undefined 的区别\"></a>10.null 和 undefined 的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-9\"><a href=\"#答案-9\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>undefined</code>: 表示缺少值，即此处应该有值，但没有定义。</p>\n<ul>\n<li>声明一个变量,这个变量的值就自动被赋予了<code>undefined</code>;</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>调用函数时，应该被提供的参数没有提供，该参数等于<code>undefined</code>;</p>\n</li>\n<li><p>对象没有赋值的属性，该属性为<code>undefined</code>;</p>\n</li>\n<li><p>函数没有返回值，默认返回<code>undefined</code>;</p>\n</li>\n</ul>\n<p><code>null</code>：表示没有对象，即此处不应该有值。</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象;</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n<p>其他方面的区别：<br>（1）数据类型的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这是 JS 设计的一个失误</strong></p>\n<p>（2）转为数值的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">5</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">5</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>（3)<code>null !== undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"11-原型和原型链\"><a href=\"#11-原型和原型链\" class=\"headerlink\" title=\"11.原型和原型链\"></a>11.原型和原型链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-10\"><a href=\"#答案-10\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md\">原型和原型链</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"12-var，let-和-const-有什么区别\"><a href=\"#12-var，let-和-const-有什么区别\" class=\"headerlink\" title=\"12.var，let 和 const 有什么区别\"></a>12.var，let 和 const 有什么区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-11\"><a href=\"#答案-11\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：<br><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</li>\n</ul>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"13-call-、apply-、bind-的区别和作用\"><a href=\"#13-call-、apply-、bind-的区别和作用\" class=\"headerlink\" title=\"13.call()、apply()、bind()的区别和作用\"></a>13.<code>call()</code>、<code>apply()</code>、<code>bind()</code>的区别和作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-12\"><a href=\"#答案-12\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。</p>\n</blockquote>\n<p>区别：（接受参数的方式不同、改变 this 指向后的处理不同）<br><code>call()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n<p><code>apply()</code>的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">apply</span>(obj, [varl, var2， var3])</span><br></pre></td></tr></table></figure>\n\n<p><code>bind()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"14-cookie、localStorage、sessionStorage的异同点\"><a href=\"#14-cookie、localStorage、sessionStorage的异同点\" class=\"headerlink\" title=\"14.cookie、localStorage、sessionStorage的异同点\"></a>14.<code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>的异同点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-13\"><a href=\"#答案-13\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"center\">生命周期</th>\n<th align=\"center\">存储容量</th>\n<th align=\"center\">储存位置</th>\n<th align=\"center\">应用场景</th>\n<th align=\"center\">浏览器兼容性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cookie</td>\n<td align=\"center\">默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效)</td>\n<td align=\"center\">4kb</td>\n<td align=\"center\">保存在客户端每次请求都会带上</td>\n<td align=\"center\">用户的部分不重要信息或者登录信息</td>\n<td align=\"center\">兼容性完全没问题</td>\n</tr>\n<tr>\n<td align=\"center\">localStorage</td>\n<td align=\"center\">理论上永久有效,除非主动清除</td>\n<td align=\"center\">4.98M(不同浏览器情况不同，safari2.49M)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合持久化缓存数据，比如页面的偏好配置等</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n<tr>\n<td align=\"center\">sessionStorage</td>\n<td align=\"center\">仅在当前网页会话下有效，关闭页面或浏览器后会被清除</td>\n<td align=\"center\">4.98M(部分浏览器没有限制)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合一次性临时数据缓存</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><code>localStorage</code>写入的时候如果超出容量会报错，但之前保存的数据不会丢失。</li>\n<li><code>localStorage</code>存储量快要满的时候，<code>getItem</code>的性能会急剧下降。</li>\n<li><code>webStorage(localStorage、sessionStorage)</code>在保存复杂数据类型时，较为依赖<code>JSON.stringify()</code>在移动端性能问题比较明显。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"15-HTTP、HTTPS-有什么联系，端口号是多少？\"><a href=\"#15-HTTP、HTTPS-有什么联系，端口号是多少？\" class=\"headerlink\" title=\"15.HTTP、HTTPS 有什么联系，端口号是多少？\"></a>15.HTTP、HTTPS 有什么联系，端口号是多少？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-14\"><a href=\"#答案-14\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\"><a href=\"#16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\" class=\"headerlink\" title=\"16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\"></a>16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-15\"><a href=\"#答案-15\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。<br>在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL&#x2F;TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"17-HTTP-2\"><a href=\"#17-HTTP-2\" class=\"headerlink\" title=\"17.HTTP&#x2F;2\"></a>17.HTTP&#x2F;2</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-16\"><a href=\"#答案-16\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。<br>提供更多的加密支持。<br>使用多路线路，允许多个消息在一个连接上同时交差。<br>增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n<h3 id=\"18-HTTP-常见状态码\"><a href=\"#18-HTTP-常见状态码\" class=\"headerlink\" title=\"18.HTTP 常见状态码\"></a>18.HTTP 常见状态码</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-17\"><a href=\"#答案-17\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。</li>\n<li>200 OK 表示正常返回信息。</li>\n<li>201 Created 表示请求成功并且服务器创建了新资源。</li>\n<li>202 Accepted 表示服务器已接受请求，但尚未处理。</li>\n<li>301 Moved Permanently 表示请求的网页已永久移动到新位置。</li>\n<li>302 Found 表示临时重定向。</li>\n<li>303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 表示自从上次请求后，请求网页未修改。</li>\n<li>400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 表示请求未授权。</li>\n<li>403 Forbidden 表示禁止访问。</li>\n<li>404 Not Found 表示找不到如何与 URI 匹配的资源。</li>\n<li>500 Internet Server error 表示最常见的服务端的错误。</li>\n<li>503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"19-无状态协议？如何克服无状态协议缺陷？\"><a href=\"#19-无状态协议？如何克服无状态协议缺陷？\" class=\"headerlink\" title=\"19.无状态协议？如何克服无状态协议缺陷？\"></a>19.无状态协议？如何克服无状态协议缺陷？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-18\"><a href=\"#答案-18\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。<br>克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"20-HTTP-请求报文和响应报文包括哪些部分？\"><a href=\"#20-HTTP-请求报文和响应报文包括哪些部分？\" class=\"headerlink\" title=\"20.HTTP 请求报文和响应报文包括哪些部分？\"></a>20.HTTP 请求报文和响应报文包括哪些部分？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-19\"><a href=\"#答案-19\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>请求报文：</p>\n<ul>\n<li>请求行，包含请求方法、URI、HTTP 版本信息。</li>\n<li>请求首部字段。</li>\n<li>请求内容实体。</li>\n</ul>\n<p>响应报文：</p>\n<ul>\n<li>状态行，包括 HTTP 版本，状态码，状态码的原因短语。</li>\n<li>响应首部字段。</li>\n<li>响应内容实体。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"21-HTTP-请求方式\"><a href=\"#21-HTTP-请求方式\" class=\"headerlink\" title=\"21.HTTP 请求方式\"></a>21.HTTP 请求方式</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-20\"><a href=\"#答案-20\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。</li>\n<li>POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。</li>\n<li>PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。</li>\n<li>HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li>DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。</li>\n<li>OPTIONS:查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-HTTP-首部字段包括哪些类型\"><a href=\"#22-HTTP-首部字段包括哪些类型\" class=\"headerlink\" title=\"22.HTTP 首部字段包括哪些类型\"></a>22.HTTP 首部字段包括哪些类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-21\"><a href=\"#答案-21\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><p>通用首部字段(请求报文和响应报文都会使用的首部字段)。</p>\n<blockquote>\n<p><code>Date</code>:创建报文的时间。<br><code>Connection</code>:连接的管理。<br><code>Cache-Control</code>:缓存机制。<br><code>Transfer-Encoding</code>:报文主体的传输编码方式。</p>\n</blockquote>\n</li>\n<li><p>请求首部字段（请求报文会使用的首部字段）。</p>\n<blockquote>\n<p><code>Host</code>: 请求资源所在的服务器。<br><code>Accept</code>: 可处理的媒体类型。<br><code>Accept-Charset</code>: 可接受的字符集。<br><code>Accept-Encoding</code>: 可接受的内容编码。<br><code>Accept-Language</code>: 可接受的自然语言。</p>\n</blockquote>\n</li>\n<li><p>响应首部字段（响应报文会使用的字段）。</p>\n<blockquote>\n<p><code>Accept-Ranges</code>: 可接受的字节范围。<br><code>Location</code>: 令客户端重新定向到的 URL。</p>\n</blockquote>\n</li>\n<li><p>实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。</p>\n<blockquote>\n<p><code>Allow</code>: 资源可支持的 HTTP 方法。<br><code>Content-Type</code>: 实体主体的类型。<br><code>Content-Encoding</code>: 实体主体使用的编码方式。<br><code>Content-Language</code>: 实体主体的自然语言。<br><code>Content-Length</code>: 实体主体的字节数。<br><code>Content-Range</code>: 实体主体的位置范围，一般用于发出部分请求时使用。</p>\n</blockquote>\n</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-GET和POST的区别\"><a href=\"#22-GET和POST的区别\" class=\"headerlink\" title=\"22.GET和POST的区别\"></a>22.<code>GET</code>和<code>POST</code>的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-22\"><a href=\"#答案-22\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>GET</code>一般用于获取&#x2F;查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而<code>POST</code>一般用于更新资源信息，会修改服务器上的资源信息。</li>\n<li><code>GET</code>请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；<code>POST</code>把提交的数据放在 HTTP 的 requset body 中。</li>\n<li><code>GET</code>方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲<code>POST</code>是没有大小限制的。</li>\n<li>在 ASP 中，服务端获取<code>GET</code>请求参数用 Requset.QueryString;获取<code>POST</code>的请求参数用 Requset.Form。</li>\n<li><code>POST</code>比<code>GET</code>安全性更高：<code>GET</code>提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"23-网站性能优化\"><a href=\"#23-网站性能优化\" class=\"headerlink\" title=\"23.网站性能优化\"></a>23.网站性能优化</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-23\"><a href=\"#答案-23\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://juejin.cn/post/6844903613790175240\">网站性能优化实战</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://imweb.io/topic/5b4d417eee0c3b0779df96d9\">网站性能优化实战(二)</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://segmentfault.com/a/1190000021098540\">网站性能优化实战篇</a></li>\n</ul>\n<p>基本优化：</p>\n<ul>\n<li>图片压缩合并；</li>\n<li>代码精简、混淆；</li>\n<li>减少<code>iframe</code>使用；</li>\n<li>避免图片<code>src</code>为空；</li>\n<li>减少<code>HTTP</code>请求数；</li>\n<li>避免重定向；</li>\n<li>样式表放页头、脚本放底部；</li>\n</ul>\n<p>网站性能优化总结：<br>(一)网络传输性能优化————重定向——&gt;拉取缓存——&gt;DNS 查询——&gt;建立 TCP 链接——&gt;发起请求——&gt;处理 HTML 元素——&gt;元素加载完成</p>\n<ul>\n<li>浏览器缓存。</li>\n<li>资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！</li>\n<li>图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;</li>\n<li>网络传输性能检查工具————Page Speed。</li>\n<li>使用 CDN。</li>\n</ul>\n<p>(二)页面性能优化————处理 HTML 标记并构建 DOM 树——&gt;处理 CSS 标记并构建 CSSOM 树——&gt;将 DOM 和 CSSOM 合并成一个 render 渲染树——&gt;根据渲染树来布局，以计算每个节点的几何信息——&gt;将每个节点绘制在屏幕上</p>\n<ul>\n<li>DOM 渲染层与 GPU 硬件加速。</li>\n<li>降低重绘和重排的频率和成本。</li>\n</ul>\n<p>总结：</p>\n<blockquote>\n<p>CSS 读写分离：不用 js 操作元素样式。<br>通过切换 class 或使用 style.csstext 属性批量操作元素样式。<br>DOM 元素离线更新。<br>将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。<br>压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。<br>图片在渲染前指定大小。<br>降低重绘和重排的频率和成本。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllehfpr90001xw2v4qnt6hyh","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprm0012xw2v6g0iaxvb"},{"post_id":"cllehfpr90001xw2v4qnt6hyh","category_id":"cllehfprk000pxw2v99yn8few","_id":"cllehfprn0015xw2vd5un2rht"},{"post_id":"cllehfprj000nxw2v70lvbsfk","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprr001uxw2v6ajbcyzb"},{"post_id":"cllehfprj000nxw2v70lvbsfk","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprr001yxw2v2fzn67ii"},{"post_id":"cllehfprj000nxw2v70lvbsfk","category_id":"cllehfprq001oxw2va3msfmx8","_id":"cllehfprr0020xw2vb00xe7da"},{"post_id":"cllehfprf0009xw2v6p1pcdwp","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprr0024xw2v0v3e7j23"},{"post_id":"cllehfprf0009xw2v6p1pcdwp","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprr0026xw2v1xhjanms"},{"post_id":"cllehfprf0009xw2v6p1pcdwp","category_id":"cllehfprq001sxw2v76uw16p9","_id":"cllehfprs002axw2v3cdk4m21"},{"post_id":"cllehfprf000axw2vf9at684u","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprt002nxw2vecqefziv"},{"post_id":"cllehfprf000axw2vf9at684u","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprt002oxw2vczpc3y8w"},{"post_id":"cllehfprf000axw2vf9at684u","category_id":"cllehfprs002gxw2v0n0q2kze","_id":"cllehfpru002qxw2vd6qaemah"},{"post_id":"cllehfprn0014xw2v0n8919to","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfpru002vxw2vhg38fuf7"},{"post_id":"cllehfprn0014xw2v0n8919to","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfpru002yxw2ve0pd31dw"},{"post_id":"cllehfprn0014xw2v0n8919to","category_id":"cllehfprt002mxw2vdx9fdfvi","_id":"cllehfpru002zxw2va162870s"},{"post_id":"cllehfprh000dxw2v3jeq7jsu","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprv0032xw2v4eua9td2"},{"post_id":"cllehfprh000dxw2v3jeq7jsu","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprv0033xw2vgicld999"},{"post_id":"cllehfprh000dxw2v3jeq7jsu","category_id":"cllehfpru002rxw2v00fs8j80","_id":"cllehfprv0035xw2v3gq550a1"},{"post_id":"cllehfprc0003xw2v0ycjcph6","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprv0036xw2v0a46c3m4"},{"post_id":"cllehfprc0003xw2v0ycjcph6","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprv0038xw2vg0no831b"},{"post_id":"cllehfprc0003xw2v0ycjcph6","category_id":"cllehfpru002wxw2vdkx7gsrv","_id":"cllehfprw0039xw2vf1y346q6"},{"post_id":"cllehfprh000exw2vgnbw675l","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprw003axw2v67jnfizo"},{"post_id":"cllehfprh000exw2vgnbw675l","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprw003cxw2v94848uge"},{"post_id":"cllehfprh000exw2vgnbw675l","category_id":"cllehfpru0031xw2v27gqb7kz","_id":"cllehfprw003dxw2vemeagei9"},{"post_id":"cllehfpri000hxw2vdhcy7wfq","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprw003fxw2v2gpi1hl6"},{"post_id":"cllehfpri000hxw2vdhcy7wfq","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprw003gxw2v4vzrfa1g"},{"post_id":"cllehfpri000hxw2vdhcy7wfq","category_id":"cllehfprv0034xw2v36h1hhot","_id":"cllehfprx003ixw2vdc89g20x"},{"post_id":"cllehfpre0007xw2v0k253d9f","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprx003jxw2v761gdwli"},{"post_id":"cllehfpre0007xw2v0k253d9f","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprx003lxw2v1um1bk5q"},{"post_id":"cllehfpre0007xw2v0k253d9f","category_id":"cllehfprv0037xw2veudu0ll3","_id":"cllehfprx003mxw2vg1jp9mm1"},{"post_id":"cllehfpri000jxw2v1ai66ccn","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprx003oxw2vekka87wj"},{"post_id":"cllehfpri000jxw2v1ai66ccn","category_id":"cllehfprj000kxw2v5zcsdck5","_id":"cllehfprx003pxw2v8zal61vj"},{"post_id":"cllehfpri000jxw2v1ai66ccn","category_id":"cllehfprw003bxw2v0tnv3jce","_id":"cllehfprx003qxw2v55mb12wx"},{"post_id":"cllehfprk000oxw2v7tnkbcwz","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfpry003sxw2v7htd3oz9"},{"post_id":"cllehfprk000oxw2v7tnkbcwz","category_id":"cllehfprr001wxw2vgv8hdysl","_id":"cllehfpry003txw2vapsrb8u3"},{"post_id":"cllehfprk000oxw2v7tnkbcwz","category_id":"cllehfprw003exw2v2i9mg6yn","_id":"cllehfpry003vxw2vf0yd2o69"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprz003xxw2v6w5h5y1y"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfprz003zxw2vaxv89cw1"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","category_id":"cllehfprx003hxw2vcfoogh4b","_id":"cllehfprz0040xw2v5cny2da8"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","category_id":"cllehfpry003uxw2v294y459z","_id":"cllehfprz0042xw2vc71ma2kv"},{"post_id":"cllehfprl000uxw2v2d53ep91","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprz0043xw2vf0csb505"},{"post_id":"cllehfprl000uxw2v2d53ep91","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfprz0044xw2vfprpb1xs"},{"post_id":"cllehfprl000uxw2v2d53ep91","category_id":"cllehfprx003hxw2vcfoogh4b","_id":"cllehfprz0045xw2v4ml6ceja"},{"post_id":"cllehfprl000uxw2v2d53ep91","category_id":"cllehfpry003wxw2v64ok6jie","_id":"cllehfprz0046xw2vbmyt9svs"},{"post_id":"cllehfprl000yxw2vhqoue0s8","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfprz0047xw2v2qydb3u2"},{"post_id":"cllehfprl000yxw2vhqoue0s8","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfprz0048xw2v1jqmc1ro"},{"post_id":"cllehfprl000yxw2vhqoue0s8","category_id":"cllehfprx003nxw2verx34uho","_id":"cllehfps00049xw2v6rnk882u"},{"post_id":"cllehfprl000yxw2vhqoue0s8","category_id":"cllehfprz003yxw2vaknt2uy1","_id":"cllehfps0004axw2v7z2042xd"},{"post_id":"cllehfprm0010xw2v71lw0e3h","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfps0004bxw2vbjlk26j8"},{"post_id":"cllehfprm0010xw2v71lw0e3h","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfps0004cxw2v8six4e36"},{"post_id":"cllehfprm0010xw2v71lw0e3h","category_id":"cllehfprx003nxw2verx34uho","_id":"cllehfps0004dxw2v77yociqg"},{"post_id":"cllehfprm0010xw2v71lw0e3h","category_id":"cllehfprz0041xw2veqso7shf","_id":"cllehfps0004exw2v32qagvsl"},{"post_id":"cllehfps4004fxw2veunn6k5k","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfps7004nxw2vddp30prn"},{"post_id":"cllehfps4004fxw2veunn6k5k","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfps7004oxw2v0oo83vbq"},{"post_id":"cllehfps4004fxw2veunn6k5k","category_id":"cllehfprx003nxw2verx34uho","_id":"cllehfps7004qxw2vcasodjbn"},{"post_id":"cllehfps4004fxw2veunn6k5k","category_id":"cllehfps6004ixw2v6wz10be4","_id":"cllehfps7004rxw2vgc7d88ye"},{"post_id":"cllehfps6004gxw2v9o71eusi","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfps7004sxw2vchxoeqbt"},{"post_id":"cllehfps6004gxw2v9o71eusi","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfps7004txw2v6ly74lik"},{"post_id":"cllehfps6004gxw2v9o71eusi","category_id":"cllehfps6004kxw2v3h8dbkfz","_id":"cllehfps7004uxw2v8ejt8kfh"},{"post_id":"cllehfps6004gxw2v9o71eusi","category_id":"cllehfps7004pxw2v8dmc8fq7","_id":"cllehfps7004vxw2v3xp2hgzz"},{"post_id":"cllehfpsc004wxw2vhdlcbqut","category_id":"cllehfprd0004xw2vfjdvbhw5","_id":"cllehfpsd0051xw2v17tu282m"},{"post_id":"cllehfpsc004wxw2vhdlcbqut","category_id":"cllehfprr0022xw2v1m0w37b5","_id":"cllehfpsd0052xw2v25y3clug"},{"post_id":"cllehfpsc004wxw2vhdlcbqut","category_id":"cllehfpsd004yxw2v8i30hsbc","_id":"cllehfpsd0053xw2vaw1i9cv5"}],"PostTag":[{"post_id":"cllehfpr90001xw2v4qnt6hyh","tag_id":"cllehfpre0005xw2v1uy9887f","_id":"cllehfpri000ixw2vc4yfcrrb"},{"post_id":"cllehfpr90001xw2v4qnt6hyh","tag_id":"cllehfprg000cxw2v4jiyf1cf","_id":"cllehfprj000lxw2v07j54hrj"},{"post_id":"cllehfprj000nxw2v70lvbsfk","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprk000qxw2v99jd0cz3"},{"post_id":"cllehfprj000nxw2v70lvbsfk","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprl000txw2vfsyt2o8g"},{"post_id":"cllehfprc0003xw2v0ycjcph6","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprl000wxw2ve6ffcm7v"},{"post_id":"cllehfprc0003xw2v0ycjcph6","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprm000zxw2v6ycchudo"},{"post_id":"cllehfpre0007xw2v0k253d9f","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprn0016xw2vherwht3y"},{"post_id":"cllehfpre0007xw2v0k253d9f","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprn0018xw2vb9sfctj4"},{"post_id":"cllehfprn0014xw2v0n8919to","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfpro001axw2v24e3gtie"},{"post_id":"cllehfprn0014xw2v0n8919to","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfpro001cxw2vhhqz4hpe"},{"post_id":"cllehfprf0009xw2v6p1pcdwp","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfpro001exw2v8khb8ekf"},{"post_id":"cllehfprf0009xw2v6p1pcdwp","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprp001gxw2v15qm0kfv"},{"post_id":"cllehfprf000axw2vf9at684u","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprp001kxw2vckzd7o2r"},{"post_id":"cllehfprf000axw2vf9at684u","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprp001mxw2vd3eie4io"},{"post_id":"cllehfprh000dxw2v3jeq7jsu","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprq001qxw2vgi832v3d"},{"post_id":"cllehfprh000dxw2v3jeq7jsu","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprq001rxw2vea2sgrtz"},{"post_id":"cllehfprh000exw2vgnbw675l","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprr001xxw2vage5g8ui"},{"post_id":"cllehfprh000exw2vgnbw675l","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprr001zxw2vct6xecfi"},{"post_id":"cllehfpri000hxw2vdhcy7wfq","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprr0023xw2v8nebarht"},{"post_id":"cllehfpri000hxw2vdhcy7wfq","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprr0025xw2v4062hix5"},{"post_id":"cllehfpri000jxw2v1ai66ccn","tag_id":"cllehfprh000gxw2vejzmhyzb","_id":"cllehfprs0029xw2veigk0379"},{"post_id":"cllehfpri000jxw2v1ai66ccn","tag_id":"cllehfprj000mxw2v6llxhkwe","_id":"cllehfprs002bxw2v02owhha0"},{"post_id":"cllehfprk000oxw2v7tnkbcwz","tag_id":"cllehfprr0027xw2v1j2zbzs5","_id":"cllehfprs002exw2v2tgh1wsj"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfprt002jxw2vc26senr9"},{"post_id":"cllehfprk000sxw2v2w4k3h8u","tag_id":"cllehfprs002fxw2vfwoyborf","_id":"cllehfprt002kxw2vg5qqe4ey"},{"post_id":"cllehfprl000uxw2v2d53ep91","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfpru002sxw2v88r86ags"},{"post_id":"cllehfprl000uxw2v2d53ep91","tag_id":"cllehfprs002fxw2vfwoyborf","_id":"cllehfpru002txw2v21zkf2zp"},{"post_id":"cllehfprl000yxw2vhqoue0s8","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfpru002xxw2vae04bxf0"},{"post_id":"cllehfprm0010xw2v71lw0e3h","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfpru0030xw2vh9crb2ql"},{"post_id":"cllehfps4004fxw2veunn6k5k","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfps6004hxw2vc77vh51n"},{"post_id":"cllehfps6004gxw2v9o71eusi","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfps7004lxw2v7lwn0gmq"},{"post_id":"cllehfps6004gxw2v9o71eusi","tag_id":"cllehfps6004jxw2v8kd93id3","_id":"cllehfps7004mxw2v86jn8qa5"},{"post_id":"cllehfpsc004wxw2vhdlcbqut","tag_id":"cllehfprs002cxw2vao8te4cf","_id":"cllehfpsd004zxw2vb7ywg83p"},{"post_id":"cllehfpsc004wxw2vhdlcbqut","tag_id":"cllehfpsd004xxw2vf94xbxr7","_id":"cllehfpsd0050xw2v51vq9e7l"}],"Tag":[{"name":"js","_id":"cllehfpre0005xw2v1uy9887f"},{"name":"正则","_id":"cllehfprg000cxw2v4jiyf1cf"},{"name":"前端","_id":"cllehfprh000gxw2vejzmhyzb"},{"name":"Echarts","_id":"cllehfprj000mxw2v6llxhkwe"},{"name":"浏览器","_id":"cllehfprr0027xw2v1j2zbzs5"},{"name":"JavaScript","_id":"cllehfprs002cxw2vao8te4cf"},{"name":"ES6","_id":"cllehfprs002fxw2vfwoyborf"},{"name":"lodash","_id":"cllehfps6004jxw2v8kd93id3"},{"name":"JavaScript面试","_id":"cllehfpsd004xxw2vf94xbxr7"}]}}