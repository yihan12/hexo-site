{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","path":"images/avatar1.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","path":"images/bg.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","path":"images/favicon.jpeg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","path":"images/favicon1.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"6d25a1f5a28c87fc6a071e5e24a8789bc1fdec9e","modified":1691912831319},{"_id":"source/categories/index.md","hash":"604a635fd603df744a2adcfc7253e2876bab4727","modified":1691893909242},{"_id":"source/_posts/js去除中括号.md","hash":"0affbf8474f798d07c216bcdac928627abe12470","modified":1691908985380},{"_id":"source/_posts/.DS_Store","hash":"eec8b21ad60e658dddfca710726ea58e8bad61eb","modified":1691985967986},{"_id":"source/friends/index.md","hash":"b48eb357e54258e2cc4bd7d2eaac6462de1c8bdc","modified":1691895646518},{"_id":"source/tags/index.md","hash":"e5efda02833ca720ce647161b6edb9326b8e8035","modified":1691891512600},{"_id":"source/_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","hash":"d662514623227a14cb5e79500c3228626f81569c","modified":1691928034710},{"_id":"source/_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","hash":"ca943c8e0072921ed155c2c9253f2961712deb7f","modified":1691928118162},{"_id":"source/_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","hash":"da8d10ece90a0b5c19d8d5362610c545d09d7aea","modified":1691928168399},{"_id":"source/_posts/Echarts/echarts--上下左右的距离（grid）.md","hash":"94fafa749fd44c42abd87614466bb0a747aeda57","modified":1691927977355},{"_id":"source/_posts/Echarts/echarts--基准线markLine.md","hash":"0c66482d620e34e7978e7a59911c3ace29ea24f4","modified":1691927943620},{"_id":"source/_posts/Echarts/echarts折线--无数据时连线与否.md","hash":"7a5c97668fe2191c31b333499930611de715b1d1","modified":1691928199214},{"_id":"source/_posts/Echarts/echarts设置从原点开始.md","hash":"626ac6aaace9b50e1aa65895e670e871362d110e","modified":1691928074812},{"_id":"source/_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","hash":"5d70fcdbc36350ce13dbed80e0fb0704c4bafdd5","modified":1691928301261},{"_id":"source/_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","hash":"5902d94421783149ab8eddb8a495023fe48f8591","modified":1691928251419},{"_id":"source/_posts/Echarts/echarts折线图--无拐点，折线样式.md","hash":"120a52bb22b03d6daa4e7c124c3b432da8269074","modified":1691928219460},{"_id":"source/_posts/JavaScript/.DS_Store","hash":"6f0fa3152b188737d45f0ec14d5730366a91d58d","modified":1691985967982},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","hash":"9563b61ced6112b269912b5e94091771f5efd564","modified":1691986086280},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","hash":"f91b838a858d162dc86cfdee1dbf20a94251a855","modified":1691986023400},{"_id":"source/_posts/浏览器/ 【浏览器】之同源策略.md","hash":"fe4b9908989392d203d25a62970097f2849efbf9","modified":1691911038346},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","hash":"233b3d8ef60c9c28b8a175491bd923b60ebb3c61","modified":1691986232378},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/.DS_Store","hash":"f10cf3669afa41a916e983c7530e3c246ec258d6","modified":1691985992833},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","hash":"705dcb021d443419cce284eecaa27b6a2c98f8a7","modified":1691986270682},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","hash":"f11edbbcbcfeead0100562f7c397da44201fb102","modified":1691986318700},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","hash":"e820078e0404049683810c54fe864dce87c8d2db","modified":1691986351242},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"efe35e61a73349f027d1f1466d243f6fe36f7abd","modified":1692101130121},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1692158420545},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420544},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","hash":"243059830aa31c3d85b5a1241f097ec6fca1c0d5","modified":1692158420546},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":499162500000},{"_id":"public/atom.xml","hash":"69d164048b65dbbabb14fee23bd348ee769852df","modified":1692234080819},{"_id":"public/categories/index.html","hash":"8e0483286024c8b2e37a9aeee081be2da040b6be","modified":1692234080819},{"_id":"public/about/index.html","hash":"b45321684ca8b4111632ca80e9f4d292684ef5cd","modified":1692234080819},{"_id":"public/tags/index.html","hash":"cc1244d1fd9fb5a685c09c4b4fd3f11a9ec9ce72","modified":1692234080819},{"_id":"public/2023/08/13/浏览器/ 【浏览器】之同源策略/index.html","hash":"4a0a56ab724198f2130c7f76df2a6085b5db993b","modified":1692234080819},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值/index.html","hash":"6c6d069093ab1c7d59227f240ec6cca6c0d0bb57","modified":1692234080819},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量/index.html","hash":"9a03ed6cfb667acd8706bb436d532a0e453d471d","modified":1692234080819},{"_id":"public/2023/08/13/js去除中括号/index.html","hash":"cb7d18bfdf2ad1ef04059017ed0951376f0d545f","modified":1692234080819},{"_id":"public/2022/07/20/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）/index.html","hash":"9b2e31bddcb8c4e668db899886b0ce4762472479","modified":1692234080819},{"_id":"public/friends/index.html","hash":"ab0706fcd1ee0c9fdffa572792c03d5cd6f3d076","modified":1692234080819},{"_id":"public/2022/07/10/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并/index.html","hash":"adea66ddba6d9c4998cf92ea0278febb7ca51afb","modified":1692234080819},{"_id":"public/2022/07/09/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流/index.html","hash":"6076e32b34f38da4248dc410c113e5f33ae45c94","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echats折线--拐点圆的样式（内圆外圆）/index.html","hash":"59779b82ddf107f800600ee601b0a0f4750633f1","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts折线图--无拐点，折线样式/index.html","hash":"4ef0da1ee173b4e8a84724f164831d15381ebd08","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts折线--无数据时连线与否/index.html","hash":"e39e3bda9c0a6c05f8627671e914970bfc7481a9","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts圆柱--设置柱子的borderRadius/index.html","hash":"163c5e1160bb5b4dc9a34056bcfb6f80a6689c69","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts图例--选中状态（默认不显示置灰）/index.html","hash":"5a55061e1ab84cb6f509f9f9f18e1743301bc6fa","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts设置从原点开始/index.html","hash":"562b9515719d81a905691a43ad3e206e2ee1c27f","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts--上下左右的距离（grid）/index.html","hash":"79355dc45f1b1ba550a8c2cef9020940ff7511f9","modified":1692234080819},{"_id":"public/2022/07/08/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖/index.html","hash":"bcb612320ffd28dbe157d962b511d4e9b17ac436","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts柱形--设置柱子多个颜色（渐进色）/index.html","hash":"f99be8734fffb4f2d9e3cebd858912b9b65114ac","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线/index.html","hash":"6992619be13bbc80785e004d16de834f7c3c2d33","modified":1692234080819},{"_id":"public/archives/index.html","hash":"e2d5ea5cf8a12c164d7ca43e84327c6ce728e395","modified":1692234080819},{"_id":"public/archives/page/2/index.html","hash":"6dfffe25628c3bd786a0cabf6c5a4ff962538ef9","modified":1692234080819},{"_id":"public/2022/03/10/Echarts/echarts--基准线markLine/index.html","hash":"82a6f1c24fee9603cac391abdd688963b53288ea","modified":1692234080819},{"_id":"public/archives/2022/index.html","hash":"508114248095ebeeab5bc2865b3de6b4ef0c8556","modified":1692234080819},{"_id":"public/archives/2022/page/2/index.html","hash":"077ec1bb6a24a6e5849adf6114aa0216c38b258a","modified":1692234080819},{"_id":"public/archives/2022/03/index.html","hash":"9198af6965d75d479b5a3ab1b086922d9ea634e5","modified":1692234080819},{"_id":"public/archives/2023/08/index.html","hash":"fb7cdf88176a98a6c78fbeab3c9104058c7b4ea2","modified":1692234080819},{"_id":"public/categories/前端/index.html","hash":"0f23cf0bc4fa962633821136ff7dea99f6c870aa","modified":1692234080819},{"_id":"public/archives/2023/index.html","hash":"62cdd0b628b10e3f16e91d3289bc92d78730e61e","modified":1692234080819},{"_id":"public/archives/2022/07/index.html","hash":"d755c312dc1967d1056993e87c56258b1e160d32","modified":1692234080819},{"_id":"public/categories/前端/page/2/index.html","hash":"93370eb7ae26542076680eec9e79ff4c58a9a984","modified":1692234080819},{"_id":"public/categories/前端/Echarts/index.html","hash":"dd742ee19bce85c4e58bead77b09938cee52cc82","modified":1692234080819},{"_id":"public/categories/前端/正则/index.html","hash":"ccbe11c2dd0286dd4ef0cfa9aae8353cb6c35c6b","modified":1692234080819},{"_id":"public/categories/前端/Echarts/markLine/index.html","hash":"16a4aef6b28925f348827db57e23e543c1acb6e6","modified":1692234080819},{"_id":"public/categories/前端/Echarts/symbol/index.html","hash":"bfead54fe9c87bdbb39e42154eec8ba83bcf21d3","modified":1692234080819},{"_id":"public/categories/前端/浏览器/index.html","hash":"e6655fa519610ec5aa5648684a6b0d00818f58cf","modified":1692234080819},{"_id":"public/categories/前端/Echarts/boundaryGap/index.html","hash":"73d8e8fa64a0e9787eb51ab1d180a6ef563a72c6","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/index.html","hash":"0e8dccc79eefc48880fe43065f54f8aa25d5d4cd","modified":1692234080819},{"_id":"public/categories/前端/Echarts/legend/index.html","hash":"c6ea49d69a92170c964e9ffdd9dcf9ce2cef6e88","modified":1692234080819},{"_id":"public/categories/前端/Echarts/borderRadius/index.html","hash":"2f59719a98070527b7b5a78d8f48c262b3266e7c","modified":1692234080819},{"_id":"public/categories/前端/Echarts/connectNulls/index.html","hash":"470ef87427734511c9ab4caff124dc9da31a1766","modified":1692234080819},{"_id":"public/categories/前端/Echarts/xAxis/index.html","hash":"bf498f2c2d7efb07a7e9a2a7cf075c8b992fa515","modified":1692234080819},{"_id":"public/categories/前端/Echarts/symbolSize/index.html","hash":"ad9e56a6eb3a80408a0cfcab2f0c1fc42f24df99","modified":1692234080819},{"_id":"public/categories/前端/Echarts/grid/index.html","hash":"6b9876fc791cea653614f995d5e04cc059ca4752","modified":1692234080819},{"_id":"public/categories/前端/Echarts/itemStyle/index.html","hash":"878e7bf89e86240a40ebaca86eaed3b446a16b4d","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/ES6/index.html","hash":"4f881e206a445f6f43fa8933372c7cec24732029","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/index.html","hash":"fc98d1de0bf3cd894f60df8f4d2bb8326280163c","modified":1692234080819},{"_id":"public/categories/前端/浏览器/同源策略/index.html","hash":"8c40421328470a8d61b3a582d1be38fa268a978e","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/数组去重/index.html","hash":"0847fd09376d163817d0a4060f88b611820512be","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/ES6/解构/index.html","hash":"bb4a5714b1229bc3a51e7f061abc25cf45ca01cb","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/节流/index.html","hash":"fee414bcc96ae3f1e797b64c26da99d18cabb978","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/ES6/变量/index.html","hash":"c93cfeda5e3605599db8c30b482ffbe9225ed166","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/lodash源码分析/index.html","hash":"7984373c601e66a29334bb2216335db77710778d","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/lodash源码分析/防抖节流/index.html","hash":"840da6025f2fb76647c4ea20e702710858a4fe74","modified":1692234080819},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/防抖/index.html","hash":"cfcb15a183a7c10e2844e77e18b1cc8dcefbee52","modified":1692234080819},{"_id":"public/tags/js/index.html","hash":"8b242c836ca9d91ec991b25cbac2dfdb6e080894","modified":1692234080819},{"_id":"public/tags/正则/index.html","hash":"24ea88cdbbfb024ace06b46b418c0851cdde6e3b","modified":1692234080819},{"_id":"public/tags/前端/index.html","hash":"0543e281a89c63c4f1630fd9c79338a44cd120ef","modified":1692234080819},{"_id":"public/page/2/index.html","hash":"816a4d75afa43117eee87540be40e3128960d5e9","modified":1692234080819},{"_id":"public/tags/Echarts/index.html","hash":"03555c811d3dbe3390c6affa79ba389401d8ae16","modified":1692234080819},{"_id":"public/tags/浏览器/index.html","hash":"faee6772ab4b70edc37337511b7b84c77ccfae57","modified":1692234080819},{"_id":"public/index.html","hash":"bd6bce3387ee0a3aa46e767923182425caa85c64","modified":1692234080819},{"_id":"public/tags/JavaScript/index.html","hash":"a2d4bf0c5ca52c04d86b61367a6f8af26e6d41a6","modified":1692234080819},{"_id":"public/tags/lodash/index.html","hash":"e2900e69bc31c0605ebb2e18a787b25f926b392a","modified":1692234080819},{"_id":"public/tags/ES6/index.html","hash":"b60c3ea89b08abe626a111c7df55009e2d4786ab","modified":1692234080819},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692234080819},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692234080819},{"_id":"public/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692234080819},{"_id":"public/images/bg.jpeg","hash":"243059830aa31c3d85b5a1241f097ec6fca1c0d5","modified":1692234080819},{"_id":"public/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1692234080819},{"_id":"public/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1692234080819},{"_id":"public/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692234080819},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692234080819},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1692234080819},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692234080819},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692234080819},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692234080819},{"_id":"public/css/index.css","hash":"9a4d4bb2cc4ac0510227cd7185e3d619130e073d","modified":1692234080819},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692234080819},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692234080819}],"Category":[{"name":"前端","_id":"cllegh9m90004nx2vb4vj3o7b"},{"name":"Echarts","parent":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mf000knx2v12d7htx6"},{"name":"正则","parent":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mg000pnx2v3263eleu"},{"name":"boundaryGap","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mn001pnx2v30sy0ch9"},{"name":"markLine","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mo001tnx2v8ck75gfg"},{"name":"symbol","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mo001xnx2v0u5c0599"},{"name":"浏览器","parent":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mp0023nx2v7sxehwnu"},{"name":"JavaScript","parent":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mp0029nx2v3ffzg4u5"},{"name":"legend","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mq002knx2v5cjh0wdz"},{"name":"borderRadius","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mr002unx2vajcrhb52"},{"name":"xAxis","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9ms0032nx2vhg942c3k"},{"name":"connectNulls","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9ms0038nx2v2ljoas0w"},{"name":"symbolSize","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9ms003anx2v636h31u2"},{"name":"grid","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mt003dnx2v00ho8u6b"},{"name":"itemStyle","parent":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mt003gnx2vgmpidt61"},{"name":"同源策略","parent":"cllegh9mp0023nx2v7sxehwnu","_id":"cllegh9mt003jnx2v7c983n5q"},{"name":"ES6","parent":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9mu003nnx2vhepk4rx2"},{"name":"JavaScript深入理解","parent":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9mv003tnx2vh886dqql"},{"name":"变量","parent":"cllegh9mu003nnx2vhepk4rx2","_id":"cllegh9mv0040nx2vhel02ym3"},{"name":"解构","parent":"cllegh9mu003nnx2vhepk4rx2","_id":"cllegh9mv0041nx2v1hfmb717"},{"name":"数组去重","parent":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9mw0043nx2vctp325r8"},{"name":"节流","parent":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9mx0046nx2vevs6djjm"},{"name":"防抖","parent":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9mx0049nx2v4zghh4x8"},{"name":"lodash源码分析","parent":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9n0004rnx2vcfzh56qz"},{"name":"防抖节流","parent":"cllegh9n0004rnx2vcfzh56qz","_id":"cllegh9n0004tnx2v3g3k42it"}],"Data":[],"Page":[{"title":"about","date":"2023-08-13T07:47:11.319Z","type":"about","categories":null,"tags":null,"_content":"\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","source":"about/index.md","raw":"---\ntitle: about\ndate:\ntype: 'about'\ncategories:\ntags:\n---\n\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","updated":"2023-08-13T07:47:11.319Z","path":"about/index.html","comments":1,"layout":"page","_id":"cllegh9m40000nx2v2zzpa0ki","content":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#x31;&#x32;&#52;&#x35;&#x35;&#x30;&#x31;&#x38;&#x31;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;\">&#x31;&#x32;&#52;&#x35;&#x35;&#x30;&#x31;&#x38;&#x31;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#x31;&#x32;&#52;&#x35;&#x35;&#x30;&#x31;&#x38;&#x31;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;\">&#x31;&#x32;&#52;&#x35;&#x35;&#x30;&#x31;&#x38;&#x31;&#54;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n"},{"title":"categories","date":"2023-08-13T02:31:49.242Z","type":"categories","categories":null,"tags":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate:\ntype: 'categories'\ncategories:\ntags:\n---\n","updated":"2023-08-13T02:31:49.242Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllegh9m80002nx2v1kdw556u","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"friends","date":"2023-08-13T03:00:46.518Z","type":"friends","categories":null,"tags":null,"_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate:\ntype: 'friends'\ncategories:\ntags:\n---\n","updated":"2023-08-13T03:00:46.518Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cllegh9ma0006nx2v2vftb6oq","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-08-13T01:51:52.600Z","type":"tags","categories":null,"tags":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate:\ntype: 'tags'\ncategories:\ntags:\n---\n","updated":"2023-08-13T01:51:52.600Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cllegh9mb0008nx2vg62zdz9p","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"js去除中括号","date":"2023-08-13T01:44:43.677Z","_content":"\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","source":"_posts/js去除中括号.md","raw":"---\ntitle: js去除中括号\ndate:\ntags: [js, 正则]\ncategories: [前端, 正则]\n---\n\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","slug":"js去除中括号","published":1,"updated":"2023-08-13T06:43:05.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9m60001nx2v913c837r","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>"},{"title":"【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线","date":"2022-03-10T03:38:24.514Z","_content":"\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","source":"_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","raw":"---\ntitle: 【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, xAxis]\n---\n\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","slug":"Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线","published":1,"updated":"2023-08-13T12:00:34.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9m90003nx2v2bubebo0","content":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 grid","date":"2022-03-10T03:38:39.986Z","_content":"\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","source":"_posts/Echarts/echarts--上下左右的距离（grid）.md","raw":"---\ntitle: 【Echarts使用】之 grid\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, grid]\n---\n\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","slug":"Echarts/echarts--上下左右的距离（grid）","published":1,"updated":"2023-08-13T11:59:37.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9ma0007nx2vas0v66ef","content":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n"},{"title":"【Echarts使用】之基准线markLine","date":"2022-03-10T03:38:35.048Z","_content":"\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","source":"_posts/Echarts/echarts--基准线markLine.md","raw":"---\ntitle: 【Echarts使用】之基准线markLine\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, markLine]\n---\n\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","slug":"Echarts/echarts--基准线markLine","published":1,"updated":"2023-08-13T11:59:03.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mb0009nx2v7wkdh5ad","content":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n"},{"title":"【Echarts使用】之 图例选中状态","date":"2022-03-10T03:38:52.203Z","_content":"\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","source":"_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","raw":"---\ntitle: 【Echarts使用】之 图例选中状态\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, legend]\n---\n\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","slug":"Echarts/echarts图例--选中状态（默认不显示置灰）","published":1,"updated":"2023-08-13T12:01:58.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mb000anx2v0v7bch3q","content":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置柱子borderRadius","date":"2022-03-10T03:38:56.351Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","raw":"---\ntitle: 【Echarts使用】之 设置柱子borderRadius\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, borderRadius]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","slug":"Echarts/echarts圆柱--设置柱子的borderRadius","published":1,"updated":"2023-08-13T12:02:48.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9md000dnx2v382l3rhp","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无数据是连线","date":"2022-03-10T03:38:59.886Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts折线--无数据时连线与否.md","raw":"---\ntitle: 【Echarts使用】之 无数据是连线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, connectNulls]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echarts折线--无数据时连线与否","published":1,"updated":"2023-08-13T12:03:19.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9md000enx2v3k6zdq2u","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无拐点","date":"2022-03-10T03:39:04.601Z","_content":"\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","source":"_posts/Echarts/echarts折线图--无拐点，折线样式.md","raw":"---\ntitle: 【Echarts使用】之 无拐点\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbolSize]\n---\n\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","slug":"Echarts/echarts折线图--无拐点，折线样式","published":1,"updated":"2023-08-13T12:03:39.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9me000hnx2veahf7w9o","content":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置柱状图渐进式","date":"2022-03-10T03:39:08.919Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","raw":"---\ntitle: 【Echarts使用】之 设置柱状图渐进式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, itemStyle]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","slug":"Echarts/echarts柱形--设置柱子多个颜色（渐进色）","published":1,"updated":"2023-08-13T12:04:11.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mf000jnx2vcc17gib8","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置从原点开始","date":"2022-03-10T03:38:44.099Z","_content":"\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","source":"_posts/Echarts/echarts设置从原点开始.md","raw":"---\ntitle: 【Echarts使用】之 设置从原点开始\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, boundaryGap]\n---\n\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","slug":"Echarts/echarts设置从原点开始","published":1,"updated":"2023-08-13T12:01:14.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mf000nnx2vg1jp87t5","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 拐点圆样式","date":"2022-03-10T03:39:13.518Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","raw":"---\ntitle: 【Echarts使用】之 拐点圆样式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbol]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echats折线--拐点圆的样式（内圆外圆）","published":1,"updated":"2023-08-13T12:05:01.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mg000onx2v5tar819i","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【浏览器】之同源策略","date":"2023-08-13T06:34:46.171Z","_content":"\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","source":"_posts/浏览器/ 【浏览器】之同源策略.md","raw":"---\ntitle: 【浏览器】之同源策略\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 同源策略]\n---\n\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","slug":"浏览器/ 【浏览器】之同源策略","published":1,"updated":"2023-08-13T07:17:18.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mg000snx2vew656no8","content":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n"},{"title":"【ES6学习笔记】之 变量","date":"2023-08-13T06:16:23.737Z","_content":"\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","raw":"---\ntitle: 【ES6学习笔记】之 变量\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 变量]\n---\n\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之 变量","published":1,"updated":"2023-08-14T04:07:03.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mh000unx2v2ivr4y0u","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n"},{"title":"【ES6学习笔记】之 解构赋值","date":"2023-08-13T06:23:26.686Z","_content":"\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","raw":"---\ntitle: 【ES6学习笔记】之 解构赋值\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 解构]\n---\n\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值","published":1,"updated":"2023-08-14T04:08:06.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mh000ynx2vc08lfihi","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n"},{"title":"【跟着大佬学JavaScript】之数组去重（结果对比）","date":"2022-07-20T15:36:24.591Z","_content":"\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之数组去重（结果对比）\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 数组去重]\n---\n\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）","published":1,"updated":"2023-08-14T04:11:10.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mi0010nx2vet7k5qqj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n"},{"title":"【跟着大佬学JavaScript】之节流","date":"2022-07-08T16:07:09.822Z","_content":"\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之节流\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 节流]\n---\n\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流","published":1,"updated":"2023-08-14T04:11:58.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mk0015nx2v6zuf80bz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n"},{"title":"【跟着大佬学JavaScript】之防抖","date":"2022-07-08T12:04:06.597Z","_content":"\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之防抖\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 防抖]\n---\n\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖","published":1,"updated":"2023-08-14T04:12:31.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9ml0018nx2vcuad7qix","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n"},{"title":"【跟着大佬学JavaScript】之lodash防抖节流合并","date":"2022-07-09T17:12:41.328Z","_content":"\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之lodash防抖节流合并\ndate:\ntags: [JavaScript, lodash]\ncategories: [前端, JavaScript, lodash源码分析, 防抖节流]\n---\n\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并","published":1,"updated":"2023-08-14T04:10:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllegh9mz004pnx2v6eqm08mh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllegh9m60001nx2v913c837r","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mk0012nx2v37ze37rz"},{"post_id":"cllegh9m60001nx2v913c837r","category_id":"cllegh9mg000pnx2v3263eleu","_id":"cllegh9ml0016nx2v8jza6q46"},{"post_id":"cllegh9mf000nnx2vg1jp87t5","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mo001vnx2v5bbobqk2"},{"post_id":"cllegh9mf000nnx2vg1jp87t5","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mo001znx2v5giz2ito"},{"post_id":"cllegh9mf000nnx2vg1jp87t5","category_id":"cllegh9mn001pnx2v30sy0ch9","_id":"cllegh9mo0021nx2veei0hbaq"},{"post_id":"cllegh9mb0009nx2v7wkdh5ad","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mp0025nx2v6qm81a44"},{"post_id":"cllegh9mb0009nx2v7wkdh5ad","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mp0027nx2v5byy4i5m"},{"post_id":"cllegh9mb0009nx2v7wkdh5ad","category_id":"cllegh9mo001tnx2v8ck75gfg","_id":"cllegh9mp002bnx2vgq1yewsl"},{"post_id":"cllegh9mg000onx2v5tar819i","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mp002dnx2vg4uvg20u"},{"post_id":"cllegh9mg000onx2v5tar819i","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mp002gnx2v0pmj3bln"},{"post_id":"cllegh9mg000onx2v5tar819i","category_id":"cllegh9mo001xnx2v0u5c0599","_id":"cllegh9mq002inx2vgtdr8int"},{"post_id":"cllegh9mb000anx2v0v7bch3q","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mr002rnx2vfuech4pd"},{"post_id":"cllegh9mb000anx2v0v7bch3q","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mr002snx2v64fh7mvv"},{"post_id":"cllegh9mb000anx2v0v7bch3q","category_id":"cllegh9mq002knx2v5cjh0wdz","_id":"cllegh9mr002vnx2v1iuf7f6z"},{"post_id":"cllegh9md000dnx2v382l3rhp","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9ms0033nx2vb8vg7f3g"},{"post_id":"cllegh9md000dnx2v382l3rhp","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9ms0035nx2v2n4lbivk"},{"post_id":"cllegh9md000dnx2v382l3rhp","category_id":"cllegh9mr002unx2vajcrhb52","_id":"cllegh9ms0036nx2v8hz0deex"},{"post_id":"cllegh9m90003nx2v2bubebo0","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9ms0039nx2v0wczc0pm"},{"post_id":"cllegh9m90003nx2v2bubebo0","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mt003bnx2v5qm400n4"},{"post_id":"cllegh9m90003nx2v2bubebo0","category_id":"cllegh9ms0032nx2vhg942c3k","_id":"cllegh9mt003cnx2v7p3pfi54"},{"post_id":"cllegh9md000enx2v3k6zdq2u","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mt003enx2v9hkre5u8"},{"post_id":"cllegh9md000enx2v3k6zdq2u","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mt003fnx2v5vmx44yt"},{"post_id":"cllegh9md000enx2v3k6zdq2u","category_id":"cllegh9ms0038nx2v2ljoas0w","_id":"cllegh9mt003hnx2v8yjo06z8"},{"post_id":"cllegh9me000hnx2veahf7w9o","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mt003inx2vhqcya5mt"},{"post_id":"cllegh9me000hnx2veahf7w9o","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mt003knx2va3mi0bpc"},{"post_id":"cllegh9me000hnx2veahf7w9o","category_id":"cllegh9ms003anx2v636h31u2","_id":"cllegh9mt003lnx2v5sztho9z"},{"post_id":"cllegh9ma0007nx2vas0v66ef","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mt003mnx2v0wtu7hfy"},{"post_id":"cllegh9ma0007nx2vas0v66ef","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mu003onx2vbsyl6x74"},{"post_id":"cllegh9ma0007nx2vas0v66ef","category_id":"cllegh9mt003dnx2v00ho8u6b","_id":"cllegh9mu003pnx2v88k002ts"},{"post_id":"cllegh9mf000jnx2vcc17gib8","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mu003rnx2vhhao9ccc"},{"post_id":"cllegh9mf000jnx2vcc17gib8","category_id":"cllegh9mf000knx2v12d7htx6","_id":"cllegh9mv003snx2v7p113b1y"},{"post_id":"cllegh9mf000jnx2vcc17gib8","category_id":"cllegh9mt003gnx2vgmpidt61","_id":"cllegh9mv003unx2vgwmoaxm6"},{"post_id":"cllegh9mg000snx2vew656no8","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mv003vnx2vfwyx5eh6"},{"post_id":"cllegh9mg000snx2vew656no8","category_id":"cllegh9mp0023nx2v7sxehwnu","_id":"cllegh9mv003xnx2v19vp7gw2"},{"post_id":"cllegh9mg000snx2vew656no8","category_id":"cllegh9mt003jnx2v7c983n5q","_id":"cllegh9mv003ynx2vhzi2153v"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mw0042nx2vbmypb2ft"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9mx0044nx2v3ubz7ij1"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","category_id":"cllegh9mu003nnx2vhepk4rx2","_id":"cllegh9mx0045nx2vgtew857p"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","category_id":"cllegh9mv0040nx2vhel02ym3","_id":"cllegh9mx0047nx2v4icl0x8g"},{"post_id":"cllegh9mh000ynx2vc08lfihi","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9mx0048nx2v0fz1ch7g"},{"post_id":"cllegh9mh000ynx2vc08lfihi","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9mx004anx2vcv5o9fwe"},{"post_id":"cllegh9mh000ynx2vc08lfihi","category_id":"cllegh9mu003nnx2vhepk4rx2","_id":"cllegh9mx004bnx2v7vsgchun"},{"post_id":"cllegh9mh000ynx2vc08lfihi","category_id":"cllegh9mv0041nx2v1hfmb717","_id":"cllegh9my004cnx2v5xuu0jqo"},{"post_id":"cllegh9mi0010nx2vet7k5qqj","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9my004dnx2vcyk48bh0"},{"post_id":"cllegh9mi0010nx2vet7k5qqj","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9my004enx2v20gd9t76"},{"post_id":"cllegh9mi0010nx2vet7k5qqj","category_id":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9my004fnx2vd4er8htj"},{"post_id":"cllegh9mi0010nx2vet7k5qqj","category_id":"cllegh9mw0043nx2vctp325r8","_id":"cllegh9my004gnx2v7roudpwb"},{"post_id":"cllegh9mk0015nx2v6zuf80bz","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9my004hnx2vdtocck42"},{"post_id":"cllegh9mk0015nx2v6zuf80bz","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9my004inx2v2s5gd9u1"},{"post_id":"cllegh9mk0015nx2v6zuf80bz","category_id":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9my004jnx2vdoha1e7w"},{"post_id":"cllegh9mk0015nx2v6zuf80bz","category_id":"cllegh9mx0046nx2vevs6djjm","_id":"cllegh9my004knx2v1lh4f6xj"},{"post_id":"cllegh9ml0018nx2vcuad7qix","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9my004lnx2vg3n2993i"},{"post_id":"cllegh9ml0018nx2vcuad7qix","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9my004mnx2v1wdx75kd"},{"post_id":"cllegh9ml0018nx2vcuad7qix","category_id":"cllegh9mv003tnx2vh886dqql","_id":"cllegh9my004nnx2v57y4bdbn"},{"post_id":"cllegh9ml0018nx2vcuad7qix","category_id":"cllegh9mx0049nx2v4zghh4x8","_id":"cllegh9my004onx2v4ybc6p1j"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","category_id":"cllegh9m90004nx2vb4vj3o7b","_id":"cllegh9n0004vnx2v0vpd0lqm"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","category_id":"cllegh9mp0029nx2v3ffzg4u5","_id":"cllegh9n0004wnx2v0poxfh9q"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","category_id":"cllegh9n0004rnx2vcfzh56qz","_id":"cllegh9n0004xnx2vh6zoewh7"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","category_id":"cllegh9n0004tnx2v3g3k42it","_id":"cllegh9n0004ynx2va19t1p7c"}],"PostTag":[{"post_id":"cllegh9m60001nx2v913c837r","tag_id":"cllegh9ma0005nx2veq9i5wbj","_id":"cllegh9me000inx2vg5634zat"},{"post_id":"cllegh9m60001nx2v913c837r","tag_id":"cllegh9mc000cnx2vcn0b3omc","_id":"cllegh9mf000lnx2vb1s1ban2"},{"post_id":"cllegh9mf000nnx2vg1jp87t5","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mg000qnx2v6youfsqn"},{"post_id":"cllegh9mf000nnx2vg1jp87t5","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mh000tnx2vfb0i7dnz"},{"post_id":"cllegh9m90003nx2v2bubebo0","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mh000wnx2v3hui3img"},{"post_id":"cllegh9m90003nx2v2bubebo0","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mi000znx2v3g8tf6h1"},{"post_id":"cllegh9mg000onx2v5tar819i","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mk0013nx2v3rx30jxo"},{"post_id":"cllegh9mg000onx2v5tar819i","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9ml0017nx2vglul3cyk"},{"post_id":"cllegh9ma0007nx2vas0v66ef","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9ml001anx2v6zdsgd40"},{"post_id":"cllegh9ma0007nx2vas0v66ef","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mm001cnx2vaoxfcz7h"},{"post_id":"cllegh9mb0009nx2v7wkdh5ad","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mm001fnx2vfhgzf6tn"},{"post_id":"cllegh9mb0009nx2v7wkdh5ad","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mm001hnx2vdfc33osv"},{"post_id":"cllegh9mb000anx2v0v7bch3q","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mn001lnx2v9lu30qo2"},{"post_id":"cllegh9mb000anx2v0v7bch3q","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mn001nnx2v5pbbdwfs"},{"post_id":"cllegh9md000dnx2v382l3rhp","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mn001rnx2v2zfygu9l"},{"post_id":"cllegh9md000dnx2v382l3rhp","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mo001snx2v2eebfxlc"},{"post_id":"cllegh9md000enx2v3k6zdq2u","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mo001ynx2vfmu33kzt"},{"post_id":"cllegh9md000enx2v3k6zdq2u","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mo0020nx2v942u9e1r"},{"post_id":"cllegh9me000hnx2veahf7w9o","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mp0024nx2ve10v4923"},{"post_id":"cllegh9me000hnx2veahf7w9o","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mp0026nx2v25f6dbc9"},{"post_id":"cllegh9mf000jnx2vcc17gib8","tag_id":"cllegh9me000gnx2v147b3i0u","_id":"cllegh9mp002anx2v7bspchx2"},{"post_id":"cllegh9mf000jnx2vcc17gib8","tag_id":"cllegh9mf000mnx2v3g799v6o","_id":"cllegh9mp002cnx2v6kks8f2k"},{"post_id":"cllegh9mg000snx2vew656no8","tag_id":"cllegh9mp0028nx2vg2tfecc5","_id":"cllegh9mq002hnx2v92x43kki"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9mq002nnx2v63or5d15"},{"post_id":"cllegh9mh000unx2v2ivr4y0u","tag_id":"cllegh9mq002jnx2v8xh9e5bc","_id":"cllegh9mq002onx2vg1l52tqp"},{"post_id":"cllegh9mh000ynx2vc08lfihi","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9mr002wnx2v8pmr0zdt"},{"post_id":"cllegh9mh000ynx2vc08lfihi","tag_id":"cllegh9mq002jnx2v8xh9e5bc","_id":"cllegh9mr002xnx2vgyq7cmnh"},{"post_id":"cllegh9mi0010nx2vet7k5qqj","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9ms0030nx2vgi1oc5kz"},{"post_id":"cllegh9mk0015nx2v6zuf80bz","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9ms0034nx2vdp7ahjuq"},{"post_id":"cllegh9ml0018nx2vcuad7qix","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9ms0037nx2vhkf1ho0y"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","tag_id":"cllegh9mp002enx2v9aathzn7","_id":"cllegh9n0004snx2v70ctan2a"},{"post_id":"cllegh9mz004pnx2v6eqm08mh","tag_id":"cllegh9mz004qnx2vgf0c0in4","_id":"cllegh9n0004unx2vbiy75avi"}],"Tag":[{"name":"js","_id":"cllegh9ma0005nx2veq9i5wbj"},{"name":"正则","_id":"cllegh9mc000cnx2vcn0b3omc"},{"name":"前端","_id":"cllegh9me000gnx2v147b3i0u"},{"name":"Echarts","_id":"cllegh9mf000mnx2v3g799v6o"},{"name":"浏览器","_id":"cllegh9mp0028nx2vg2tfecc5"},{"name":"JavaScript","_id":"cllegh9mp002enx2v9aathzn7"},{"name":"ES6","_id":"cllegh9mq002jnx2v8xh9e5bc"},{"name":"lodash","_id":"cllegh9mz004qnx2vgf0c0in4"}]}}