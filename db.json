{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","path":"images/avatar1.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","path":"images/favicon.jpeg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","path":"images/favicon1.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","path":"images/bg.jpeg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/friends/index.md","hash":"b48eb357e54258e2cc4bd7d2eaac6462de1c8bdc","modified":1691895646518},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1694079215917},{"_id":"source/about/index.md","hash":"6d25a1f5a28c87fc6a071e5e24a8789bc1fdec9e","modified":1691912831319},{"_id":"source/_posts/js去除中括号.md","hash":"0affbf8474f798d07c216bcdac928627abe12470","modified":1691908985380},{"_id":"source/categories/index.md","hash":"604a635fd603df744a2adcfc7253e2876bab4727","modified":1691893909242},{"_id":"source/_posts/.DS_Store","hash":"1bf8cba0331611cac726844386c544a2b6962afc","modified":1694093004294},{"_id":"source/_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","hash":"d662514623227a14cb5e79500c3228626f81569c","modified":1691928034710},{"_id":"source/_posts/Echarts/echarts--上下左右的距离（grid）.md","hash":"94fafa749fd44c42abd87614466bb0a747aeda57","modified":1691927977355},{"_id":"source/_posts/Echarts/echarts--基准线markLine.md","hash":"0c66482d620e34e7978e7a59911c3ace29ea24f4","modified":1691927943620},{"_id":"source/tags/index.md","hash":"e5efda02833ca720ce647161b6edb9326b8e8035","modified":1691891512600},{"_id":"source/_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","hash":"ca943c8e0072921ed155c2c9253f2961712deb7f","modified":1691928118162},{"_id":"source/_posts/Echarts/echarts折线--无数据时连线与否.md","hash":"7a5c97668fe2191c31b333499930611de715b1d1","modified":1691928199214},{"_id":"source/_posts/Echarts/echarts设置从原点开始.md","hash":"626ac6aaace9b50e1aa65895e670e871362d110e","modified":1691928074812},{"_id":"source/_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","hash":"da8d10ece90a0b5c19d8d5362610c545d09d7aea","modified":1691928168399},{"_id":"source/_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","hash":"5d70fcdbc36350ce13dbed80e0fb0704c4bafdd5","modified":1691928301261},{"_id":"source/_posts/JavaScript/.DS_Store","hash":"6f0fa3152b188737d45f0ec14d5730366a91d58d","modified":1692235442339},{"_id":"source/_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","hash":"5902d94421783149ab8eddb8a495023fe48f8591","modified":1691928251419},{"_id":"source/_posts/浏览器/ 【浏览器】之同源策略.md","hash":"fe4b9908989392d203d25a62970097f2849efbf9","modified":1691911038346},{"_id":"source/_posts/Bug/兼容性/https的图片在移动端展示问题.md","hash":"1e6be27817d6a26df937bdee723a117389196038","modified":1692322386594},{"_id":"source/_posts/Echarts/echarts折线图--无拐点，折线样式.md","hash":"120a52bb22b03d6daa4e7c124c3b432da8269074","modified":1691928219460},{"_id":"source/_posts/浏览器/【浏览器】之渲染机制.md","hash":"024d1d12d6527e8efd43e823305a2fc4bc7eab72","modified":1694050084122},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","hash":"f91b838a858d162dc86cfdee1dbf20a94251a855","modified":1691986023400},{"_id":"source/_posts/浏览器/【浏览器】之缓存.md","hash":"be7cdcba9916b0c257e893a45631aced01ef4140","modified":1693877348695},{"_id":"source/_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","hash":"9563b61ced6112b269912b5e94091771f5efd564","modified":1691986086280},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","hash":"705dcb021d443419cce284eecaa27b6a2c98f8a7","modified":1691986270682},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","hash":"233b3d8ef60c9c28b8a175491bd923b60ebb3c61","modified":1691986232378},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","hash":"f11edbbcbcfeead0100562f7c397da44201fb102","modified":1691986318700},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","hash":"e820078e0404049683810c54fe864dce87c8d2db","modified":1691986351242},{"_id":"source/_posts/Vue/Vue2源码分析/【源码剖析】new Vue 发生了什么.md","hash":"231025c76d540f11a04d5ccc4d7d4f7018dc0d0b","modified":1694079331204},{"_id":"source/_posts/Vue/Vue2源码分析/【源码剖析】$mount挂载.md","hash":"7a4853589752e88be3f1c75a72ae5ed1931679b4","modified":1694137299319},{"_id":"source/_posts/JavaScript/JavaScript面试/ES6模块和CommonJS的异同.md","hash":"74345be25cb0fb58428c643ef15b16bdb3d591c7","modified":1731118606662},{"_id":"source/_posts/JavaScript/JavaScript面试/如何提取url的参数.md","hash":"ace2e113b0e974ce90ce4dcafccd95e78f4393a9","modified":1731115135385},{"_id":"source/_posts/浏览器/【浏览器】之跨域.md","hash":"d2d49c05c1c265c9bb89765e9937c3b1cdda7bac","modified":1693964998881},{"_id":"source/_posts/JavaScript/JavaScript面试/输入url,到页面展示的过程.md","hash":"ecd7b46b1e22b547ca93b67f782247e861240347","modified":1731119001489},{"_id":"source/_posts/JavaScript/JavaScript学习笔记/.DS_Store","hash":"f10cf3669afa41a916e983c7530e3c246ec258d6","modified":1691985992833},{"_id":"source/_posts/JavaScript/JavaScript面试/白屏时间.md","hash":"c6bd9603666588d1d0a8937c6a084cca9aa87051","modified":1731117021883},{"_id":"source/_posts/JavaScript/JavaScript面试/JavaScript面试.md","hash":"aca098bb501d23bed2190026886b709489a4c6d2","modified":1692235230370},{"_id":"source/_posts/leetcode/Array/LeetCode 011：盛最多水的容器.md","hash":"313ca718d3ba75d8e2748b899ba71fa9b8d34d0e","modified":1702802040373},{"_id":"source/_posts/leetcode/String/LeetCode 003：无重复字符的最长子串.md","hash":"7fe8d1e121dce3fb70c2d48cf5049db05c07b752","modified":1692408262547},{"_id":"source/_posts/leetcode/String/ LeetCode 039：组合总和.md","hash":"1607092a8d2cf7994d5a2bb0bff516258f0e43d5","modified":1692925345511},{"_id":"source/_posts/leetcode/Array/LeetCode 004：寻找两个正序数组的中位数.md","hash":"b60a5ff3c49e867ebe122f5724698c9ed8df4089","modified":1729389768410},{"_id":"source/_posts/leetcode/String/LeetCode 006：N 字形变换.md","hash":"b0afbf9926e4e68b4b4aff6a91bf08d568ca7ea5","modified":1692752368240},{"_id":"source/_posts/leetcode/String/LeetCode 005：最长回文子串.md","hash":"4163f667c9a2fb98bc96e078bd1de47e3700d9d7","modified":1692676420295},{"_id":"source/_posts/leetcode/String/LeetCode 030：串联所有单词的子串.md","hash":"8c906214a69174eb7d65ecc9c7b0c804c6be2816","modified":1692839181668},{"_id":"source/_posts/leetcode/divide-and-conquer/base.md","hash":"36186b81beb9bd7966eaf03d2d2d00a2f3ec3f02","modified":1729405867002},{"_id":"source/_posts/leetcode/String/LeetCode 049：字母异位词分组.md","hash":"dc092b7c7f59c0f7b8afc5ad7482c1ce097f61ad","modified":1693006397529},{"_id":"source/_posts/leetcode/divide-and-conquer/最大子数组问题.md","hash":"5b149e06305823c57db57f8d52ea77b10752c8e6","modified":1729405867001},{"_id":"source/_posts/leetcode/divide-and-conquer/棋盘覆盖问题.md","hash":"a75ba4d0b19f21cace78905b78167aeadddba009","modified":1729423971081},{"_id":"source/_posts/leetcode/divide-and-conquer/寻找第k小元素.md","hash":"ff2f75e5f9e06adf7a167eb8f65aeb295d4f4584","modified":1729415840510},{"_id":"source/_posts/leetcode/divide-and-conquer/最近点对问题.md","hash":"7f699629f7c25f16da22e833515ee4e16e3583b2","modified":1729416082329},{"_id":"source/_posts/leetcode/dynamic-programming/base.md","hash":"9099bac4dc5272e8b7e1e37d6363c89613ed029d","modified":1729428240457},{"_id":"source/_posts/leetcode/dynamic-programming/旅行商问题.md","hash":"88bf1aaa62996fcf12e6c2023aa1545e35347879","modified":1729910685858},{"_id":"source/_posts/leetcode/dynamic-programming/0-1背包问题.md","hash":"002ed1eb97374bb20d1146a7933a66f52ff6d539","modified":1729433720787},{"_id":"source/_posts/leetcode/dynamic-programming/最大子数组问题.md","hash":"50668f857e8ea81afed29c36f4d0df8c3125d047","modified":1729429945811},{"_id":"source/_posts/leetcode/Stack/LeetCode 020：有效的括号.md","hash":"ebcfbd74223fa28fbbbdf8205aac196da5a478d2","modified":1693131003290},{"_id":"source/_posts/leetcode/dynamic-programming/状态压缩动态规划.md","hash":"4c125c25957d73345f1dbac25c4449fb28adca86","modified":1729917528692},{"_id":"source/_posts/tools/tinymce/image.md","hash":"f181e2c15b3507f7b33b2232dc1b9b7b7833968c","modified":1722682251715},{"_id":"source/_posts/leetcode/Sort/bubbleSort/bubbleSort.md","hash":"7ad8c0865976d355a897e1004e9e77dd3bbcf409","modified":1693195420657},{"_id":"source/_posts/leetcode/dynamic-programming/最长公共子序列.md","hash":"6c8e127a37a0c0d0f8e0f690f2bce4c13c44d063","modified":1729916785981},{"_id":"source/_posts/leetcode/Sort/shellSort/shellSort.md","hash":"6e45aa251c143a4b95f74d468ec199283935bfcd","modified":1693380117669},{"_id":"source/_posts/leetcode/Sort/selectionSort/selectionSort.md","hash":"07777df2688f7ac02039e019453e3e66c95492b5","modified":1693467829058},{"_id":"source/_posts/tools/tinymce/tinymce media.md","hash":"003e728d9643d80e2776fd1cb6c70b071e08d94b","modified":1722683487672},{"_id":"source/_posts/leetcode/Sort/insertionSort/insertionSort.md","hash":"c645bfbeb2294043153841072931e15db6321019","modified":1693270877028},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"efe35e61a73349f027d1f1466d243f6fe36f7abd","modified":1692101130121},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"459517785a7161e07c333bfe2900243b6287f905","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1692158420544},{"_id":"node_modules/hexo-theme-butterfly/source/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1692158420545},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1692158420547},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":499162500000},{"_id":"node_modules/hexo-theme-butterfly/source/images/bg.jpeg","hash":"9aa11ebfc2e41ae20b1035539eebe7b3cf8fde37","modified":1692417127567},{"_id":"public/atom.xml","hash":"85f8a01c97d8ae49d9d78734c9ec09ecb579bad3","modified":1731120192124},{"_id":"public/friends/index.html","hash":"76ea0c223ee9a7aef502501be14a196534dce6d2","modified":1731120217038},{"_id":"public/about/index.html","hash":"5d607db93afcea8f1e88d0f94a836a0a2dd5df4a","modified":1731120217038},{"_id":"public/categories/index.html","hash":"f3cf19f60cd093944ccfb686c1c0b9a5d74db306","modified":1731120217038},{"_id":"public/2024/11/09/JavaScript/JavaScript面试/输入url,到页面展示的过程/index.html","hash":"c684d0751c882806f29e30f29387269210ca5aed","modified":1731120192124},{"_id":"public/2024/11/09/JavaScript/JavaScript面试/ES6模块和CommonJS的异同/index.html","hash":"d07e0f7b9bda00a90a8f0c6c23af50000347899a","modified":1731120192124},{"_id":"public/tags/index.html","hash":"5e5a18b82dd4f3a2d59c52d3fcd8eabd06e211ab","modified":1731120217038},{"_id":"public/2024/11/09/JavaScript/JavaScript面试/白屏时间/index.html","hash":"a13db54a50396efc3f55b1e7d3fa34bf8dd1d829","modified":1731120192124},{"_id":"public/2024/10/26/leetcode/dynamic-programming/状态压缩动态规划/index.html","hash":"29dfaae19450befb6b16ce3bf4b1bf7ce9f8e190","modified":1731120192124},{"_id":"public/2024/11/09/JavaScript/JavaScript面试/如何提取url的参数/index.html","hash":"bbd1e8fc14437261afa2241e48cbb0cb41ed9fbc","modified":1731120192124},{"_id":"public/2024/10/26/leetcode/dynamic-programming/最长公共子序列/index.html","hash":"81a6995402b0526c55d4a6ce6cc2570881ae3263","modified":1731120192124},{"_id":"public/2024/10/26/leetcode/dynamic-programming/旅行商问题/index.html","hash":"97691bc27d1a2e5da69e30bc0f6d93abf943623f","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/dynamic-programming/0-1背包问题/index.html","hash":"8c9bc235fbcc3f4cb6871b666e81f1c2d15e13f7","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/dynamic-programming/最大子数组问题/index.html","hash":"fccf5b66016356b50223413e23945f2be1bf95b4","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/dynamic-programming/base/index.html","hash":"537eeb3c8272ff401b4e3bec3b3a86b2600a9c07","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/divide-and-conquer/棋盘覆盖问题/index.html","hash":"a58956e93afe09b23725c54f863399d6df365e2a","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/divide-and-conquer/最近点对问题/index.html","hash":"a09345a0a25db51795c6a4861e58022eb75e8ec2","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/divide-and-conquer/寻找第k小元素/index.html","hash":"63c272c8370f81efcf14c15fee02fa5abfe2db9f","modified":1731120192124},{"_id":"public/2024/08/03/tools/tinymce/tinymce media/index.html","hash":"37bf6c602f7772dc1c740b42fcf084c8e1767e45","modified":1731120192124},{"_id":"public/2024/08/03/tools/tinymce/image/index.html","hash":"c5e616d88b82bf26a1570e0720308e97e2aa371a","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/divide-and-conquer/最大子数组问题/index.html","hash":"f21494c056f2868ff0207f840b61430223e2686c","modified":1731120192124},{"_id":"public/2024/10/20/leetcode/divide-and-conquer/base/index.html","hash":"8ce020892f7d268826ae4e3cf63203df99e55435","modified":1731120192124},{"_id":"public/2023/12/17/leetcode/Array/LeetCode 011：盛最多水的容器/index.html","hash":"4203992e497929af88edcd7f1af4c22b4165884b","modified":1731120192124},{"_id":"public/2023/12/16/leetcode/Array/LeetCode 004：寻找两个正序数组的中位数/index.html","hash":"a6cfd49e1eb24495fab7e98f6929343b71611b1a","modified":1731120192124},{"_id":"public/2023/09/08/Vue/Vue2源码分析/【源码剖析】$mount挂载/index.html","hash":"13f1098d9bf7adf94b35a2bd3637780e47786a9c","modified":1731120192124},{"_id":"public/2023/09/07/Vue/Vue2源码分析/【源码剖析】new Vue 发生了什么/index.html","hash":"0e03ee5aaea13c428bfa0f07159692aadd73f331","modified":1731120192124},{"_id":"public/2023/09/07/浏览器/【浏览器】之渲染机制/index.html","hash":"ad91f449e0dbba951923b47fa479683445bd45d7","modified":1731120192124},{"_id":"public/2023/09/06/浏览器/【浏览器】之跨域/index.html","hash":"77172efc066caa6fd003bcdbf1903b346b888bfb","modified":1731120192124},{"_id":"public/2023/09/05/浏览器/【浏览器】之缓存/index.html","hash":"6a008d0681b7993b8fa5d28aa20f56707f98834c","modified":1731120192124},{"_id":"public/2023/08/31/leetcode/Sort/selectionSort/selectionSort/index.html","hash":"19dc948363f4344708d3bfa7dab4c3de071eb47b","modified":1731120192124},{"_id":"public/2023/08/30/leetcode/Sort/shellSort/shellSort/index.html","hash":"a3a58e420b4b2082b63804b3a381af425f870ea7","modified":1731120192124},{"_id":"public/2023/08/29/leetcode/Sort/insertionSort/insertionSort/index.html","hash":"7e407de8d088ad958365928a618a87ee974c9c64","modified":1731120192124},{"_id":"public/2023/08/28/leetcode/Sort/bubbleSort/bubbleSort/index.html","hash":"437e6ad9a93a095693fd34be5cec97e9c9b0280f","modified":1731120192124},{"_id":"public/2023/08/26/leetcode/String/LeetCode 049：字母异位词分组/index.html","hash":"982195300008b0a72b89e35a6676e3b36eec0099","modified":1731120192124},{"_id":"public/2023/08/25/leetcode/String/ LeetCode 039：组合总和/index.html","hash":"cd710109e223d84de1ee10e50010c068899dc621","modified":1731120192124},{"_id":"public/2023/08/27/leetcode/Stack/LeetCode 020：有效的括号/index.html","hash":"0312043eac4b879c61d3b6973fb3ff90a855b36f","modified":1731120192124},{"_id":"public/2023/08/24/leetcode/String/LeetCode 030：串联所有单词的子串/index.html","hash":"5a4d047003c918eece2e96aba1d462dfac54fad5","modified":1731120192124},{"_id":"public/2023/08/23/leetcode/String/LeetCode 006：N 字形变换/index.html","hash":"d2be9e4c907ba2d100d54f9bba32d140820e6168","modified":1731120192124},{"_id":"public/2023/08/19/leetcode/String/LeetCode 003：无重复字符的最长子串/index.html","hash":"fec9ee3d5ac292e88cf1040d8ab84e5e13e57d44","modified":1731120192124},{"_id":"public/2023/08/22/leetcode/String/LeetCode 005：最长回文子串/index.html","hash":"2e290ad04ea661dcbd601f2ca0599bd28cdbe074","modified":1731120192124},{"_id":"public/2023/08/18/Bug/兼容性/https的图片在移动端展示问题/index.html","hash":"7dd0460e0b79c1ae961665f5624287337d4babbe","modified":1731120192124},{"_id":"public/2023/08/17/JavaScript/JavaScript面试/JavaScript面试/index.html","hash":"578eef9a661edf8aeb734b834be0d157385116b0","modified":1731120192124},{"_id":"public/2023/08/13/浏览器/ 【浏览器】之同源策略/index.html","hash":"42b1a3cd98845ae15c00bb54e5b621fab70c24c0","modified":1731120192124},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值/index.html","hash":"8622755250cac4c5f0f54f0d652a44e986b0c02e","modified":1731120192124},{"_id":"public/2023/08/13/js去除中括号/index.html","hash":"493910c78b961b234a608246bfea7cf30b7593e0","modified":1731120192124},{"_id":"public/2022/07/10/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并/index.html","hash":"d1223e49d395f0aa94cdfa3984a48d904934fc8f","modified":1731120192124},{"_id":"public/2022/07/20/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）/index.html","hash":"b5ca673e2d132116f701a86ff4a5f57d164ae9a5","modified":1731120192124},{"_id":"public/2022/07/09/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流/index.html","hash":"29f18e0bd7cd4d5313aaab32dbedc5bbf788f725","modified":1731120192124},{"_id":"public/2023/08/13/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量/index.html","hash":"e29e825b8f2c12921c9b3802f59d97624330d22c","modified":1731120192124},{"_id":"public/2022/07/08/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖/index.html","hash":"4b52b4a6dd3683093d2ed7529254648bcc474247","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echats折线--拐点圆的样式（内圆外圆）/index.html","hash":"5245a2d0aec2da7b9f0e18c1566d34ab373aac15","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts柱形--设置柱子多个颜色（渐进色）/index.html","hash":"5a2b4fa28cd51052a9507cfd1ad0966c78b8fcb7","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts折线图--无拐点，折线样式/index.html","hash":"952c55684544502798367772ff9f5a4d9ab4389d","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts折线--无数据时连线与否/index.html","hash":"4975071a7d6ed119690a314c78091fddda915d65","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts圆柱--设置柱子的borderRadius/index.html","hash":"3dd14d5c62d5b003ece2695a455b6dcde8ca474c","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts图例--选中状态（默认不显示置灰）/index.html","hash":"1fda6cd13a8649ef3ccb5545222a4d04d4275c92","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts设置从原点开始/index.html","hash":"45d48e5ba1c3b4571c0e764bb47d06d60f07b935","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts--上下左右的距离（grid）/index.html","hash":"9cddd232631d0b2a4dfa6a4c57b7f9fd2ea1a9d2","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts--基准线markLine/index.html","hash":"796353e11bc97e0794e39891b6e03ff22236694e","modified":1731120192124},{"_id":"public/2022/03/10/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线/index.html","hash":"925b5ff3a205789cab8a92a5c0c59f36c1fde586","modified":1731120192124},{"_id":"public/archives/page/2/index.html","hash":"43b38740ee0841f3602a71fd45e8a3132966ec9c","modified":1731120217038},{"_id":"public/archives/index.html","hash":"9e6c4a150c1d6cb66c65355f977fa616c1ca212c","modified":1731120217038},{"_id":"public/archives/page/3/index.html","hash":"8fc0b0c91378ccfa50c7d4fdc3a7112f14249649","modified":1731120217038},{"_id":"public/archives/page/4/index.html","hash":"ec638791bdd0430f957f4f6707803371527ef18c","modified":1731120217038},{"_id":"public/archives/page/5/index.html","hash":"90eadd4c62706216372c75831a80dd734e37194a","modified":1731120217038},{"_id":"public/archives/page/6/index.html","hash":"0ebc7113ba196125d0d6c66bc2c7182f538b79b2","modified":1731120217038},{"_id":"public/archives/2022/index.html","hash":"cc4356a00e668ac26694d9d24ef3f35c5a4f9ce3","modified":1731120217038},{"_id":"public/archives/2022/07/index.html","hash":"cee65b9d165ebda77cd8465058ca09540ac96341","modified":1731120217038},{"_id":"public/archives/2023/index.html","hash":"ea3729b52d268d86ebabb49c042b778ee9aeb2c3","modified":1731120217038},{"_id":"public/archives/2022/03/index.html","hash":"be2d9ee52327c1eb73d2859ae664d4834918e4cc","modified":1731120217038},{"_id":"public/archives/2023/page/2/index.html","hash":"32c697291337d28fbaf7fbf0460b0c39dd4dd9e3","modified":1731120217038},{"_id":"public/archives/2022/page/2/index.html","hash":"4b1039c06655613d55dc8c4db066b9fe67cc3ae5","modified":1731120217038},{"_id":"public/archives/2023/page/3/index.html","hash":"cfc32f186c2a9fca9adbcc282228c5e89f648a13","modified":1731120217038},{"_id":"public/archives/2023/08/index.html","hash":"f45952b664cb5ccb5cfb282423eff10c8f7241c4","modified":1731120217038},{"_id":"public/archives/2023/08/page/2/index.html","hash":"c78cad90ce8ae305ee82fb23322411da3a34aa9e","modified":1731120217038},{"_id":"public/archives/2023/09/index.html","hash":"d32d2f23977830465ee217571e85a84e958e5b8b","modified":1731120217038},{"_id":"public/archives/2023/12/index.html","hash":"51f28676382fe908c9b5549c5bf28c56ee76ce69","modified":1731120217038},{"_id":"public/archives/2024/page/2/index.html","hash":"1c97d23a71692003e99da783ebc2144d9b229e54","modified":1731120217038},{"_id":"public/archives/2024/index.html","hash":"bdfcb7e526b0e7384a46b95d2a3f4458932b9b0f","modified":1731120217038},{"_id":"public/archives/2024/10/index.html","hash":"f459b6a456dbe49050c4d4aba87254478e9365ce","modified":1731120217038},{"_id":"public/archives/2024/10/page/2/index.html","hash":"92c3153f97e96cbc772d622d352d6575dfbc324a","modified":1731120217038},{"_id":"public/archives/2024/11/index.html","hash":"4f78a7b429b49c3849d1e65a5478a520511a77d2","modified":1731120217038},{"_id":"public/categories/前端/index.html","hash":"7c8a8e30e96d2cfb7b25190a0838d1f1e7418ad7","modified":1731120217038},{"_id":"public/archives/2024/08/index.html","hash":"d46ad093abf11f5955148b665a5ffd0c4137ef23","modified":1731120217038},{"_id":"public/categories/前端/page/4/index.html","hash":"5ad2321ca363e1779827f137d8b847d47aa58c0b","modified":1731120217038},{"_id":"public/categories/前端/page/3/index.html","hash":"c101f66f89c6a7a69029a6a385a91cef529426c9","modified":1731120217038},{"_id":"public/categories/前端/page/2/index.html","hash":"ddcd25b1d93c79fd125802a141cbb02970764174","modified":1731120217038},{"_id":"public/categories/前端/page/5/index.html","hash":"e95c0b850df0ccd1324999d61ffd202a548a207f","modified":1731120217038},{"_id":"public/categories/前端/page/6/index.html","hash":"a767c1cbb4efd75e490756dd84816fda5b2b6964","modified":1731120217038},{"_id":"public/categories/前端/正则/index.html","hash":"d163ef5ad8c4ba963f73aafb88efc796cd0661bb","modified":1731120217038},{"_id":"public/categories/前端/Echarts/index.html","hash":"5c76e098aba0ceec7d87be10a99cffdfb802fad5","modified":1731120217038},{"_id":"public/categories/前端/Echarts/boundaryGap/index.html","hash":"400d91a623316d4f9e88f86f10e7ba899650d15b","modified":1731120217038},{"_id":"public/categories/前端/Echarts/markLine/index.html","hash":"2b5a5eade8b0722d27796c7e851d42eb0606c58b","modified":1731120217038},{"_id":"public/categories/前端/浏览器/index.html","hash":"4fbe5231d8818021003b5559bf07e0d0fbccc876","modified":1731120217038},{"_id":"public/categories/前端/Echarts/grid/index.html","hash":"2cc7b2c6e4d4b524b8370abd192fbf0019a9bb06","modified":1731120217038},{"_id":"public/categories/前端/Echarts/xAxis/index.html","hash":"cd0fcb63cc413e7453ba0dc1c52e67bf85d756c5","modified":1731120217038},{"_id":"public/categories/Bug/index.html","hash":"17d8aa3ebc9471f0660717ff89b797e403d61504","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/index.html","hash":"70f18ac14f7428d54f1cd242ffb338334672dd18","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/page/2/index.html","hash":"f2a97b2d7083cfec64d264f7fd8a2a36ca477315","modified":1731120217038},{"_id":"public/categories/前端/Echarts/borderRadius/index.html","hash":"f1d558f757bc389bd315fc9ac85192d60605b55f","modified":1731120217038},{"_id":"public/categories/前端/Vue/index.html","hash":"27c05deabb3c8bded71a4f119a537b429d6a7fbe","modified":1731120217038},{"_id":"public/categories/前端/Echarts/connectNulls/index.html","hash":"21aedd4a7f77bceee794f3731b7b74c288bac214","modified":1731120217038},{"_id":"public/categories/前端/Echarts/itemStyle/index.html","hash":"58e18d9cde940221604f72edbf8f3f19be742631","modified":1731120217038},{"_id":"public/categories/前端/leetcode/index.html","hash":"f4f65b1bb5b2be31d7859487ee5bb4b4d47be5e6","modified":1731120217038},{"_id":"public/categories/前端/Echarts/symbolSize/index.html","hash":"969cc9bc88c3e83281179270aa1f899f6d8a98ec","modified":1731120217038},{"_id":"public/categories/前端/leetcode/page/2/index.html","hash":"3ba4b6268fbf3ef667c9b65c19b28cf7ae55468f","modified":1731120217038},{"_id":"public/categories/前端/算法/index.html","hash":"28b2cdf7bca31d97ff3af56061d368a457d9445f","modified":1731120217038},{"_id":"public/categories/前端/Echarts/legend/index.html","hash":"175681dd141185806ae1f8ff3ae6207297af26df","modified":1731120217038},{"_id":"public/categories/前端/算法/page/2/index.html","hash":"df30a6b0a16531f20a78ae784f11fae0d33cdc12","modified":1731120217038},{"_id":"public/categories/前端/Echarts/symbol/index.html","hash":"9ebcdf16a7056368d389fa60defa204d50dd3927","modified":1731120217038},{"_id":"public/categories/前端/浏览器/渲染机制/index.html","hash":"dc13dafa0f2963d6c337d9f516130ec4d52e7e5b","modified":1731120217038},{"_id":"public/categories/前端/tinymce/index.html","hash":"462d50c4be01a0ffdcc14e3831ca6a1b69cb80ed","modified":1731120217038},{"_id":"public/categories/Bug/兼容性/index.html","hash":"5947f3dae0b59dcb009a27811bb76de5054299ad","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/ES6/index.html","hash":"6921f3ba3793a986749cab3956f9b9b33f3e91f3","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/index.html","hash":"666fce909538814bf7cd0691c99dcd51dc2908ca","modified":1731120217038},{"_id":"public/categories/前端/Vue/Vue2源码剖析/index.html","hash":"6f4a7b9ab78c8f5792d89f8672ab71b97b603c93","modified":1731120217038},{"_id":"public/categories/前端/浏览器/同源策略/index.html","hash":"a67d3ac2b9cfee9fbb3d509d1e08fea8c62d893b","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/ES6模块和CommonJS的异同/index.html","hash":"b3bf2f4c8e1c51f4c4fd4a4615d3718a12485a4b","modified":1731120217038},{"_id":"public/categories/前端/leetcode/004寻找两个正序数组的中位数/index.html","hash":"0f38625bcdd8eaab7a498cfb63d6516b8a71f18f","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/如何提取url的参数/index.html","hash":"b536128fb2ec0199d935df47d1f80a1d9a3f7bd6","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/输入url/index.html","hash":"06974202ac42a5e350c07d3f07251161ecf21594","modified":1731120217038},{"_id":"public/categories/前端/leetcode/020盛最多水的容器/index.html","hash":"3738971d09498dc059ae26b24a6dd35b28a7d5f8","modified":1731120217038},{"_id":"public/categories/前端/leetcode/020有效的括号/index.html","hash":"d0c1b5a46ee703c75e8adff8cec331ec4e7543ff","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/前端白屏时间长的原因有哪些，怎么优化/index.html","hash":"8368dc4f2993520f48528e0c1f20362b336e2538","modified":1731120217038},{"_id":"public/categories/前端/leetcode/039组合总和/index.html","hash":"7276c88c279f768c7915adcc9e2c4a5ffe619063","modified":1731120217038},{"_id":"public/categories/前端/leetcode/003无重复字符的最长子串/index.html","hash":"bd46486a0ab055a8c537d6aa07a357c97ce9ff46","modified":1731120217038},{"_id":"public/categories/前端/leetcode/005最长回文子串/index.html","hash":"af6a89e5e5dde3b171653946f0a640c204094a4a","modified":1731120217038},{"_id":"public/categories/前端/leetcode/006N-字形变换/index.html","hash":"68e9ee879b6426686ff5d58fc03d36d07ef4ac3b","modified":1731120217038},{"_id":"public/categories/前端/算法/分治法/index.html","hash":"25d63c1af63a61ba2bdc26e82b174efbab213370","modified":1731120217038},{"_id":"public/categories/前端/leetcode/030串联所有单词的子串/index.html","hash":"6ea4956c9b09c45de46947e82e94f4a13aafaad2","modified":1731120217038},{"_id":"public/categories/前端/leetcode/049字母异位词分组/index.html","hash":"3a0402056cdd9fc7d288686c2d5adbea6bd859b0","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/index.html","hash":"7fcd7860bf99a43b5ec32c81a72bd404acf5b5e1","modified":1731120217038},{"_id":"public/categories/Bug/兼容性/img/index.html","hash":"c573799b6ce6a0d75ae54543619bf84cf7a1d89d","modified":1731120217038},{"_id":"public/categories/前端/tinymce/tools/index.html","hash":"367d3b5755f83e63ca7e5727f96112b112da5716","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/ES6/变量/index.html","hash":"3d876d4569520891e5777c629896de0a732bd07a","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/ES6/解构/index.html","hash":"8edb860bf163ca6fd4f389a9ff157d5a17b9addc","modified":1731120217038},{"_id":"public/categories/前端/leetcode/冒泡排序/index.html","hash":"ace5baccaecfe06aca367eda6585a209823acc27","modified":1731120217038},{"_id":"public/categories/前端/leetcode/插入排序/index.html","hash":"e3d625e7d9a50d3c4a384d76939536be075014e8","modified":1731120217038},{"_id":"public/categories/前端/leetcode/希尔排序/index.html","hash":"465ea377983deeacd0466c3ceba8a32580b21345","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/数组去重/index.html","hash":"be1dfcd83b975ad39e1a52a8a0b17873cb667497","modified":1731120217038},{"_id":"public/categories/前端/leetcode/选择排序/index.html","hash":"22520efc6e0c64e2274b1724a31a4fd3b19c72a4","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/防抖/index.html","hash":"1971d97374fc80ec1c5f76bf1963db30f60b204d","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/JavaScript深入理解/节流/index.html","hash":"414d931ce30dae23ae909c62174c22b169538074","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/输入url/到页面展示的过程/index.html","hash":"135a71057977f7453f85961d468899dbf545fdbb","modified":1731120217038},{"_id":"public/categories/前端/算法/分治法/寻找第k小元素/index.html","hash":"553380b8790914a03f07530944cc0cc10c112589","modified":1731120217038},{"_id":"public/categories/前端/算法/分治法/最大子数组问题/index.html","hash":"2c0d393c688e755b78111efb42ed218fd917dae3","modified":1731120217038},{"_id":"public/categories/前端/算法/分治法/棋盘覆盖问题/index.html","hash":"28efc5f70cfdf7ceeb0c5b8e26ade30313e58d49","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/0-1背包问题/index.html","hash":"b6b99371408250c753ad731e001c0d4555b5fa4b","modified":1731120217038},{"_id":"public/categories/前端/算法/分治法/最近点对问题/index.html","hash":"c7859218a18008a65bfc1eb8872fe21f8b3918fd","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/最大子数组问题/index.html","hash":"7a67ccbe0701c995734f120e3cbcc7d22f5a8647","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/最长公共子序列/index.html","hash":"a0b0774115ec6e9065340df598f53453ff6dd4cb","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/状态压缩动态规划/index.html","hash":"2527149dedb6756634649197853be2b26a9a1775","modified":1731120217038},{"_id":"public/categories/前端/算法/动态规划/旅行商问题/index.html","hash":"a14ab2a32b92b9f29ec64de0d02ffe823ac3a648","modified":1731120217038},{"_id":"public/categories/前端/浏览器/缓存/index.html","hash":"4f26d2dd734009a15ee10f4a8d5df744cc20d774","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/lodash源码分析/index.html","hash":"bcf0be10672b9c5d34885c25ac03ab088834407a","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/JavaScript面试/index.html","hash":"757bea50ac472763a35520b053b8ef2a64c2dbce","modified":1731120217038},{"_id":"public/categories/前端/浏览器/跨域/index.html","hash":"d4e1807ada0df541b71deca69bf1a4380c8b8dac","modified":1731120217038},{"_id":"public/categories/前端/JavaScript/lodash源码分析/防抖节流/index.html","hash":"4e32f618a4af0bb61a41e258dd1760d28e404c4c","modified":1731120217038},{"_id":"public/page/3/index.html","hash":"838b173222fdb1bd67148334f9f5b12b18ba3ab6","modified":1731120217038},{"_id":"public/page/2/index.html","hash":"8cbf1cd2e707a39c5ba07dc5a765a3c7d61e2b52","modified":1731120217038},{"_id":"public/index.html","hash":"4e80acfd6245f6b87da3f808638e98634b230755","modified":1731120217038},{"_id":"public/page/5/index.html","hash":"c648215aafe0b0b50e00ea1b123a02086abafb6e","modified":1731120217038},{"_id":"public/page/6/index.html","hash":"8ac8d03dbf147429bf507d258e175e9437fb885e","modified":1731120217038},{"_id":"public/page/4/index.html","hash":"289340b1c9d94872b67f4a7a025a10b3771aefe9","modified":1731120217038},{"_id":"public/tags/前端/index.html","hash":"aa0a4b358dd80d66b992e222a38e1e5a440432ba","modified":1731120217038},{"_id":"public/tags/js/index.html","hash":"56ebefe17d62d0260f0ea078dda0d116a98be9be","modified":1731120217038},{"_id":"public/tags/Echarts/index.html","hash":"f33603b73a424177a4eca4026d55ba2846db728d","modified":1731120217038},{"_id":"public/tags/前端/page/2/index.html","hash":"9777e216fab35f164c5ed0d396fc7f542163f668","modified":1731120217038},{"_id":"public/tags/浏览器/index.html","hash":"5d9a530556cbf2058002c9cccf09ed720caaea7f","modified":1731120217038},{"_id":"public/tags/Bug/index.html","hash":"ac13c8b5fd79b845f8304aeb2c8f53327d97379d","modified":1731120217038},{"_id":"public/tags/正则/index.html","hash":"aa67a06acfa1118b01ea2651089451eca37488aa","modified":1731120217038},{"_id":"public/tags/兼容性/index.html","hash":"ea5194b5e65e0c9170f4c56a0eed04756cbcef64","modified":1731120217038},{"_id":"public/tags/JavaScript/index.html","hash":"add4a05d331812488dc5233c92f99a7c9656c8b1","modified":1731120217038},{"_id":"public/tags/源码剖析/index.html","hash":"14fb60c5fb96c75ad0186d9ddf0c19ad483bc4bb","modified":1731120217038},{"_id":"public/tags/ES6/index.html","hash":"cf36bd956fdc62c5018c47738fca7d1e833f4650","modified":1731120217038},{"_id":"public/tags/Vue/index.html","hash":"d338d8961baf442dde3e8d1e9b4afe0151accc83","modified":1731120217038},{"_id":"public/tags/JavaScript面试/index.html","hash":"475c783c7a4a0bc26d121cefd38682c386e44042","modified":1731120217038},{"_id":"public/tags/leetcode/index.html","hash":"e2e97f49074a7e1704395f304daf2418a5adf41f","modified":1731120217038},{"_id":"public/tags/leetcode/page/2/index.html","hash":"b7b2f68e5473f65a27aa6690579e057502129992","modified":1731120217038},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"5b036c4f9225917bf43b39749ef233fa5859a2cc","modified":1731120217038},{"_id":"public/tags/栈/index.html","hash":"4d38fee68d310f0f0e63ba0c92e1b80a68c0c12a","modified":1731120217038},{"_id":"public/tags/数组/index.html","hash":"6941aa3856e63f81a13d9966dfd95f51ef0d1ea4","modified":1731120217038},{"_id":"public/tags/字符串/index.html","hash":"3afd656347a275b3ebaa0ba2e1ee20472e44f0d7","modified":1731120217038},{"_id":"public/tags/算法/index.html","hash":"a6b8b45a8a35dde6b6cbd513fde8643402b62faf","modified":1731120217038},{"_id":"public/tags/算法/page/2/index.html","hash":"1dc08f6aef156cbcb7eaa3524d4283c0cf0ec0ea","modified":1731120217038},{"_id":"public/tags/分治法/index.html","hash":"f1b7e372aad00a2a09bf805bd8b27252e2c79767","modified":1731120217038},{"_id":"public/tags/动态规划/index.html","hash":"4ecb553e55dcf9bf3b5f5d6c034d4aa18d83fe0f","modified":1731120217038},{"_id":"public/tags/tinymce/index.html","hash":"3ec39182e7d193f78af15d56c39de6c183083126","modified":1731120217038},{"_id":"public/tags/选择排序/index.html","hash":"c63700ab4616d87577ec0638f78c207b2af15673","modified":1731120217038},{"_id":"public/tags/冒泡排序/index.html","hash":"043cc2f7af91946370c503c6782eb7e8877b8ef4","modified":1731120217038},{"_id":"public/tags/插入排序/index.html","hash":"4ed6442064389283fc57c0590899a714549c81cc","modified":1731120217038},{"_id":"public/tags/希尔排序/index.html","hash":"73b16e966ea332e1cab311f43e681fd6a3e47681","modified":1731120217038},{"_id":"public/tags/lodash/index.html","hash":"cdad2b46f93997f9ea2f1aa27af2e7ad1501a7b2","modified":1731120217038},{"_id":"public/images/avatar1.png","hash":"642ef58c0781d0f1885775ddd349ca7af65f24b0","modified":1731119087483},{"_id":"public/images/favicon.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1731119087483},{"_id":"public/images/favicon1.png","hash":"21cf9c2e9c36c244a6542a3b6c220f13fa1a67cc","modified":1731119087483},{"_id":"public/images/avatar.jpeg","hash":"4111590cb829b7159c29d8f4f2356547a9d0e094","modified":1731119087483},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1731119087483},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1731119087483},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1731119087483},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1731119087483},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1731119087483},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1731119087483},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1731119087483},{"_id":"public/css/index.css","hash":"9a4d4bb2cc4ac0510227cd7185e3d619130e073d","modified":1731119087483},{"_id":"public/images/bg.jpeg","hash":"9aa11ebfc2e41ae20b1035539eebe7b3cf8fde37","modified":1731119087483},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1731119087483},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1731119087483},{"_id":"source/_posts/JavaScript/JavaScript面试/深浅拷贝.md","hash":"a884b7c199a5e429a72956442d32ed420df5dd69","modified":1731120113322},{"_id":"public/2024/11/09/JavaScript/JavaScript面试/深浅拷贝/index.html","hash":"3216d80118593ac305b86e83adc434c8886558b8","modified":1731120192124},{"_id":"public/categories/前端/JavaScript/深浅拷贝/index.html","hash":"a12185c84073ba013ca3a56e0a3cda49b7ca9b5a","modified":1731120217038}],"Category":[{"name":"前端","_id":"cm39jlww80004m32vbfdbe8rg"},{"name":"Echarts","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwe000lm32vak1n75su"},{"name":"正则","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwj0019m32v9gsp64hd"},{"name":"boundaryGap","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwp0025m32v06kw9vre"},{"name":"markLine","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwq002cm32v3ow6d22g"},{"name":"浏览器","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwws002km32vetcx8bbl"},{"name":"grid","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwu002zm32vbkorhian"},{"name":"xAxis","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwww0035m32v9go64do9"},{"name":"Bug","_id":"cm39jlwwx003cm32vgfpi3quy"},{"name":"borderRadius","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwy003km32v4frjee1v"},{"name":"JavaScript","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx0003rm32v3lx2alna"},{"name":"symbolSize","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx20045m32v7qs48vhm"},{"name":"Vue","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx5004mm32veddh1xd2"},{"name":"connectNulls","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx6004om32v6ygdgp59"},{"name":"itemStyle","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx70050m32v69yd0zum"},{"name":"leetcode","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx80054m32vb4r5f2er"},{"name":"legend","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx8005dm32v6lk07vmk"},{"name":"symbol","parent":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwxa005pm32vabczgucb"},{"name":"算法","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxe006dm32vhyo175cg"},{"name":"同源策略","parent":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwxe006hm32v8tmhf6a9"},{"name":"渲染机制","parent":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwxg006rm32vditsgj2i"},{"name":"兼容性","parent":"cm39jlwwx003cm32vgfpi3quy","_id":"cm39jlwxj007jm32v296f9t5p"},{"name":"tinymce","parent":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxl007tm32v61d1g345"},{"name":"ES6","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxl007zm32v0c3n9dsj"},{"name":"JavaScript深入理解","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxo008km32v3bol6tgl"},{"name":"Vue2源码剖析","parent":"cm39jlwx5004mm32veddh1xd2","_id":"cm39jlwxq008um32v3ni321fs"},{"name":"ES6模块和CommonJS的异同","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxr0090m32v4ifc0xs6"},{"name":"004寻找两个正序数组的中位数","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxr0097m32v488ga7ej"},{"name":"如何提取url的参数","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxs009cm32v1rwf53wd"},{"name":"输入url","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxs009im32vfca7f7eo"},{"name":"020盛最多水的容器","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxt009mm32vf1a814sy"},{"name":"020有效的括号","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxt009um32v3zoz0xe9"},{"name":"前端白屏时间长的原因有哪些，怎么优化","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxu009ym32v3fbr1j34"},{"name":"039组合总和","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxu00a4m32v813104dx"},{"name":"003无重复字符的最长子串","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxv00a7m32vaafbbed4"},{"name":"005最长回文子串","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxv00adm32vaw0ng5f5"},{"name":"006N 字形变换","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxv00agm32vdqat3gvh"},{"name":"分治法","parent":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwxw00ajm32vhwtr8zsf"},{"name":"030串联所有单词的子串","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxw00amm32vf4h7fwu3"},{"name":"049字母异位词分组","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxw00atm32vbip29i5j"},{"name":"动态规划","parent":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwxy00b5m32v8p5820jy"},{"name":"img","parent":"cm39jlwxj007jm32v296f9t5p","_id":"cm39jlwxy00bdm32v5ute259e"},{"name":"tools","parent":"cm39jlwxl007tm32v61d1g345","_id":"cm39jlwxz00blm32v68ds7aaj"},{"name":"变量","parent":"cm39jlwxl007zm32v0c3n9dsj","_id":"cm39jlwy000bom32v8ojwg060"},{"name":"选择排序","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy000btm32v6dq2hbwi"},{"name":"解构","parent":"cm39jlwxl007zm32v0c3n9dsj","_id":"cm39jlwy000bxm32vdsqwdeq6"},{"name":"冒泡排序","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy100c0m32v1rs6gcer"},{"name":"插入排序","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy100c3m32v9cqjdcra"},{"name":"希尔排序","parent":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy200c6m32vb6fhel0m"},{"name":"数组去重","parent":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy200cam32v80540883"},{"name":"防抖","parent":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy300cdm32v8j08enaj"},{"name":"节流","parent":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy300cgm32v5v6ue1qn"},{"name":"到页面展示的过程","parent":"cm39jlwxs009im32vfca7f7eo","_id":"cm39jlwy300cjm32v2lv6gsh9"},{"name":"寻找第k小元素","parent":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy400cnm32vfei01hhn"},{"name":"最大子数组问题","parent":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy400cqm32v96ct6lgk"},{"name":"最近点对问题","parent":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy400ctm32vghdv8eho"},{"name":"棋盘覆盖问题","parent":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy500cwm32v3ou0aa4h"},{"name":"0-1背包问题","parent":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy500d0m32vavew05qz"},{"name":"最大子数组问题","parent":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy500d3m32v8un3havz"},{"name":"旅行商问题","parent":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy600d6m32ve1beggfz"},{"name":"状态压缩动态规划","parent":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy600d9m32vcou58p93"},{"name":"最长公共子序列","parent":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy700ddm32ves1y26wk"},{"name":"缓存","parent":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwyb00eim32v3xam6xei"},{"name":"跨域","parent":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwyc00emm32v9j8cfc0b"},{"name":"lodash源码分析","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwyc00erm32v4kwl3oul"},{"name":"JavaScript面试","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwyd00evm32v3t0dhhu4"},{"name":"防抖节流","parent":"cm39jlwyc00erm32v4kwl3oul","_id":"cm39jlwyd00eym32vc1qmes93"},{"name":"深浅拷贝","parent":"cm39jlwx0003rm32v3lx2alna","_id":"cm39k9n0j00029k2vbafh2xs8"}],"Data":[],"Page":[{"title":"friends","date":"2023-08-13T03:00:46.518Z","type":"friends","categories":null,"tags":null,"_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate:\ntype: 'friends'\ncategories:\ntags:\n---\n","updated":"2023-08-13T03:00:46.518Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cm39jlww50000m32v0mvs957t","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"about","date":"2023-08-13T07:47:11.319Z","type":"about","categories":null,"tags":null,"_content":"\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","source":"about/index.md","raw":"---\ntitle: about\ndate:\ntype: 'about'\ncategories:\ntags:\n---\n\n### Hi there, I'm yihan123 👋\n\n👯 I'm Peng Yao hui, a web frontend developer from ChangSha, China.\n\n- 🌱 : JavaScript/Css3/Html5/Vue/React\n- 🔭 : Work in shenzhen\n- 😄 : CSDN:[易函 123](https://blog.csdn.net/qq_43485006)/思否:[易函 123](https://segmentfault.com/u/yihan123)/掘金:[易函 123](https://juejin.cn/user/3016715638158381)/博客园：[易函 123](https://www.cnblogs.com/yihan123/)\n- 💬 : Email: 1245501816@qq.com\n- ⚡ : Live and learn\n","updated":"2023-08-13T07:47:11.319Z","path":"about/index.html","comments":1,"layout":"page","_id":"cm39jlww80002m32v9rfxh1lv","content":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#x31;&#x32;&#52;&#53;&#x35;&#x30;&#49;&#x38;&#49;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;\">&#x31;&#x32;&#52;&#53;&#x35;&#x30;&#49;&#x38;&#49;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"Hi-there-I’m-yihan123-👋\"><a href=\"#Hi-there-I’m-yihan123-👋\" class=\"headerlink\" title=\"Hi there, I’m yihan123 👋\"></a>Hi there, I’m yihan123 👋</h3><p>👯 I’m Peng Yao hui, a web frontend developer from ChangSha, China.</p>\n<ul>\n<li>🌱 : JavaScript&#x2F;Css3&#x2F;Html5&#x2F;Vue&#x2F;React</li>\n<li>🔭 : Work in shenzhen</li>\n<li>😄 : CSDN:<a href=\"https://blog.csdn.net/qq_43485006\">易函 123</a>&#x2F;思否:<a href=\"https://segmentfault.com/u/yihan123\">易函 123</a>&#x2F;掘金:<a href=\"https://juejin.cn/user/3016715638158381\">易函 123</a>&#x2F;博客园：<a href=\"https://www.cnblogs.com/yihan123/\">易函 123</a></li>\n<li>💬 : Email: <a href=\"mailto:&#x31;&#x32;&#52;&#53;&#x35;&#x30;&#49;&#x38;&#49;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;\">&#x31;&#x32;&#52;&#53;&#x35;&#x30;&#49;&#x38;&#49;&#54;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a></li>\n<li>⚡ : Live and learn</li>\n</ul>\n"},{"title":"tags","date":"2023-08-13T01:51:52.600Z","type":"tags","categories":null,"tags":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate:\ntype: 'tags'\ncategories:\ntags:\n---\n","updated":"2023-08-13T01:51:52.600Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cm39jlww90006m32v99rj8iom","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"categories","date":"2023-08-13T02:31:49.242Z","type":"categories","categories":null,"tags":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate:\ntype: 'categories'\ncategories:\ntags:\n---\n","updated":"2023-08-13T02:31:49.242Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm39jlwwa0008m32vfdae7ahw","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"【Echarts使用】之 grid","date":"2022-03-10T03:38:39.986Z","_content":"\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","source":"_posts/Echarts/echarts--上下左右的距离（grid）.md","raw":"---\ntitle: 【Echarts使用】之 grid\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, grid]\n---\n\n### 示例\n\n```\ngrid: {\n    top: '3%',\n    left: '12%',\n    right: '0%',\n    bottom: '3%',\n    containLabel: true\n},\n```\n\necharts 组件离容器左侧的距离。\n\n> `containLabel`:\n> containLabel 为 false 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。\n> 这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。\n>\n> containLabel 为 true 的时候：  \n> grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。\n> 这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。\n","slug":"Echarts/echarts--上下左右的距离（grid）","published":1,"updated":"2023-08-13T11:59:37.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlww60001m32vhosu9xma","content":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grid: &#123;</span><br><span class=\"line\">    top: &#x27;3%&#x27;,</span><br><span class=\"line\">    left: &#x27;12%&#x27;,</span><br><span class=\"line\">    right: &#x27;0%&#x27;,</span><br><span class=\"line\">    bottom: &#x27;3%&#x27;,</span><br><span class=\"line\">    containLabel: true</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>echarts 组件离容器左侧的距离。</p>\n<blockquote>\n<p><code>containLabel</code>:<br>containLabel 为 false 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是由坐标轴形成的矩形的尺寸和位置。<br>这比较适用于多个 grid 进行对齐的场景，因为往往多个 grid 对齐的时候，是依据坐标轴来对齐的。</p>\n<p>containLabel 为 true 的时候：<br>grid.left grid.right grid.top grid.bottom grid.width grid.height 决定的是包括了坐标轴标签在内的所有内容所形成的矩形的位置。<br>这常用于『防止标签溢出』的场景，标签溢出指的是，标签长度动态变化时，可能会溢出容器或者覆盖其他组件。</p>\n</blockquote>\n"},{"title":"js去除中括号","date":"2023-08-13T01:44:43.677Z","_content":"\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","source":"_posts/js去除中括号.md","raw":"---\ntitle: js去除中括号\ndate:\ntags: [js, 正则]\ncategories: [前端, 正则]\n---\n\n```javascript\nvar str = '这是一个字符串[html]语句;[html]字符串很常见';<br>\nalert(str.replace(/\\[|]/g,''));//移除字符串中的所有[]括号（不包括其内容）\n//输出：这是一个字符串html语句;html字符串很常见<br>\nalert(str.replace(/\\[.*?\\]/g,''));//移除字符串中的所有[]括号（包括其内容）\n//输出：这是一个字符串语句;字符串很常见\n```\n\n### 移除所有中括号,不包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[|]/g, '')\nconsole.log(newStr) //1,2,3,4,5,6,7,8\n```\n\n### 移除所有中括号,包括其内容\n\n```javascript\nlet str = '[1,2,3,4,5,6,7,8]'\nlet newStr = str.replace(/\\[.*?\\]/g, '')\nconsole.log(newStr) //''\n```\n\n<!--more-->\n\n### 正则表达式符号释义\n\n- \"\\\"：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”；\n\n- \"|\"：或的意思；\n\n- \"/g\"：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；\n\n- \".\"：表示除换行符和其他 Unicode 行终止符之外的任意字符；\n\n- \"*\"：匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。\\*等价于{0,}；\n\n- \"?\"：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）\n","slug":"js去除中括号","published":1,"updated":"2023-08-13T06:43:05.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlww80003m32vbzhi89ms","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;这是一个字符串[html]语句;[html]字符串很常见&#x27;</span>;&lt;br&gt;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（不包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串html语句;html字符串很常见&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"title function_\">alert</span>(str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>,<span class=\"string\">&#x27;&#x27;</span>));<span class=\"comment\">//移除字符串中的所有[]括号（包括其内容）</span></span><br><span class=\"line\"><span class=\"comment\">//输出：这是一个字符串语句;字符串很常见</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-不包括其内容\"><a href=\"#移除所有中括号-不包括其内容\" class=\"headerlink\" title=\"移除所有中括号,不包括其内容\"></a>移除所有中括号,不包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[|]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//1,2,3,4,5,6,7,8</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"移除所有中括号-包括其内容\"><a href=\"#移除所有中括号-包括其内容\" class=\"headerlink\" title=\"移除所有中括号,包括其内容\"></a>移除所有中括号,包括其内容</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">&#x27;[1,2,3,4,5,6,7,8]&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> newStr = str.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\[.*?\\]/g</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newStr) <span class=\"comment\">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"正则表达式符号释义\"><a href=\"#正则表达式符号释义\" class=\"headerlink\" title=\"正则表达式符号释义\"></a>正则表达式符号释义</h3><ul>\n<li><p>“&quot;：将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”；</p>\n</li>\n<li><p>“|”：或的意思；</p>\n</li>\n<li><p>“&#x2F;g”：全局搜索。由于此处要去除字符串中所有中括号，因此正则中要开启全局搜索；</p>\n</li>\n<li><p>“.”：表示除换行符和其他 Unicode 行终止符之外的任意字符；</p>\n</li>\n<li><p>“<em>“：匹配前面的子表达式零次或多次。例如，zo</em>能匹配“z”以及“zoo”。*等价于{0,}；</p>\n</li>\n<li><p>“?”：匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。（贪婪模式）</p>\n</li>\n</ul>"},{"title":"【Echarts使用】之 图例选中状态","date":"2022-03-10T03:38:52.203Z","_content":"\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","source":"_posts/Echarts/echarts图例--选中状态（默认不显示置灰）.md","raw":"---\ntitle: 【Echarts使用】之 图例选中状态\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, legend]\n---\n\n图例选中状态表。\n\n```\nlegend:{\n    selected: {\n        // 选中'系列1'\n        '系列1': true,\n        // 不选中'系列2'\n        '系列2': false\n    }\n}\n```\n\n使用\n\n```\nlegend: {\n    show: true,\n    selected: {\n      '1星': true, '2星': true, '3星': true, '4星': false, '5星': false\n    },\n    bottom: 0\n},\n```\n","slug":"Echarts/echarts图例--选中状态（默认不显示置灰）","published":1,"updated":"2023-08-13T12:01:58.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwa0007m32vfoid4330","content":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>图例选中状态表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend:&#123;</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">        // 选中&#x27;系列1&#x27;</span><br><span class=\"line\">        &#x27;系列1&#x27;: true,</span><br><span class=\"line\">        // 不选中&#x27;系列2&#x27;</span><br><span class=\"line\">        &#x27;系列2&#x27;: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend: &#123;</span><br><span class=\"line\">    show: true,</span><br><span class=\"line\">    selected: &#123;</span><br><span class=\"line\">      &#x27;1星&#x27;: true, &#x27;2星&#x27;: true, &#x27;3星&#x27;: true, &#x27;4星&#x27;: false, &#x27;5星&#x27;: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bottom: 0</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之基准线markLine","date":"2022-03-10T03:38:35.048Z","_content":"\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","source":"_posts/Echarts/echarts--基准线markLine.md","raw":"---\ntitle: 【Echarts使用】之基准线markLine\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, markLine]\n---\n\n### 设置了两条基准线\n\n```\nmarkLine: {\n    symbol: \"none\",\n    data: [{\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.rs'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#714EB3\"\n        },\n        yAxis: 10\n    },\n    {\n        label: {\n            width: \"30\",\n            position: 'start',\n            formatter: t('sleepManage_cycle.sameChart.qc'),\n            fontSize: '10',\n            color: '#86899D',\n            overflow: 'break',\n        },\n        silent: false,\n        lineStyle: {\n            type: \"dashed\",\n            color: \"#3F6293\"\n        },\n        yAxis: 1\n    }]\n},\n```\n\n### 关键参数\n\n> `yAxis`:基准线的坐标\n\n> `overflow`:  \n> 'truncate' 截断，并在末尾显示 ellipsis 配置的文本，默认为...  \n> 'break' 换行  \n> 'breakAll' 换行，跟'break'不同的是，在英语等拉丁文中，'breakAll'还会强制单词内换行\n\n> `ellipsis`:在 overflow 配置为'truncate'的时候，可以通过该属性配置末尾显示的文本。\n","slug":"Echarts/echarts--基准线markLine","published":1,"updated":"2023-08-13T11:59:03.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwa0009m32vcf4pbwmd","content":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"设置了两条基准线\"><a href=\"#设置了两条基准线\" class=\"headerlink\" title=\"设置了两条基准线\"></a>设置了两条基准线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLine: &#123;</span><br><span class=\"line\">    symbol: &quot;none&quot;,</span><br><span class=\"line\">    data: [&#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.rs&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#714EB3&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 10</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        label: &#123;</span><br><span class=\"line\">            width: &quot;30&quot;,</span><br><span class=\"line\">            position: &#x27;start&#x27;,</span><br><span class=\"line\">            formatter: t(&#x27;sleepManage_cycle.sameChart.qc&#x27;),</span><br><span class=\"line\">            fontSize: &#x27;10&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;,</span><br><span class=\"line\">            overflow: &#x27;break&#x27;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        silent: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &quot;dashed&quot;,</span><br><span class=\"line\">            color: &quot;#3F6293&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        yAxis: 1</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><blockquote>\n<p><code>yAxis</code>:基准线的坐标</p>\n</blockquote>\n<blockquote>\n<p><code>overflow</code>:<br>‘truncate’ 截断，并在末尾显示 ellipsis 配置的文本，默认为…<br>‘break’ 换行<br>‘breakAll’ 换行，跟’break’不同的是，在英语等拉丁文中，’breakAll’还会强制单词内换行</p>\n</blockquote>\n<blockquote>\n<p><code>ellipsis</code>:在 overflow 配置为’truncate’的时候，可以通过该属性配置末尾显示的文本。</p>\n</blockquote>\n"},{"title":"【Echarts使用】之 设置柱子borderRadius","date":"2022-03-10T03:38:56.351Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts圆柱--设置柱子的borderRadius.md","raw":"---\ntitle: 【Echarts使用】之 设置柱子borderRadius\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, borderRadius]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderColor: bgColor,\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: bgColor\n        },\n        emphasis: {\n            itemStyle: {\n                borderColor: bgColor,\n                color: bgColor\n            }\n        },\n    }\n]\n```\n","slug":"Echarts/echarts圆柱--设置柱子的borderRadius","published":1,"updated":"2023-08-13T12:02:48.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwb000am32v2b3taob7","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderColor: bgColor,</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: bgColor</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        emphasis: &#123;</span><br><span class=\"line\">            itemStyle: &#123;</span><br><span class=\"line\">                borderColor: bgColor,</span><br><span class=\"line\">                color: bgColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无拐点","date":"2022-03-10T03:39:04.601Z","_content":"\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","source":"_posts/Echarts/echarts折线图--无拐点，折线样式.md","raw":"---\ntitle: 【Echarts使用】之 无拐点\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbolSize]\n---\n\n### 无拐点\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      smooth: true, //关键点，为true是不支持虚线的，实线就用true\n      symbolSize:0,   // 折线拐点圆的大小\n\n    }\n]\n```\n\n### 折线线型\n\n```\nseries: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      lineStyle:{\n\n                  width:2,\n                  type:'dotted'  //'dotted'虚线 'solid'实线 'dashed'虚线\n\n\n      }\n    }\n]\n\n```\n","slug":"Echarts/echarts折线图--无拐点，折线样式","published":1,"updated":"2023-08-13T12:03:39.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwc000dm32vfv527vp1","content":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"无拐点\"><a href=\"#无拐点\" class=\"headerlink\" title=\"无拐点\"></a>无拐点</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      smooth: true, //关键点，为true是不支持虚线的，实线就用true</span><br><span class=\"line\">      symbolSize:0,   // 折线拐点圆的大小</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"折线线型\"><a href=\"#折线线型\" class=\"headerlink\" title=\"折线线型\"></a>折线线型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      data: [820, 932, 901, 934, 1290, 1330, 1320],</span><br><span class=\"line\">      type: &#x27;line&#x27;,</span><br><span class=\"line\">      lineStyle:&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  width:2,</span><br><span class=\"line\">                  type:&#x27;dotted&#x27;  //&#x27;dotted&#x27;虚线 &#x27;solid&#x27;实线 &#x27;dashed&#x27;虚线</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 无数据是连线","date":"2022-03-10T03:38:59.886Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts折线--无数据时连线与否.md","raw":"---\ntitle: 【Echarts使用】之 无数据是连线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, connectNulls]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echarts折线--无数据时连线与否","published":1,"updated":"2023-08-13T12:03:19.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwc000em32v3xofc0lb","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置柱状图渐进式","date":"2022-03-10T03:39:08.919Z","_content":"\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echarts柱形--设置柱子多个颜色（渐进色）.md","raw":"---\ntitle: 【Echarts使用】之 设置柱状图渐进式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, itemStyle]\n---\n\n```\nseries:[\n    {\n        type: 'bar',\n        stack: 'Total',\n        itemStyle: {\n            borderRadius: [4, 4, 4, 4], // 圆柱\n            color: function (params) {\n                //首先定义一个数组\n                const colorList = [\n                    {\n                        x: 0,\n                        y: 1,\n                        x2: 0,\n                        y2: 0,\n                        colorStops: [{\n                            offset: 0, color: '#3BABFF' // 0% 处的颜色\n                        }, {\n                            offset: 1, color: '#7548FF' // 100% 处的颜色\n                        }],\n                        global: false // 缺省为 false\n                    }, \"#514FA4\", \"#373948\"];\n                if (params.data.type == \"达标\") {\n                    return colorList[0]\n                } else if (params.data.type == \"未达标\") {\n                    return colorList[1]\n                } else {\n                    return colorList[2]\n                }\n            },\n        },\n    }\n]\n```\n","slug":"Echarts/echarts柱形--设置柱子多个颜色（渐进色）","published":1,"updated":"2023-08-13T12:04:11.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwd000im32vftbg0gdv","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;bar&#x27;,</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            borderRadius: [4, 4, 4, 4], // 圆柱</span><br><span class=\"line\">            color: function (params) &#123;</span><br><span class=\"line\">                //首先定义一个数组</span><br><span class=\"line\">                const colorList = [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        x: 0,</span><br><span class=\"line\">                        y: 1,</span><br><span class=\"line\">                        x2: 0,</span><br><span class=\"line\">                        y2: 0,</span><br><span class=\"line\">                        colorStops: [&#123;</span><br><span class=\"line\">                            offset: 0, color: &#x27;#3BABFF&#x27; // 0% 处的颜色</span><br><span class=\"line\">                        &#125;, &#123;</span><br><span class=\"line\">                            offset: 1, color: &#x27;#7548FF&#x27; // 100% 处的颜色</span><br><span class=\"line\">                        &#125;],</span><br><span class=\"line\">                        global: false // 缺省为 false</span><br><span class=\"line\">                    &#125;, &quot;#514FA4&quot;, &quot;#373948&quot;];</span><br><span class=\"line\">                if (params.data.type == &quot;达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[0]</span><br><span class=\"line\">                &#125; else if (params.data.type == &quot;未达标&quot;) &#123;</span><br><span class=\"line\">                    return colorList[1]</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return colorList[2]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 拐点圆样式","date":"2022-03-10T03:39:13.518Z","_content":"\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","source":"_posts/Echarts/echats折线--拐点圆的样式（内圆外圆）.md","raw":"---\ntitle: 【Echarts使用】之 拐点圆样式\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, symbol]\n---\n\n```\nseries:[\n    {\n        type: 'line',\n        connectNulls: true,//无数据是是否连线\n        stack: 'Total',\n        symbol: 'circle', //拐点样式\n        symbolSize: 4, //拐点圆大小\n        itemStyle: {\n            color: '#292B37', //拐点内圆颜色\n            borderColor: '#5B5E74', //拐点外圆颜色\n            width: 2, //拐点内圆大小\n        },\n    }\n]\n```\n","slug":"Echarts/echats折线--拐点圆的样式（内圆外圆）","published":1,"updated":"2023-08-13T12:05:01.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwe000km32v8ewddogt","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">series:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: &#x27;line&#x27;,</span><br><span class=\"line\">        connectNulls: true,//无数据是是否连线</span><br><span class=\"line\">        stack: &#x27;Total&#x27;,</span><br><span class=\"line\">        symbol: &#x27;circle&#x27;, //拐点样式</span><br><span class=\"line\">        symbolSize: 4, //拐点圆大小</span><br><span class=\"line\">        itemStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#292B37&#x27;, //拐点内圆颜色</span><br><span class=\"line\">            borderColor: &#x27;#5B5E74&#x27;, //拐点外圆颜色</span><br><span class=\"line\">            width: 2, //拐点内圆大小</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n"},{"title":"【Echarts使用】之 设置从原点开始","date":"2022-03-10T03:38:44.099Z","_content":"\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","source":"_posts/Echarts/echarts设置从原点开始.md","raw":"---\ntitle: 【Echarts使用】之 设置从原点开始\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, boundaryGap]\n---\n\n```\nxAxis:{\n    boundaryGap: false, // 不留白，从原点开始\n}\n```\n","slug":"Echarts/echarts设置从原点开始","published":1,"updated":"2023-08-13T12:01:14.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwf000om32v6ytjfw9y","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xAxis:&#123;</span><br><span class=\"line\">    boundaryGap: false, // 不留白，从原点开始</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"【浏览器】之同源策略","date":"2023-08-13T06:34:46.171Z","_content":"\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","source":"_posts/浏览器/ 【浏览器】之同源策略.md","raw":"---\ntitle: 【浏览器】之同源策略\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 同源策略]\n---\n\n# 什么是浏览器同源策略?\n\n**同源**：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。  \n这两个 URL 是同源的\n\n```javascript\nhttps://time.geekbang.org/?category=1\nhttps://time.geekbang.org/?category=0\n```\n\n> **源：就是协议、域名和端口号。**\n>\n> 同源策略：**SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定**，是浏览器最核心、最基本的安全功能，**若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击**。**所谓同源是指\"协议+域名+端口\"三者相同，若两个 URL 的协议、域名、端口号都相同**，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的\n\n非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）\n\n具体来讲，同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。\n\n- 第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。\n\n- 第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。\n\n- 第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。\n\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。\n\n# 安全与便利\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n同源策略将限制以下几种行为：\n\n（1）Cookie、LocalStorage 和 IndexDB 无法读取\n\n（2）DOM 和 Js 对象无法获得\n\n（3）AJAX 请求不能发送\n\n以下两种不受同源策略的限制：\n\n（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制\n\n（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的`<script src=\"...\"></script>，<img>，<link>，<iframe>`等\n\n注意：\n\n同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制\n\n**1. 页面中可以嵌入第三方资源**\n\n**2. 跨域资源共享和跨文档消息机制**\n\n# 总结\n\n同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。\n\n不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：\n\n**页面中可以引用第三方资源**，不过这也暴露了很多诸如 **XSS 的安全问题**，因此又在这种开放的基础之上引入了 **CSP** 来限制其自由程度。 **使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的**，因此浏览器又在这种严格策略的基础之上引入了**跨域资源共享策略（CORS）**，让其可以安全地进行跨域操作。 **两个不同源的 DOM 是不能相互操纵的**，因此，浏览器中又实现了**跨文档消息机制（window.postMessage）**，让其可以比较安全地通信\n\n**原文地址**：[【浏览器】之 同源策略](https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md)\n","slug":"浏览器/ 【浏览器】之同源策略","published":1,"updated":"2023-08-13T07:17:18.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwf000qm32v5jitbynh","content":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"什么是浏览器同源策略\"><a href=\"#什么是浏览器同源策略\" class=\"headerlink\" title=\"什么是浏览器同源策略?\"></a>什么是浏览器同源策略?</h1><p><strong>同源</strong>：如果两个 URL 的协议、域名（主机名）和端口都相同，我们就称这两个 URL 同源。<br>这两个 URL 是同源的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=1</span></span><br><span class=\"line\"><span class=\"attr\">https</span>:<span class=\"comment\">//time.geekbang.org/?category=0</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>源：就是协议、域名和端口号。</strong></p>\n<p>同源策略：<strong>SOP（Same origin policy）是由 Netscape 公司 1995 年引入浏览器的一种约定</strong>，是浏览器最核心、最基本的安全功能，<strong>若缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击</strong>。<strong>所谓同源是指”协议+域名+端口”三者相同，若两个 URL 的协议、域名、端口号都相同</strong>，则两者为同源，有一个不同则非同源，即便两个不同的域名指向同一个 ip 地址，也是非同源的</p>\n</blockquote>\n<p>非同源的 URL 在没有明确授权的情况下，不能读写对方资源（不能相互通信）</p>\n<p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p>\n<ul>\n<li><p>第一个，DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>\n</li>\n<li><p>第二个，数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。你可以自己试一下，这里我们就不做演示了。</p>\n</li>\n<li><p>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。你还记得在《17 | WebAPI：XMLHttpRequest 是怎么实现的？》这篇文章的末尾分析的 XMLHttpRequest 在使用过程中所遇到的坑吗？其中第一个坑就是在默认情况下不能访问跨域的资源。</p>\n</li>\n</ul>\n<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>\n<h1 id=\"安全与便利\"><a href=\"#安全与便利\" class=\"headerlink\" title=\"安全与便利\"></a>安全与便利</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>同源策略将限制以下几种行为：</p>\n<p>（1）Cookie、LocalStorage 和 IndexDB 无法读取</p>\n<p>（2）DOM 和 Js 对象无法获得</p>\n<p>（3）AJAX 请求不能发送</p>\n<p>以下两种不受同源策略的限制：</p>\n<p>（1）页面中的链接，重定向以及表单提交是不会受到同源策略限制</p>\n<p>（2）跨域资源的引入，但是 js 不能读写加载的内容，如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;</code>等</p>\n<p>注意：</p>\n<p>同源策略是浏览器做的限制，对服务器与服务器之间的通信不做限制</p>\n<p><strong>1. 页面中可以嵌入第三方资源</strong></p>\n<p><strong>2. 跨域资源共享和跨文档消息机制</strong></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>\n<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>\n<p><strong>页面中可以引用第三方资源</strong>，不过这也暴露了很多诸如 <strong>XSS 的安全问题</strong>，因此又在这种开放的基础之上引入了 <strong>CSP</strong> 来限制其自由程度。 <strong>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的</strong>，因此浏览器又在这种严格策略的基础之上引入了<strong>跨域资源共享策略（CORS）</strong>，让其可以安全地进行跨域操作。 <strong>两个不同源的 DOM 是不能相互操纵的</strong>，因此，浏览器中又实现了<strong>跨文档消息机制（window.postMessage）</strong>，让其可以比较安全地通信</p>\n<p><strong>原文地址</strong>：<a href=\"https://github.com/yihan12/Blog/blob/main/browser/Same-Origin%20Policy.md\">【浏览器】之 同源策略</a></p>\n"},{"title":"【浏览器】之渲染机制","date":"2023-09-07T01:27:30.366Z","_content":"\n### 浏览器渲染机制\n\n首先，浏览器的渲染机制中有几个基本概念名称：\n\n（1）、DOM：浏览器将 HTML 解析成树形的数据结构\n\n（2）、CSSOM：浏览器将 CSS 解析成树形的数据结构\n\n（3）、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree（渲染树）\n\n（4）、Layout：计算出 Render Tree 每个节点的具\\*\\*\\*置\n\n（5）、Painting：通过显卡，将 Layout 后的节点内容分别呈现到屏幕上\n\n浏览器整个渲染流程如下：\n\n（1）、用户输入一个 URL 后，浏览器就会向服务器发出一个请求，请求 URL 对应的资源\n\n（2）、接到服务器的响应内容后，浏览器的 HTML 解析器，会将 HTML 文件解析成一颗 DOM 树，DOM 树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点\n\n（3）、将 CSS 解析成 CSSOM 树\n\n（4）、根据 DOM 树与 CSSOM 树，构建 Render Tree\n\n（5）、浏览器会根据 Render Tree 能知道网页中哪些有节点，各个节点的 CSS，以及各个节点的从属关系\n\n（6）、计算出每个节点在屏幕中的位置后，最后一步就是 Painting，根据计算出的规则，把内容画到屏幕上\n\n注意：\n\n浏览器在获得 HTML 文件后，是自上而下的加载，并在加载过程中进行解析与渲染\n\n加载过程中：\n\n遇到外部 CSS 文件和图片等静态资源时，浏览器会另外发送一个异步请求\n\n遇到 js 文件时，HTML 文件会挂起渲染的进程，等待 js 文件加载完毕后，再继续进行渲染，因为 js 可能会修改 DOM，导致后续 HTML 资源白白加载，这也是为什么建议将 js 文件写在底部 body 标签前\n\n### 请问你了解什么是重绘？什么是回流？两者有何区别？\n\n**重绘：**\n\n更换某个元素颜色，这样的行为是不影响页面布局，DOM 树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染\n\n常见情况：\n\n（1）、回流必定引发重绘，但重绘也会单独触发\n\n（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）\n\n**回流：**\n\n增删 DOM 节点，或修改一个元素的宽高，页面布局发生变化，DOM 树结构发生变化，需要重新构建 DOM 树，而 DOM 树与渲染树是紧密相连的，DOM 树构建完，渲染树也会随之对页面进行再次渲染\n\n常见情况：\n\n（1）、页面渲染初始化\n\n（2）、DOM 树变化（添加或者删除可见的 DOM 元素、元素位置改变）\n\n（3）、Render 树变化（元素尺寸改变：边距、填充、边框、宽度和高度）\n\n（4）、浏览器窗口尺寸改变，resize 事件发生\n\n（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；\n\n（6）、查询布局信息，包括 offestLeft/Top/Width/Height、scrollLeft/Top/Width/Height、clientLeft/Top/Width/Height、浏览为了返回最新值，会触发回流\n\n### 请问在浏览器中输入 URL 后，浏览器会做哪些工作？\n\n从输入 URL 到渲染出整个页面包括三个部分：\n\n**（1）、DNS 解析 URL**\n\nDNS 解析就是寻找哪个服务器上有请求的资源，因为 ip 地址不易记忆，一般会使用 URL 域名（如www.baidu.com）作为网址，DNS解析就是将域名“翻译”成IP地址\n\n具体过程：\n\na、浏览器缓存：浏览器会按照一定的频率，缓存 DNS 记录\n\nb、操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会取操作系统中找\n\nc、路由缓存：路由器也有 DNS 缓存\n\nd、ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求\n\ne、根服务器：ISP 的 DNS 服务器找不到，就要向根服务器发出请求，进行递归查询\n\n**（2）、浏览器发送请求与服务器交互**\n\na、浏览器利用 tcp 协议通过三次握手与服务器建立连接\n\nhttp 请求包括 header 和 body，header 中包括请求的方式（get 和 post）、请求的协议 （http、https、ftp）、请求的地址 ip、缓存 cookie，body 中有请求的内容\n\nb、浏览器根据解析到的 IP 地址和端口号发起 http 的 get 请求\n\nc、服务器接收到 http 请求之后，开始搜索 html 页面，并使用 http 返回响应报文\n\nd、若状态码为 200 显示响应成功，浏览器接收到返回的 HTML 页面后，开始渲染页面\n\n**（3）、浏览器对接收到的 HTML 页面进行渲染**\n\na、浏览器根据深度遍历的方式把 HTML 节点遍历成 DOM 树\n\nb、将 CSS 解析成 CSSOM 树\n\nc、将 DOM 树和 CSSOM 树构造成 Render 树\n\nd、根据 Render 树计算所有节点在屏幕中的位置，进行布局（回流）\n\ne、遍历 Render 树并调用硬件 API 绘制所有节点（重绘）\n\n### 所以以下几个动作可能会导致性能问题：\n\n- 改变 window 大小\n- 改变字体\n- 添加或删除样式\n- 文字改变\n- 定位或者浮动\n- 盒模型\n\n### 渲染\n\n当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：\n\n- PARSE：解析 HTML，构建 DOM 树。\n\n  > Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。\n  > Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如<html>, <body>）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。\n  > DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。\n\n- STYLE：为每个节点计算最终的有效样式（CSS-CSSOM）。\n\n  > 收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。\n  > 访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。\n  > 结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。\n\n- LAYOUT：为每个节点计算位置和大小等布局信息。\n\n  > Layout 树和 DOM 树不一定是一一对应的，为了构建 Layout 树，浏览器主要完成了下列工作：从 DOM 树的根节点开始遍历每个可见节点。某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。为伪元素创建 LayoutObject。为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。\n\n- PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。\n\n  > DOM 树的 Document 节点对应的 RenderView 节点。DOM 树中 Document 节点的子节点，也就是 HTML 节点对应的 RenderBlock 节点。显式指定 CSS 位置的节点（position 为 absolute 或者 fixed）。具有透明效果的节点。具有 CSS 3D 属性的节点。使用 Canvas 元素或者 Video 元素的节点。浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。\n\n- COMPOSITE & RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。\n\n### 次级资源加载\n\n一个网页通常会使用多个外部资源，如图片、JavaScript、CSS、字体等。主线程在解析 DOM 的过程中遇到这些资源后会一一请求。为了加速渲染流程，会有一个叫做预加载扫描器（preload scanner）线程并发运行。如果 HTML 中存在 img 或 link 之类的内容，则预加载扫描器会查看 HTML parser 生成的标记，并发送请求到浏览器进程的网络线程获取这些资源。\n\n### JavaScript 可能阻塞解析\n\n当 HTML 解析器发现 script 标签时，会暂停 HTML 的解析，转而开始加载、解析和执行 JavaScript。因为 JS 可能会改变 DOM 的结构。如果不想因 JS 阻塞 HTML 的解析，可以为 script 标签添加 defer 属性或将 script 放在 body 结束标签之前，浏览器会在最后执行 JS 代码，避免阻塞 DOM 构建。\n\n### CSSOM\n\nCSSOM 和 DOM 是并行构建的，构建 CSSOM 不会阻塞 DOM 的构建。但 CSSOM 会阻塞 JS 的执行，因为 JS 可能会操作样式信息。虽然 CSSOM 不会阻塞 DOM 的构建，但在进入下一阶段之前，必须等待 CSSOM 构建完成。这也是通常所说的 CSSOM 会阻塞渲染。\n\n### 浏览器渲染性能的优化\n\n上一节中是一轮典型的浏览器渲染流程，在流程完成之后，DOM、CSSOM、LayoutObject、PaintLayer 等各种树状数据结构都会保留下来，以便在用户操作、网络请求、JS 执行等事件发生时，重新触发渲染流程。\n\n#### 2.1 减少渲染中的重排重绘\n\n> 使用合适的网页分层技术：如使用多层 canvas，将动画背景，运动主体，次要物体分层，这样每一帧需要变化的就只是一个或部分合成层，而不是整个页面。\n> 使用 CSS Transforms 和 Animations：它可以让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果，而不需要重新计算布局，重新绘制图形。CSS Triggers 中仅触发 Composite 的属性就是最优的选择。\n\n#### 2.2 优化影响渲染的资源在浏览器解析\n\nHTML 的过程中，CSS 和 JS 都有可能对页面的渲染造成影响。\n\n> 优化方法包括以下几点：\n> 关键 CSS 资源放在头部加载。\n> JS 通常放在页面底部。\n> 为 JS 添加 async 和 defer 属性。\n> body 中尽量不要出现 CSS 和 JS。\n> 为 img 指定宽高，避免图像加载完成后触发重排。\n> 避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。\n\n### CSSOM\n\n像 <head> 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。\n\n每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。\n\n### 第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\n\n### 总结\n\n综上所述，我们得出这样的结论：\n\n浏览器工作流程：构建 DOM -> 构建 CSSOM -> 构建渲染树 -> 布局 -> 绘制。  \nCSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。  \n**通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。**  \n（）\n","source":"_posts/浏览器/【浏览器】之渲染机制.md","raw":"---\ntitle: 【浏览器】之渲染机制\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 渲染机制]\n---\n\n### 浏览器渲染机制\n\n首先，浏览器的渲染机制中有几个基本概念名称：\n\n（1）、DOM：浏览器将 HTML 解析成树形的数据结构\n\n（2）、CSSOM：浏览器将 CSS 解析成树形的数据结构\n\n（3）、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree（渲染树）\n\n（4）、Layout：计算出 Render Tree 每个节点的具\\*\\*\\*置\n\n（5）、Painting：通过显卡，将 Layout 后的节点内容分别呈现到屏幕上\n\n浏览器整个渲染流程如下：\n\n（1）、用户输入一个 URL 后，浏览器就会向服务器发出一个请求，请求 URL 对应的资源\n\n（2）、接到服务器的响应内容后，浏览器的 HTML 解析器，会将 HTML 文件解析成一颗 DOM 树，DOM 树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点\n\n（3）、将 CSS 解析成 CSSOM 树\n\n（4）、根据 DOM 树与 CSSOM 树，构建 Render Tree\n\n（5）、浏览器会根据 Render Tree 能知道网页中哪些有节点，各个节点的 CSS，以及各个节点的从属关系\n\n（6）、计算出每个节点在屏幕中的位置后，最后一步就是 Painting，根据计算出的规则，把内容画到屏幕上\n\n注意：\n\n浏览器在获得 HTML 文件后，是自上而下的加载，并在加载过程中进行解析与渲染\n\n加载过程中：\n\n遇到外部 CSS 文件和图片等静态资源时，浏览器会另外发送一个异步请求\n\n遇到 js 文件时，HTML 文件会挂起渲染的进程，等待 js 文件加载完毕后，再继续进行渲染，因为 js 可能会修改 DOM，导致后续 HTML 资源白白加载，这也是为什么建议将 js 文件写在底部 body 标签前\n\n### 请问你了解什么是重绘？什么是回流？两者有何区别？\n\n**重绘：**\n\n更换某个元素颜色，这样的行为是不影响页面布局，DOM 树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染\n\n常见情况：\n\n（1）、回流必定引发重绘，但重绘也会单独触发\n\n（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）\n\n**回流：**\n\n增删 DOM 节点，或修改一个元素的宽高，页面布局发生变化，DOM 树结构发生变化，需要重新构建 DOM 树，而 DOM 树与渲染树是紧密相连的，DOM 树构建完，渲染树也会随之对页面进行再次渲染\n\n常见情况：\n\n（1）、页面渲染初始化\n\n（2）、DOM 树变化（添加或者删除可见的 DOM 元素、元素位置改变）\n\n（3）、Render 树变化（元素尺寸改变：边距、填充、边框、宽度和高度）\n\n（4）、浏览器窗口尺寸改变，resize 事件发生\n\n（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；\n\n（6）、查询布局信息，包括 offestLeft/Top/Width/Height、scrollLeft/Top/Width/Height、clientLeft/Top/Width/Height、浏览为了返回最新值，会触发回流\n\n### 请问在浏览器中输入 URL 后，浏览器会做哪些工作？\n\n从输入 URL 到渲染出整个页面包括三个部分：\n\n**（1）、DNS 解析 URL**\n\nDNS 解析就是寻找哪个服务器上有请求的资源，因为 ip 地址不易记忆，一般会使用 URL 域名（如www.baidu.com）作为网址，DNS解析就是将域名“翻译”成IP地址\n\n具体过程：\n\na、浏览器缓存：浏览器会按照一定的频率，缓存 DNS 记录\n\nb、操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会取操作系统中找\n\nc、路由缓存：路由器也有 DNS 缓存\n\nd、ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求\n\ne、根服务器：ISP 的 DNS 服务器找不到，就要向根服务器发出请求，进行递归查询\n\n**（2）、浏览器发送请求与服务器交互**\n\na、浏览器利用 tcp 协议通过三次握手与服务器建立连接\n\nhttp 请求包括 header 和 body，header 中包括请求的方式（get 和 post）、请求的协议 （http、https、ftp）、请求的地址 ip、缓存 cookie，body 中有请求的内容\n\nb、浏览器根据解析到的 IP 地址和端口号发起 http 的 get 请求\n\nc、服务器接收到 http 请求之后，开始搜索 html 页面，并使用 http 返回响应报文\n\nd、若状态码为 200 显示响应成功，浏览器接收到返回的 HTML 页面后，开始渲染页面\n\n**（3）、浏览器对接收到的 HTML 页面进行渲染**\n\na、浏览器根据深度遍历的方式把 HTML 节点遍历成 DOM 树\n\nb、将 CSS 解析成 CSSOM 树\n\nc、将 DOM 树和 CSSOM 树构造成 Render 树\n\nd、根据 Render 树计算所有节点在屏幕中的位置，进行布局（回流）\n\ne、遍历 Render 树并调用硬件 API 绘制所有节点（重绘）\n\n### 所以以下几个动作可能会导致性能问题：\n\n- 改变 window 大小\n- 改变字体\n- 添加或删除样式\n- 文字改变\n- 定位或者浮动\n- 盒模型\n\n### 渲染\n\n当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：\n\n- PARSE：解析 HTML，构建 DOM 树。\n\n  > Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。\n  > Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如<html>, <body>）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。\n  > DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。\n\n- STYLE：为每个节点计算最终的有效样式（CSS-CSSOM）。\n\n  > 收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。\n  > 访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。\n  > 结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。\n\n- LAYOUT：为每个节点计算位置和大小等布局信息。\n\n  > Layout 树和 DOM 树不一定是一一对应的，为了构建 Layout 树，浏览器主要完成了下列工作：从 DOM 树的根节点开始遍历每个可见节点。某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。为伪元素创建 LayoutObject。为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。\n\n- PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。\n\n  > DOM 树的 Document 节点对应的 RenderView 节点。DOM 树中 Document 节点的子节点，也就是 HTML 节点对应的 RenderBlock 节点。显式指定 CSS 位置的节点（position 为 absolute 或者 fixed）。具有透明效果的节点。具有 CSS 3D 属性的节点。使用 Canvas 元素或者 Video 元素的节点。浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。\n\n- COMPOSITE & RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。\n\n### 次级资源加载\n\n一个网页通常会使用多个外部资源，如图片、JavaScript、CSS、字体等。主线程在解析 DOM 的过程中遇到这些资源后会一一请求。为了加速渲染流程，会有一个叫做预加载扫描器（preload scanner）线程并发运行。如果 HTML 中存在 img 或 link 之类的内容，则预加载扫描器会查看 HTML parser 生成的标记，并发送请求到浏览器进程的网络线程获取这些资源。\n\n### JavaScript 可能阻塞解析\n\n当 HTML 解析器发现 script 标签时，会暂停 HTML 的解析，转而开始加载、解析和执行 JavaScript。因为 JS 可能会改变 DOM 的结构。如果不想因 JS 阻塞 HTML 的解析，可以为 script 标签添加 defer 属性或将 script 放在 body 结束标签之前，浏览器会在最后执行 JS 代码，避免阻塞 DOM 构建。\n\n### CSSOM\n\nCSSOM 和 DOM 是并行构建的，构建 CSSOM 不会阻塞 DOM 的构建。但 CSSOM 会阻塞 JS 的执行，因为 JS 可能会操作样式信息。虽然 CSSOM 不会阻塞 DOM 的构建，但在进入下一阶段之前，必须等待 CSSOM 构建完成。这也是通常所说的 CSSOM 会阻塞渲染。\n\n### 浏览器渲染性能的优化\n\n上一节中是一轮典型的浏览器渲染流程，在流程完成之后，DOM、CSSOM、LayoutObject、PaintLayer 等各种树状数据结构都会保留下来，以便在用户操作、网络请求、JS 执行等事件发生时，重新触发渲染流程。\n\n#### 2.1 减少渲染中的重排重绘\n\n> 使用合适的网页分层技术：如使用多层 canvas，将动画背景，运动主体，次要物体分层，这样每一帧需要变化的就只是一个或部分合成层，而不是整个页面。\n> 使用 CSS Transforms 和 Animations：它可以让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果，而不需要重新计算布局，重新绘制图形。CSS Triggers 中仅触发 Composite 的属性就是最优的选择。\n\n#### 2.2 优化影响渲染的资源在浏览器解析\n\nHTML 的过程中，CSS 和 JS 都有可能对页面的渲染造成影响。\n\n> 优化方法包括以下几点：\n> 关键 CSS 资源放在头部加载。\n> JS 通常放在页面底部。\n> 为 JS 添加 async 和 defer 属性。\n> body 中尽量不要出现 CSS 和 JS。\n> 为 img 指定宽高，避免图像加载完成后触发重排。\n> 避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。\n\n### CSSOM\n\n像 <head> 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。\n\n每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。\n\n### 第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\n\n### 总结\n\n综上所述，我们得出这样的结论：\n\n浏览器工作流程：构建 DOM -> 构建 CSSOM -> 构建渲染树 -> 布局 -> 绘制。  \nCSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。  \n**通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。**  \n（）\n","slug":"浏览器/【浏览器】之渲染机制","published":1,"updated":"2023-09-07T01:28:04.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwg000um32vd0n75jif","content":"<h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p>首先，浏览器的渲染机制中有几个基本概念名称：</p>\n<p>（1）、DOM：浏览器将 HTML 解析成树形的数据结构</p>\n<p>（2）、CSSOM：浏览器将 CSS 解析成树形的数据结构</p>\n<p>（3）、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree（渲染树）</p>\n<p>（4）、Layout：计算出 Render Tree 每个节点的具***置</p>\n<p>（5）、Painting：通过显卡，将 Layout 后的节点内容分别呈现到屏幕上</p>\n<p>浏览器整个渲染流程如下：</p>\n<p>（1）、用户输入一个 URL 后，浏览器就会向服务器发出一个请求，请求 URL 对应的资源</p>\n<p>（2）、接到服务器的响应内容后，浏览器的 HTML 解析器，会将 HTML 文件解析成一颗 DOM 树，DOM 树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点</p>\n<p>（3）、将 CSS 解析成 CSSOM 树</p>\n<p>（4）、根据 DOM 树与 CSSOM 树，构建 Render Tree</p>\n<p>（5）、浏览器会根据 Render Tree 能知道网页中哪些有节点，各个节点的 CSS，以及各个节点的从属关系</p>\n<p>（6）、计算出每个节点在屏幕中的位置后，最后一步就是 Painting，根据计算出的规则，把内容画到屏幕上</p>\n<p>注意：</p>\n<p>浏览器在获得 HTML 文件后，是自上而下的加载，并在加载过程中进行解析与渲染</p>\n<p>加载过程中：</p>\n<p>遇到外部 CSS 文件和图片等静态资源时，浏览器会另外发送一个异步请求</p>\n<p>遇到 js 文件时，HTML 文件会挂起渲染的进程，等待 js 文件加载完毕后，再继续进行渲染，因为 js 可能会修改 DOM，导致后续 HTML 资源白白加载，这也是为什么建议将 js 文件写在底部 body 标签前</p>\n<h3 id=\"请问你了解什么是重绘？什么是回流？两者有何区别？\"><a href=\"#请问你了解什么是重绘？什么是回流？两者有何区别？\" class=\"headerlink\" title=\"请问你了解什么是重绘？什么是回流？两者有何区别？\"></a>请问你了解什么是重绘？什么是回流？两者有何区别？</h3><p><strong>重绘：</strong></p>\n<p>更换某个元素颜色，这样的行为是不影响页面布局，DOM 树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染</p>\n<p>常见情况：</p>\n<p>（1）、回流必定引发重绘，但重绘也会单独触发</p>\n<p>（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）</p>\n<p><strong>回流：</strong></p>\n<p>增删 DOM 节点，或修改一个元素的宽高，页面布局发生变化，DOM 树结构发生变化，需要重新构建 DOM 树，而 DOM 树与渲染树是紧密相连的，DOM 树构建完，渲染树也会随之对页面进行再次渲染</p>\n<p>常见情况：</p>\n<p>（1）、页面渲染初始化</p>\n<p>（2）、DOM 树变化（添加或者删除可见的 DOM 元素、元素位置改变）</p>\n<p>（3）、Render 树变化（元素尺寸改变：边距、填充、边框、宽度和高度）</p>\n<p>（4）、浏览器窗口尺寸改变，resize 事件发生</p>\n<p>（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>\n<p>（6）、查询布局信息，包括 offestLeft&#x2F;Top&#x2F;Width&#x2F;Height、scrollLeft&#x2F;Top&#x2F;Width&#x2F;Height、clientLeft&#x2F;Top&#x2F;Width&#x2F;Height、浏览为了返回最新值，会触发回流</p>\n<h3 id=\"请问在浏览器中输入-URL-后，浏览器会做哪些工作？\"><a href=\"#请问在浏览器中输入-URL-后，浏览器会做哪些工作？\" class=\"headerlink\" title=\"请问在浏览器中输入 URL 后，浏览器会做哪些工作？\"></a>请问在浏览器中输入 URL 后，浏览器会做哪些工作？</h3><p>从输入 URL 到渲染出整个页面包括三个部分：</p>\n<p><strong>（1）、DNS 解析 URL</strong></p>\n<p>DNS 解析就是寻找哪个服务器上有请求的资源，因为 ip 地址不易记忆，一般会使用 URL 域名（如<a href=\"http://www.baidu.com)作为网址,dns解析就是将域名“翻译”成ip地址/\">www.baidu.com）作为网址，DNS解析就是将域名“翻译”成IP地址</a></p>\n<p>具体过程：</p>\n<p>a、浏览器缓存：浏览器会按照一定的频率，缓存 DNS 记录</p>\n<p>b、操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会取操作系统中找</p>\n<p>c、路由缓存：路由器也有 DNS 缓存</p>\n<p>d、ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求</p>\n<p>e、根服务器：ISP 的 DNS 服务器找不到，就要向根服务器发出请求，进行递归查询</p>\n<p><strong>（2）、浏览器发送请求与服务器交互</strong></p>\n<p>a、浏览器利用 tcp 协议通过三次握手与服务器建立连接</p>\n<p>http 请求包括 header 和 body，header 中包括请求的方式（get 和 post）、请求的协议 （http、https、ftp）、请求的地址 ip、缓存 cookie，body 中有请求的内容</p>\n<p>b、浏览器根据解析到的 IP 地址和端口号发起 http 的 get 请求</p>\n<p>c、服务器接收到 http 请求之后，开始搜索 html 页面，并使用 http 返回响应报文</p>\n<p>d、若状态码为 200 显示响应成功，浏览器接收到返回的 HTML 页面后，开始渲染页面</p>\n<p><strong>（3）、浏览器对接收到的 HTML 页面进行渲染</strong></p>\n<p>a、浏览器根据深度遍历的方式把 HTML 节点遍历成 DOM 树</p>\n<p>b、将 CSS 解析成 CSSOM 树</p>\n<p>c、将 DOM 树和 CSSOM 树构造成 Render 树</p>\n<p>d、根据 Render 树计算所有节点在屏幕中的位置，进行布局（回流）</p>\n<p>e、遍历 Render 树并调用硬件 API 绘制所有节点（重绘）</p>\n<h3 id=\"所以以下几个动作可能会导致性能问题：\"><a href=\"#所以以下几个动作可能会导致性能问题：\" class=\"headerlink\" title=\"所以以下几个动作可能会导致性能问题：\"></a>所以以下几个动作可能会导致性能问题：</h3><ul>\n<li>改变 window 大小</li>\n<li>改变字体</li>\n<li>添加或删除样式</li>\n<li>文字改变</li>\n<li>定位或者浮动</li>\n<li>盒模型</li>\n</ul>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：</p>\n<ul>\n<li><p>PARSE：解析 HTML，构建 DOM 树。</p>\n<blockquote>\n<p>Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。<br>Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如<html>, <body>）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。<br>DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。</p>\n</blockquote>\n</li>\n<li><p>STYLE：为每个节点计算最终的有效样式（CSS-CSSOM）。</p>\n<blockquote>\n<p>收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。<br>访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。<br>结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。</p>\n</blockquote>\n</li>\n<li><p>LAYOUT：为每个节点计算位置和大小等布局信息。</p>\n<blockquote>\n<p>Layout 树和 DOM 树不一定是一一对应的，为了构建 Layout 树，浏览器主要完成了下列工作：从 DOM 树的根节点开始遍历每个可见节点。某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。为伪元素创建 LayoutObject。为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。</p>\n</blockquote>\n</li>\n<li><p>PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。</p>\n<blockquote>\n<p>DOM 树的 Document 节点对应的 RenderView 节点。DOM 树中 Document 节点的子节点，也就是 HTML 节点对应的 RenderBlock 节点。显式指定 CSS 位置的节点（position 为 absolute 或者 fixed）。具有透明效果的节点。具有 CSS 3D 属性的节点。使用 Canvas 元素或者 Video 元素的节点。浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。</p>\n</blockquote>\n</li>\n<li><p>COMPOSITE &amp; RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。</p>\n</li>\n</ul>\n<h3 id=\"次级资源加载\"><a href=\"#次级资源加载\" class=\"headerlink\" title=\"次级资源加载\"></a>次级资源加载</h3><p>一个网页通常会使用多个外部资源，如图片、JavaScript、CSS、字体等。主线程在解析 DOM 的过程中遇到这些资源后会一一请求。为了加速渲染流程，会有一个叫做预加载扫描器（preload scanner）线程并发运行。如果 HTML 中存在 img 或 link 之类的内容，则预加载扫描器会查看 HTML parser 生成的标记，并发送请求到浏览器进程的网络线程获取这些资源。</p>\n<h3 id=\"JavaScript-可能阻塞解析\"><a href=\"#JavaScript-可能阻塞解析\" class=\"headerlink\" title=\"JavaScript 可能阻塞解析\"></a>JavaScript 可能阻塞解析</h3><p>当 HTML 解析器发现 script 标签时，会暂停 HTML 的解析，转而开始加载、解析和执行 JavaScript。因为 JS 可能会改变 DOM 的结构。如果不想因 JS 阻塞 HTML 的解析，可以为 script 标签添加 defer 属性或将 script 放在 body 结束标签之前，浏览器会在最后执行 JS 代码，避免阻塞 DOM 构建。</p>\n<h3 id=\"CSSOM\"><a href=\"#CSSOM\" class=\"headerlink\" title=\"CSSOM\"></a>CSSOM</h3><p>CSSOM 和 DOM 是并行构建的，构建 CSSOM 不会阻塞 DOM 的构建。但 CSSOM 会阻塞 JS 的执行，因为 JS 可能会操作样式信息。虽然 CSSOM 不会阻塞 DOM 的构建，但在进入下一阶段之前，必须等待 CSSOM 构建完成。这也是通常所说的 CSSOM 会阻塞渲染。</p>\n<h3 id=\"浏览器渲染性能的优化\"><a href=\"#浏览器渲染性能的优化\" class=\"headerlink\" title=\"浏览器渲染性能的优化\"></a>浏览器渲染性能的优化</h3><p>上一节中是一轮典型的浏览器渲染流程，在流程完成之后，DOM、CSSOM、LayoutObject、PaintLayer 等各种树状数据结构都会保留下来，以便在用户操作、网络请求、JS 执行等事件发生时，重新触发渲染流程。</p>\n<h4 id=\"2-1-减少渲染中的重排重绘\"><a href=\"#2-1-减少渲染中的重排重绘\" class=\"headerlink\" title=\"2.1 减少渲染中的重排重绘\"></a>2.1 减少渲染中的重排重绘</h4><blockquote>\n<p>使用合适的网页分层技术：如使用多层 canvas，将动画背景，运动主体，次要物体分层，这样每一帧需要变化的就只是一个或部分合成层，而不是整个页面。<br>使用 CSS Transforms 和 Animations：它可以让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果，而不需要重新计算布局，重新绘制图形。CSS Triggers 中仅触发 Composite 的属性就是最优的选择。</p>\n</blockquote>\n<h4 id=\"2-2-优化影响渲染的资源在浏览器解析\"><a href=\"#2-2-优化影响渲染的资源在浏览器解析\" class=\"headerlink\" title=\"2.2 优化影响渲染的资源在浏览器解析\"></a>2.2 优化影响渲染的资源在浏览器解析</h4><p>HTML 的过程中，CSS 和 JS 都有可能对页面的渲染造成影响。</p>\n<blockquote>\n<p>优化方法包括以下几点：<br>关键 CSS 资源放在头部加载。<br>JS 通常放在页面底部。<br>为 JS 添加 async 和 defer 属性。<br>body 中尽量不要出现 CSS 和 JS。<br>为 img 指定宽高，避免图像加载完成后触发重排。<br>避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。</p>\n</blockquote>\n<h3 id=\"CSSOM-1\"><a href=\"#CSSOM-1\" class=\"headerlink\" title=\"CSSOM\"></a>CSSOM</h3><p>像 <head> 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。</p>\n<p>每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。</p>\n<h3 id=\"第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\"><a href=\"#第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\" class=\"headerlink\" title=\"第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\"></a>第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。</h3><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>综上所述，我们得出这样的结论：</p>\n<p>浏览器工作流程：构建 DOM -&gt; 构建 CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。<br>CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。<br><strong>通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。</strong><br>（）</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"浏览器渲染机制\"><a href=\"#浏览器渲染机制\" class=\"headerlink\" title=\"浏览器渲染机制\"></a>浏览器渲染机制</h3><p>首先，浏览器的渲染机制中有几个基本概念名称：</p>\n<p>（1）、DOM：浏览器将 HTML 解析成树形的数据结构</p>\n<p>（2）、CSSOM：浏览器将 CSS 解析成树形的数据结构</p>\n<p>（3）、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree（渲染树）</p>\n<p>（4）、Layout：计算出 Render Tree 每个节点的具***置</p>\n<p>（5）、Painting：通过显卡，将 Layout 后的节点内容分别呈现到屏幕上</p>\n<p>浏览器整个渲染流程如下：</p>\n<p>（1）、用户输入一个 URL 后，浏览器就会向服务器发出一个请求，请求 URL 对应的资源</p>\n<p>（2）、接到服务器的响应内容后，浏览器的 HTML 解析器，会将 HTML 文件解析成一颗 DOM 树，DOM 树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成后，才会去构建当前节点的下一个兄弟节点</p>\n<p>（3）、将 CSS 解析成 CSSOM 树</p>\n<p>（4）、根据 DOM 树与 CSSOM 树，构建 Render Tree</p>\n<p>（5）、浏览器会根据 Render Tree 能知道网页中哪些有节点，各个节点的 CSS，以及各个节点的从属关系</p>\n<p>（6）、计算出每个节点在屏幕中的位置后，最后一步就是 Painting，根据计算出的规则，把内容画到屏幕上</p>\n<p>注意：</p>\n<p>浏览器在获得 HTML 文件后，是自上而下的加载，并在加载过程中进行解析与渲染</p>\n<p>加载过程中：</p>\n<p>遇到外部 CSS 文件和图片等静态资源时，浏览器会另外发送一个异步请求</p>\n<p>遇到 js 文件时，HTML 文件会挂起渲染的进程，等待 js 文件加载完毕后，再继续进行渲染，因为 js 可能会修改 DOM，导致后续 HTML 资源白白加载，这也是为什么建议将 js 文件写在底部 body 标签前</p>\n<h3 id=\"请问你了解什么是重绘？什么是回流？两者有何区别？\"><a href=\"#请问你了解什么是重绘？什么是回流？两者有何区别？\" class=\"headerlink\" title=\"请问你了解什么是重绘？什么是回流？两者有何区别？\"></a>请问你了解什么是重绘？什么是回流？两者有何区别？</h3><p><strong>重绘：</strong></p>\n<p>更换某个元素颜色，这样的行为是不影响页面布局，DOM 树不会变化，但颜色变了，使该元素所在的 Layer 重新渲染</p>\n<p>常见情况：</p>\n<p>（1）、回流必定引发重绘，但重绘也会单独触发</p>\n<p>（2）、背景色、颜色、字体改变（字体大小改变，会触发回流）</p>\n<p><strong>回流：</strong></p>\n<p>增删 DOM 节点，或修改一个元素的宽高，页面布局发生变化，DOM 树结构发生变化，需要重新构建 DOM 树，而 DOM 树与渲染树是紧密相连的，DOM 树构建完，渲染树也会随之对页面进行再次渲染</p>\n<p>常见情况：</p>\n<p>（1）、页面渲染初始化</p>\n<p>（2）、DOM 树变化（添加或者删除可见的 DOM 元素、元素位置改变）</p>\n<p>（3）、Render 树变化（元素尺寸改变：边距、填充、边框、宽度和高度）</p>\n<p>（4）、浏览器窗口尺寸改变，resize 事件发生</p>\n<p>（5）、内容改变：文本改变或者图片大小改变而引起的计算值宽度和高度改变；</p>\n<p>（6）、查询布局信息，包括 offestLeft&#x2F;Top&#x2F;Width&#x2F;Height、scrollLeft&#x2F;Top&#x2F;Width&#x2F;Height、clientLeft&#x2F;Top&#x2F;Width&#x2F;Height、浏览为了返回最新值，会触发回流</p>\n<h3 id=\"请问在浏览器中输入-URL-后，浏览器会做哪些工作？\"><a href=\"#请问在浏览器中输入-URL-后，浏览器会做哪些工作？\" class=\"headerlink\" title=\"请问在浏览器中输入 URL 后，浏览器会做哪些工作？\"></a>请问在浏览器中输入 URL 后，浏览器会做哪些工作？</h3><p>从输入 URL 到渲染出整个页面包括三个部分：</p>\n<p><strong>（1）、DNS 解析 URL</strong></p>\n<p>DNS 解析就是寻找哪个服务器上有请求的资源，因为 ip 地址不易记忆，一般会使用 URL 域名（如<a href=\"http://www.baidu.com)作为网址,dns解析就是将域名“翻译”成ip地址/\">www.baidu.com）作为网址，DNS解析就是将域名“翻译”成IP地址</a></p>\n<p>具体过程：</p>\n<p>a、浏览器缓存：浏览器会按照一定的频率，缓存 DNS 记录</p>\n<p>b、操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会取操作系统中找</p>\n<p>c、路由缓存：路由器也有 DNS 缓存</p>\n<p>d、ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求</p>\n<p>e、根服务器：ISP 的 DNS 服务器找不到，就要向根服务器发出请求，进行递归查询</p>\n<p><strong>（2）、浏览器发送请求与服务器交互</strong></p>\n<p>a、浏览器利用 tcp 协议通过三次握手与服务器建立连接</p>\n<p>http 请求包括 header 和 body，header 中包括请求的方式（get 和 post）、请求的协议 （http、https、ftp）、请求的地址 ip、缓存 cookie，body 中有请求的内容</p>\n<p>b、浏览器根据解析到的 IP 地址和端口号发起 http 的 get 请求</p>\n<p>c、服务器接收到 http 请求之后，开始搜索 html 页面，并使用 http 返回响应报文</p>\n<p>d、若状态码为 200 显示响应成功，浏览器接收到返回的 HTML 页面后，开始渲染页面</p>\n<p><strong>（3）、浏览器对接收到的 HTML 页面进行渲染</strong></p>\n<p>a、浏览器根据深度遍历的方式把 HTML 节点遍历成 DOM 树</p>\n<p>b、将 CSS 解析成 CSSOM 树</p>\n<p>c、将 DOM 树和 CSSOM 树构造成 Render 树</p>\n<p>d、根据 Render 树计算所有节点在屏幕中的位置，进行布局（回流）</p>\n<p>e、遍历 Render 树并调用硬件 API 绘制所有节点（重绘）</p>\n<h3 id=\"所以以下几个动作可能会导致性能问题：\"><a href=\"#所以以下几个动作可能会导致性能问题：\" class=\"headerlink\" title=\"所以以下几个动作可能会导致性能问题：\"></a>所以以下几个动作可能会导致性能问题：</h3><ul>\n<li>改变 window 大小</li>\n<li>改变字体</li>\n<li>添加或删除样式</li>\n<li>文字改变</li>\n<li>定位或者浮动</li>\n<li>盒模型</li>\n</ul>\n<h3 id=\"渲染\"><a href=\"#渲染\" class=\"headerlink\" title=\"渲染\"></a>渲染</h3><p>当浏览器进程获取到 HTML 的第一个字节开始，会通知渲染进程开始解析 HTML，将 HTML 转换成 DOM 树，并进入渲染流程。一般所有的浏览器都会经过五大步骤，分别是：</p>\n<ul>\n<li><p>PARSE：解析 HTML，构建 DOM 树。</p>\n<blockquote>\n<p>Conversion（转换）：浏览器从网络或磁盘读取 HTML 文件原始字节，根据指定的文件编码（如 UTF-8）将字节转换成字符。<br>Tokenizing（分词）：浏览器根据 HTML 规范将字符串转换为不同的标记（如<html>, <body>）。Lexing（语法分析）：上一步产生的标记将被转换为对象，这些对象包含了 HTML 语法的各种信息，如属性、属性值、文本等。<br>DOM construction（DOM 构造）：因为 HTML 标记定义了不同标签之间的关系，上一步产生的对象会链接在一个树状数据结构中，以标识父子、兄弟关系。</p>\n</blockquote>\n</li>\n<li><p>STYLE：为每个节点计算最终的有效样式（CSS-CSSOM）。</p>\n<blockquote>\n<p>收集、划分和索引所有样式表中存在的样式规则，CSS 引擎会从 style 标签，css 文件及浏览器代理样式中收集所有的样式规则，并为这些规则建立索引，以方便后续的高效查询。<br>访问每个元素并找到适用于该元素的所有规则，CSS 引擎遍历 DOM 节点，进行选择器匹配，并为匹配的节点执行样式设置。<br>结合层叠规则和其他信息为节点生成最终的计算样式，这些样式的值可以通过 window.getComputedStyle() 获取。</p>\n</blockquote>\n</li>\n<li><p>LAYOUT：为每个节点计算位置和大小等布局信息。</p>\n<blockquote>\n<p>Layout 树和 DOM 树不一定是一一对应的，为了构建 Layout 树，浏览器主要完成了下列工作：从 DOM 树的根节点开始遍历每个可见节点。某些不可见节点（例如 script、head、meta 等），它们不会体现在渲染输出中，会被忽略。某些通过设置 display 为 none 隐藏的节点，在渲染树中也会被忽略。为伪元素创建 LayoutObject。为行内元素创建匿名包含块对应的 LayoutObject。对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。产出可见节点，包含其内容和计算的样式。</p>\n</blockquote>\n</li>\n<li><p>PAINT：绘制不同的盒子，为了避免不必要的重绘，将会分成多个层进行处理。</p>\n<blockquote>\n<p>DOM 树的 Document 节点对应的 RenderView 节点。DOM 树中 Document 节点的子节点，也就是 HTML 节点对应的 RenderBlock 节点。显式指定 CSS 位置的节点（position 为 absolute 或者 fixed）。具有透明效果的节点。具有 CSS 3D 属性的节点。使用 Canvas 元素或者 Video 元素的节点。浏览器遍历 LayoutObject 树的时候，建立了 PaintLayer 树，LayoutObject 与 PaintLayer 也不一定是一一对应的。每个 LayoutObject 要么与自己的 PaintLayer 关联，要么与拥有 PaintLayer 的第一个祖先的 PaintLayer 关联。</p>\n</blockquote>\n</li>\n<li><p>COMPOSITE &amp; RENDER：将上述不同的层合成为一张位图，发送给 GPU，渲染到屏幕上。为了提高浏览器的渲染性能，通常的手段是保证渲染流程不被阻塞，避免不必要的绘制计算和重排重绘，利用 GPU 硬件加速等技术来提高渲染性能。</p>\n</li>\n</ul>\n<h3 id=\"次级资源加载\"><a href=\"#次级资源加载\" class=\"headerlink\" title=\"次级资源加载\"></a>次级资源加载</h3><p>一个网页通常会使用多个外部资源，如图片、JavaScript、CSS、字体等。主线程在解析 DOM 的过程中遇到这些资源后会一一请求。为了加速渲染流程，会有一个叫做预加载扫描器（preload scanner）线程并发运行。如果 HTML 中存在 img 或 link 之类的内容，则预加载扫描器会查看 HTML parser 生成的标记，并发送请求到浏览器进程的网络线程获取这些资源。</p>\n<h3 id=\"JavaScript-可能阻塞解析\"><a href=\"#JavaScript-可能阻塞解析\" class=\"headerlink\" title=\"JavaScript 可能阻塞解析\"></a>JavaScript 可能阻塞解析</h3><p>当 HTML 解析器发现 script 标签时，会暂停 HTML 的解析，转而开始加载、解析和执行 JavaScript。因为 JS 可能会改变 DOM 的结构。如果不想因 JS 阻塞 HTML 的解析，可以为 script 标签添加 defer 属性或将 script 放在 body 结束标签之前，浏览器会在最后执行 JS 代码，避免阻塞 DOM 构建。</p>\n<h3 id=\"CSSOM\"><a href=\"#CSSOM\" class=\"headerlink\" title=\"CSSOM\"></a>CSSOM</h3><p>CSSOM 和 DOM 是并行构建的，构建 CSSOM 不会阻塞 DOM 的构建。但 CSSOM 会阻塞 JS 的执行，因为 JS 可能会操作样式信息。虽然 CSSOM 不会阻塞 DOM 的构建，但在进入下一阶段之前，必须等待 CSSOM 构建完成。这也是通常所说的 CSSOM 会阻塞渲染。</p>\n<h3 id=\"浏览器渲染性能的优化\"><a href=\"#浏览器渲染性能的优化\" class=\"headerlink\" title=\"浏览器渲染性能的优化\"></a>浏览器渲染性能的优化</h3><p>上一节中是一轮典型的浏览器渲染流程，在流程完成之后，DOM、CSSOM、LayoutObject、PaintLayer 等各种树状数据结构都会保留下来，以便在用户操作、网络请求、JS 执行等事件发生时，重新触发渲染流程。</p>\n<h4 id=\"2-1-减少渲染中的重排重绘\"><a href=\"#2-1-减少渲染中的重排重绘\" class=\"headerlink\" title=\"2.1 减少渲染中的重排重绘\"></a>2.1 减少渲染中的重排重绘</h4><blockquote>\n<p>使用合适的网页分层技术：如使用多层 canvas，将动画背景，运动主体，次要物体分层，这样每一帧需要变化的就只是一个或部分合成层，而不是整个页面。<br>使用 CSS Transforms 和 Animations：它可以让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果，而不需要重新计算布局，重新绘制图形。CSS Triggers 中仅触发 Composite 的属性就是最优的选择。</p>\n</blockquote>\n<h4 id=\"2-2-优化影响渲染的资源在浏览器解析\"><a href=\"#2-2-优化影响渲染的资源在浏览器解析\" class=\"headerlink\" title=\"2.2 优化影响渲染的资源在浏览器解析\"></a>2.2 优化影响渲染的资源在浏览器解析</h4><p>HTML 的过程中，CSS 和 JS 都有可能对页面的渲染造成影响。</p>\n<blockquote>\n<p>优化方法包括以下几点：<br>关键 CSS 资源放在头部加载。<br>JS 通常放在页面底部。<br>为 JS 添加 async 和 defer 属性。<br>body 中尽量不要出现 CSS 和 JS。<br>为 img 指定宽高，避免图像加载完成后触发重排。<br>避免使用 table, iframe 等慢元素。原因是 table 会等到它的 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。</p>\n</blockquote>\n<h3 id=\"CSSOM-1\"><a href=\"#CSSOM-1\" class=\"headerlink\" title=\"CSSOM\"></a>CSSOM</h3><p>像 <head> 和它的子节点以及任何具有 display: none 样式的结点，例如 script { display: none; }（在 user agent stylesheets 可以看到这个样式）这些标签将不会显示，也就是它们不会出现在 Render 树上。具有 visibility: hidden 的节点会出现在 Render 树上，因为它们会占用空间。由于我们没有给出任何指令来覆盖用户代理的默认值，因此上面代码示例中的 script 节点将不会包含在 Render 树中。</p>\n<p>每个可见节点都应用了其 CSSOM 规则。Render 树保存所有具有内容和计算样式的可见节点——将所有相关样式匹配到 DOM 树中的每个可见节点，并根据 CSS 级联确定每个节点的计算样式。</p>\n<h3 id=\"第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\"><a href=\"#第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\" class=\"headerlink\" title=\"第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。\"></a>第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。</h3><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>综上所述，我们得出这样的结论：</p>\n<p>浏览器工作流程：构建 DOM -&gt; 构建 CSSOM -&gt; 构建渲染树 -&gt; 布局 -&gt; 绘制。<br>CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。<br><strong>通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新 DOM 构建。</strong><br>（）</p>\n"},{"title":"【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线","date":"2022-03-10T03:38:24.514Z","_content":"\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","source":"_posts/Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线.md","raw":"---\ntitle: 【Echarts使用】之 x/y轴刻度、文字、轴线样式、分割线\ndate:\ntags: [前端, Echarts]\ncategories: [前端, Echarts, xAxis]\n---\n\n### 隐藏 x/y 轴刻度\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏x轴刻度\n    },\n},\n// y轴\nyAxis: {\n    type: 'category',\n    splitLine: { show: false },\n    data: ['11/25', '11/26', '11/27', '11/28', '11/29', '11/30', '12/1'],\n    axisTick: {\n        show: false //隐藏y轴刻度\n    },\n},\n```\n\n### 更改 x/y 轴文字\n\n```\n//x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n//y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLabel: {\n        show: true,\n        textStyle: {\n            color: '#6B6E7F',  //更改坐标轴文字颜色\n            fontSize: 9      //更改坐标轴文字大小\n        }\n    }\n},\n```\n\n### 更改 x/y 轴线样式\n\n```\n// x轴\nxAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n// y轴\nyAxis: {\n    type: 'category',\n    // offset: 40,\n    splitLine: { show: false },\n    data: [],\n    axisLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //0 轴线设置样式\n},\n```\n\n### x/y 轴分隔线\n\n```\n// x轴\nxAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n// y轴\nyAxis: {\n    type: 'value',\n    axisLabel: {\n        show: false,\n        interval: 'auto',\n        formatter: '{value} AM'\n    },\n    min: 20,\n    max: 33, // y轴的展示范围\n    axisTick: {\n        show: false\n    },\n    splitLine: {\n        show: false,\n        lineStyle: {\n            type: 'dashed',\n            color: '#86899D'\n        }\n    } //设置y轴分割线样式\n},\n```\n","slug":"Echarts/echarts--xy轴刻度、文字、轴线样式、分隔线","published":1,"updated":"2023-08-13T12:00:34.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwh000wm32v0kb0e4fl","content":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"隐藏-x-y-轴刻度\"><a href=\"#隐藏-x-y-轴刻度\" class=\"headerlink\" title=\"隐藏 x&#x2F;y 轴刻度\"></a>隐藏 x&#x2F;y 轴刻度</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏x轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [&#x27;11/25&#x27;, &#x27;11/26&#x27;, &#x27;11/27&#x27;, &#x27;11/28&#x27;, &#x27;11/29&#x27;, &#x27;11/30&#x27;, &#x27;12/1&#x27;],</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false //隐藏y轴刻度</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴文字\"><a href=\"#更改-x-y-轴文字\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴文字\"></a>更改 x&#x2F;y 轴文字</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">//y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: true,</span><br><span class=\"line\">        textStyle: &#123;</span><br><span class=\"line\">            color: &#x27;#6B6E7F&#x27;,  //更改坐标轴文字颜色</span><br><span class=\"line\">            fontSize: 9      //更改坐标轴文字大小</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改-x-y-轴线样式\"><a href=\"#更改-x-y-轴线样式\" class=\"headerlink\" title=\"更改 x&#x2F;y 轴线样式\"></a>更改 x&#x2F;y 轴线样式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;category&#x27;,</span><br><span class=\"line\">    // offset: 40,</span><br><span class=\"line\">    splitLine: &#123; show: false &#125;,</span><br><span class=\"line\">    data: [],</span><br><span class=\"line\">    axisLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //0 轴线设置样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"x-y-轴分隔线\"><a href=\"#x-y-轴分隔线\" class=\"headerlink\" title=\"x&#x2F;y 轴分隔线\"></a>x&#x2F;y 轴分隔线</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// x轴</span><br><span class=\"line\">xAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">// y轴</span><br><span class=\"line\">yAxis: &#123;</span><br><span class=\"line\">    type: &#x27;value&#x27;,</span><br><span class=\"line\">    axisLabel: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        interval: &#x27;auto&#x27;,</span><br><span class=\"line\">        formatter: &#x27;&#123;value&#125; AM&#x27;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    min: 20,</span><br><span class=\"line\">    max: 33, // y轴的展示范围</span><br><span class=\"line\">    axisTick: &#123;</span><br><span class=\"line\">        show: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    splitLine: &#123;</span><br><span class=\"line\">        show: false,</span><br><span class=\"line\">        lineStyle: &#123;</span><br><span class=\"line\">            type: &#x27;dashed&#x27;,</span><br><span class=\"line\">            color: &#x27;#86899D&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; //设置y轴分割线样式</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"https的图片在移动端展示问题","date":"2023-08-18T01:30:59.174Z","_content":"\n### 问题描述\n\n引入的 src 图片地址是 https 时，在 pc 端和 h5 均正常显示，但在手机端均无法显示，并且图片链接在微信里面也无法打开；\n\n### 解决方案\n\n```html\n<meta name=\"referrer\" content=\"never\" />\n\n// 或\n\n<img\n  src=\"https://example.com/images/myimage.jpg\"\n  alt=\"Some image\"\n  referrerpolicy=\"no-referrer\"\n/>\n```\n\n```\n当网站使用refresh字段进行跳转的时候，大多数浏览器不发送referer;\n\n从用户从一个HTTPS的网站点击链接到另一个HTTP的网站时，不发送referer;\n\nhtml5中，a标签的rel = “noreferrer”, 可以让浏览器不发送referer;\n\n使用Data URI scheme链接的，浏览器也不发送referer;\n\n使用Content Security Policy, 也可以让浏览器不发送referer;\n\n在html头部中使用meta标签来控制不让浏览器发送referer;\n\n用户手输入网址或是从收藏夹、书签中访问。\n```\n\n```\nnever\n\nalways\n\norigin\n\ndefault\n```\n\n1.如果 referer-policy 的值为 never：删除 http head 中的 referer；\n\n2.如果 referer-policy 的值为 default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；\n\n3.如果 referer-policy 的值为 origin：只发送 origin 部分；\n\n4.如果 referer-policy 的值为 always：不改变 http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。\n","source":"_posts/Bug/兼容性/https的图片在移动端展示问题.md","raw":"---\ntitle: https的图片在移动端展示问题\ndate:\ntags: [Bug, 兼容性]\ncategories: [Bug, 兼容性, img]\n---\n\n### 问题描述\n\n引入的 src 图片地址是 https 时，在 pc 端和 h5 均正常显示，但在手机端均无法显示，并且图片链接在微信里面也无法打开；\n\n### 解决方案\n\n```html\n<meta name=\"referrer\" content=\"never\" />\n\n// 或\n\n<img\n  src=\"https://example.com/images/myimage.jpg\"\n  alt=\"Some image\"\n  referrerpolicy=\"no-referrer\"\n/>\n```\n\n```\n当网站使用refresh字段进行跳转的时候，大多数浏览器不发送referer;\n\n从用户从一个HTTPS的网站点击链接到另一个HTTP的网站时，不发送referer;\n\nhtml5中，a标签的rel = “noreferrer”, 可以让浏览器不发送referer;\n\n使用Data URI scheme链接的，浏览器也不发送referer;\n\n使用Content Security Policy, 也可以让浏览器不发送referer;\n\n在html头部中使用meta标签来控制不让浏览器发送referer;\n\n用户手输入网址或是从收藏夹、书签中访问。\n```\n\n```\nnever\n\nalways\n\norigin\n\ndefault\n```\n\n1.如果 referer-policy 的值为 never：删除 http head 中的 referer；\n\n2.如果 referer-policy 的值为 default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；\n\n3.如果 referer-policy 的值为 origin：只发送 origin 部分；\n\n4.如果 referer-policy 的值为 always：不改变 http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。\n","slug":"Bug/兼容性/https的图片在移动端展示问题","published":1,"updated":"2023-08-18T01:33:06.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwh0010m32v7bfg3gaf","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>引入的 src 图片地址是 https 时，在 pc 端和 h5 均正常显示，但在手机端均无法显示，并且图片链接在微信里面也无法打开；</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;referrer&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;never&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 或</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://example.com/images/myimage.jpg&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">alt</span>=<span class=\"string\">&quot;Some image&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">referrerpolicy</span>=<span class=\"string\">&quot;no-referrer&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当网站使用refresh字段进行跳转的时候，大多数浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">从用户从一个HTTPS的网站点击链接到另一个HTTP的网站时，不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">html5中，a标签的rel = “noreferrer”, 可以让浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">使用Data URI scheme链接的，浏览器也不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">使用Content Security Policy, 也可以让浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">在html头部中使用meta标签来控制不让浏览器发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">用户手输入网址或是从收藏夹、书签中访问。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">never</span><br><span class=\"line\"></span><br><span class=\"line\">always</span><br><span class=\"line\"></span><br><span class=\"line\">origin</span><br><span class=\"line\"></span><br><span class=\"line\">default</span><br></pre></td></tr></table></figure>\n\n<p>1.如果 referer-policy 的值为 never：删除 http head 中的 referer；</p>\n<p>2.如果 referer-policy 的值为 default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；</p>\n<p>3.如果 referer-policy 的值为 origin：只发送 origin 部分；</p>\n<p>4.如果 referer-policy 的值为 always：不改变 http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>引入的 src 图片地址是 https 时，在 pc 端和 h5 均正常显示，但在手机端均无法显示，并且图片链接在微信里面也无法打开；</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;referrer&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;never&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 或</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://example.com/images/myimage.jpg&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">alt</span>=<span class=\"string\">&quot;Some image&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">referrerpolicy</span>=<span class=\"string\">&quot;no-referrer&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当网站使用refresh字段进行跳转的时候，大多数浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">从用户从一个HTTPS的网站点击链接到另一个HTTP的网站时，不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">html5中，a标签的rel = “noreferrer”, 可以让浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">使用Data URI scheme链接的，浏览器也不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">使用Content Security Policy, 也可以让浏览器不发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">在html头部中使用meta标签来控制不让浏览器发送referer;</span><br><span class=\"line\"></span><br><span class=\"line\">用户手输入网址或是从收藏夹、书签中访问。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">never</span><br><span class=\"line\"></span><br><span class=\"line\">always</span><br><span class=\"line\"></span><br><span class=\"line\">origin</span><br><span class=\"line\"></span><br><span class=\"line\">default</span><br></pre></td></tr></table></figure>\n\n<p>1.如果 referer-policy 的值为 never：删除 http head 中的 referer；</p>\n<p>2.如果 referer-policy 的值为 default：如果当前页面使用的是 https 协议，而正要加载的资源使用的是普通的 http 协议，则将 http header 中的 referer 置为空；</p>\n<p>3.如果 referer-policy 的值为 origin：只发送 origin 部分；</p>\n<p>4.如果 referer-policy 的值为 always：不改变 http header 中的 referer 的值，注意：这种情况下，如果当前页面使用了 https 协议，而要加载的资源使用的是 http 协议，加载资源的请求头中也会携带 referer。</p>\n"},{"title":"【ES6学习笔记】之 变量","date":"2023-08-13T06:16:23.737Z","_content":"\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之 变量.md","raw":"---\ntitle: 【ES6学习笔记】之 变量\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 变量]\n---\n\n# 概览\n\nES6 新增了两个定义变量的关键字：`let` 与 `const`，它们几乎取代了 ES5 定义变量的方式：`var`。`let`是新的`var`,`const`简单的常量声明。\n\n```javascript\nfunction f() {\n  {\n    let x\n    {\n      // okay, block scoped name\n      const x = 'sneaky'\n      // error, const\n      x = 'foo'\n    }\n    // error, already declared in block\n    let x = 'inner'\n  }\n}\n```\n\nES6 之前变量之前存在两个问题：\n\n- JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。\n- 循环内变量过度共享\n\n# 块级作用域\n\n`let`,`const`创建的变量都是**块级作用域**：它们只存在包围它们的最深代码块中。\n\n作用域有哪些？\n\n- 块级作用域\n- 函数作用域\n- 全局作用域\n\n```javascript\nfunction func() {\n  if (true) {\n    let tmp = 123\n    // const tmp = 123;\n  }\n  console.log(tmp) // ReferenceError: tmp is not defined\n}\nconsole.log(tmp) // ReferenceError: tmp is not defined\n```\n\n相比之下，`var`声明的是函数域。\n\n```javascript\nfunction func() {\n  if (true) {\n    var tmp = 123\n  }\n  console.log(tmp) // 123\n}\nfunc()\nconsole.log(tmp) // tmp is not defined\n```\n\n下面的式子更难看出函数作用域与块级作用域的区别\n\n```javascript\nfunction myFunc() {\n  var number1 = 15 // 函数作用域\n  if (true) {\n    let number1 = 20 // 块级作用域\n    console.log(number1) // 20\n  }\n  console.log(number1) // 15\n}\nmyFunc()\nconsole.log(number1) // number1 is not defined\n```\n\n而全局作用域，可以从 JavaScript 程序中的任何位置访问。\n\n```javascript\nvar number1 = 15\nconsole.log(window.number1, globalThis.number1, window === globalThis) // 15 15 true\n```\n\n**面试题：循环中定时器闭包**\n\n```javascript\nfor (var i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) //5, 5, 5, 5, 5\n  }, 0)\n}\nconsole.log(i) //5 i跳出循环体污染外部函数\n\n//将var改成let之后\nfor (let i = 0; i < 5; i++) {\n  setTimeout(() => {\n    console.log(i) // 0,1,2,3,4\n  }, 0)\n}\nconsole.log(i) //i is not defined i无法污染外部函数\n```\n\n在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。\n\n# TDZ\n\n> `let`、`const`暂时性死区（temporal dead zone）\n\n`let`,`const`声明的变量拥有**暂时性死区**：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。  \n简单描述：\n\n```javascript\nif (true) {\n  //这块区域是TDZ\n  console.log(a) // Uncaught ReferenceError: Cannot access 'a' before initialization\n  let a = 1\n  // const a = 1\n}\n```\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  // Uninitialized binding for `tmp` is created\n\n  tmp = 'abc' // ReferenceError\n  console.log(tmp) // ReferenceError\n\n  let tmp // TDZ ends, `tmp` is initialized with `undefined`\n  console.log(tmp) // undefined\n\n  tmp = 123\n  console.log(tmp) // 123\n}\n```\n\n下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）\n\n```javascript\nif (true) {\n  // enter new scope, TDZ starts\n  const func = function () {\n    console.log(myVar) // OK!\n  }\n\n  // Here we are within the TDZ and\n  // accessing `myVar` would cause a `ReferenceError`\n\n  let myVar = 3 // TDZ ends\n  func() // called outside TDZ\n}\n```\n\n上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。\n\n#### 为什么会存在 TDZ?\n\n- 它帮助我们发现错误。\n- 在声明变量之前尝试访问它是错误的方式。\n\n> 为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。\n\n我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。\n\n或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。\n\n# 变量提升\n\n> `var`变量提升\n\nJavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做**变量提升（Hoisting）**\n\n下面代码，演示了函数的变量提升：\n\n```javascript\n{\n  // Enter a new scope\n\n  console.log(foo()) // hello, due to hoisting\n  function foo() {\n    return 'hello'\n  }\n}\n```\n\n也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。\n\n```javascript\nfunction test() {\n  console.log('1: ', a) //undefined\n  if (false) {\n    var a = 1\n  }\n  console.log('3: ', a) //undefined\n}\n\ntest()\n```\n\n实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。\n\n```javascript\nfunction test() {\n  var a\n  //a声明没有赋值\n  console.log('1: ', a) //undefined\n  if (false) {\n    a = 1\n  }\n  //a声明没有赋值\n  console.log('3: ', a) //undefined\n}\n```\n\n在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。\n\n```javascript\n//b提升到函数a顶部，但不会提升到函数test。\nfunction test() {\n  function a() {\n    if (false) {\n      var b = 2\n    }\n  }\n  console.log('b: ', b)\n}\n\ntest() //b is not defined\n```\n\n# 不允许重复声明\n\n> `let`不允许重复声明\n\n`let`不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction func() {\n  let a = 10\n  var a = 1\n}\n\n// 报错\nfunction func() {\n  let a = 10\n  let a = 1\n}\n```\n\n因此在函数内部不能重新声明函数\n\n```javascript\nfunction func(arg) {\n  let arg\n}\nfunc() // 报错 Identifier 'arg' has already been declared\n\nfunction func(arg) {\n  {\n    let arg\n  }\n}\nfunc() // 不报错\n```\n\n# const 命令\n\n> const 声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n一般使用场景：\n\n```javascript\nconst start = 'hi all'\n\nconst getName = () => {\n  return 'jelly'\n}\n\nconst conf = {\n  fav: 'Coding',\n}\n\n// 模板\nconst msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`\n```\n\n你可能不知道的事：\n\n```javascript\n// 1. 与引号混用\nconst wantToSay = `I'm a \"tbfed\"`\n\n// 2. 支持多行文本\nconst slogan = `\nI have a dream today!\n`\n\n// 比较适合写HTML\nconst resultTpl = `\n  <section>\n    <div>...</div>\n  </section>\n`\n```\n\n> 在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。\n\n```javascript\nconst obj = { prop: 0 }\nobj.prop = obj.prop + 1\nconsole.log(obj.prop) // 1\n```\n\n# 全局变量和全局对象\n\n在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：\n\n- 全局声明变量是普通变量。\n  它们只能在脚本的顶层通过 const、let 和类声明创建。\n- 全局对象变量被存储在所谓全局对象的属性中。\n  它们是在脚本的顶层通过 var 和函数声明创建的。\n  可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。\n  除此之外，全局对象变量像普通变量一样工作。\n\n```javascript\nwindow === globalThis // true\n\nconsole.log(window.a) // 1\nvar a = 1\nconsole.log(window.a) // 1\n```\n\n# 区别\n\n`var`、`let`和`const`是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n\n`var`:\n\n- var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。\n- 其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。\n- 如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。\n\n`let`:\n\n- let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。\n- 用户不能重新声明使用 let 关键字定义的变量，但可以更新它。\n- 用户可以使用 let 关键字在不同的功能块中声明同名变量。\n- 无需初始化即可声明。\n\n`const`:\n\n- const 变量的作用域是块作用域。\n- 它不能更新或重新声明到范围内\n- 没有初始化就不能声明\n\n**变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n`let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n# 面试题\n\n### 1.请问 var、let 和 const 有何区别？\n\n**作用域不同：**\n\nvar 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的\n\nlet 、 const 声明的是块级作用域变量，只在它所在的代码块内有效\n\n**变量提升现象：**\n\nvar 声明的变量会被提升到作用域顶部，并初始化为 undefined\n\nlet、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined\n\n**变量/常量：**\n\nvar 和 let 声明变量，const 声明只读常量\n\n**暂时性死区：**\n\nvar 可以先使用，后声明，值为 undefined\n\nlet 、const 必须先声明，后使用；且 const 必须初始化赋值\n\n在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：\n\n由 let/const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）\n\n简单来说：用 let/const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。**从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)**\n\n### 2.const 声明的变量是绝对的不可变吗？\n\n实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量\n\n对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。\n\n例如 const 定义一个对象，对象的属性的值是可变的。\n\n**原文地址** [第一章 变量](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md)  \n**下一章**：[第二章 模板字符串、字符串新特性](https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之 变量","published":1,"updated":"2023-08-14T04:07:03.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwi0012m32v2yvc6zkp","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><p>ES6 新增了两个定义变量的关键字：<code>let</code> 与 <code>const</code>，它们几乎取代了 ES5 定义变量的方式：<code>var</code>。<code>let</code>是新的<code>var</code>,<code>const</code>简单的常量声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// okay, block scoped name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> x = <span class=\"string\">&#x27;sneaky&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">// error, const</span></span><br><span class=\"line\">      x = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// error, already declared in block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;inner&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ES6 之前变量之前存在两个问题：</p>\n<ul>\n<li>JS 没有块级作用域。在 JS 函数中的 var 声明，其作用域是函数体的全部。</li>\n<li>循环内变量过度共享</li>\n</ul>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><p><code>let</code>,<code>const</code>创建的变量都是<strong>块级作用域</strong>：它们只存在包围它们的最深代码块中。</p>\n<p>作用域有哪些？</p>\n<ul>\n<li>块级作用域</li>\n<li>函数作用域</li>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"comment\">// const tmp = 123;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError: tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>相比之下，<code>var</code>声明的是函数域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// tmp is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>下面的式子更难看出函数作用域与块级作用域的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunc</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span> <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> number1 = <span class=\"number\">20</span> <span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 20</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">myFunc</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(number1) <span class=\"comment\">// number1 is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>而全局作用域，可以从 JavaScript 程序中的任何位置访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> number1 = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">number1</span>, globalThis.<span class=\"property\">number1</span>, <span class=\"variable language_\">window</span> === globalThis) <span class=\"comment\">// 15 15 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>面试题：循环中定时器闭包</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5, 5, 5, 5, 5</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//5 i跳出循环体污染外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将var改成let之后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i) <span class=\"comment\">//i is not defined i无法污染外部函数</span></span><br></pre></td></tr></table></figure>\n\n<p>在 for 循环中使用 var 声明的循环变量，会跳出循环体污染当前的函数。</p>\n<h1 id=\"TDZ\"><a href=\"#TDZ\" class=\"headerlink\" title=\"TDZ\"></a>TDZ</h1><blockquote>\n<p><code>let</code>、<code>const</code>暂时性死区（temporal dead zone）</p>\n</blockquote>\n<p><code>let</code>,<code>const</code>声明的变量拥有<strong>暂时性死区</strong>：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。<br>简单描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这块区域是TDZ</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\">// const a = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"comment\">// Uninitialized binding for `tmp` is created</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"string\">&#x27;abc&#x27;</span> <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp <span class=\"comment\">// TDZ ends, `tmp` is initialized with `undefined`</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp) <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面示例将演示死区（dead zone）是真正短暂时间的（基于时间）和不受空间条件限制（基于位置）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// enter new scope, TDZ starts</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myVar) <span class=\"comment\">// OK!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Here we are within the TDZ and</span></span><br><span class=\"line\">  <span class=\"comment\">// accessing `myVar` would cause a `ReferenceError`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> myVar = <span class=\"number\">3</span> <span class=\"comment\">// TDZ ends</span></span><br><span class=\"line\">  <span class=\"title function_\">func</span>() <span class=\"comment\">// called outside TDZ</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的例子我们可以清楚的看到 let myVar 变量被定义了，但是不像 var 一样被提升。那它初始化了吗？没有，这就是 TDZ 在进入块级作用域就存在的原因。基本上，当 let myVar 将被定义时，它将进入 TDZ，并在您声明和初始化它时结束。所以在范围中，它将首先在 TDZ 中，但是一旦到达声明部分，TDZ 就会结束。</p>\n<h4 id=\"为什么会存在-TDZ\"><a href=\"#为什么会存在-TDZ\" class=\"headerlink\" title=\"为什么会存在 TDZ?\"></a>为什么会存在 TDZ?</h4><ul>\n<li>它帮助我们发现错误。</li>\n<li>在声明变量之前尝试访问它是错误的方式。</li>\n</ul>\n<blockquote>\n<p>为避免 TDZ，请始终确保在任何范围的顶部定义 let 和 const。</p>\n</blockquote>\n<p>我们可以通过分解来简单地理解这个术语。时间意味着暂时的东西，死亡意味着没有生命的状态，编程世界中与内存相关的区域。所以变量暂时不可用（或死亡）的时区在 TDZ 中。</p>\n<p>或者简单地说，进入块级作用域与其变量创建声明之间的时间跨度称为时间死区。</p>\n<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><blockquote>\n<p><code>var</code>变量提升</p>\n</blockquote>\n<p>JavaScript 中，我们通常说的作用域是函数作用域，使用 var 声明的变量，无论是在代码的哪个地方声明的，都会提升到当前作用域的最顶部，这种行为叫做<strong>变量提升（Hoisting）</strong></p>\n<p>下面代码，演示了函数的变量提升：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Enter a new scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">foo</span>()) <span class=\"comment\">// hello, due to hoisting</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，如果在函数内部声明的变量，都会被提升到函数开头，而在全局的声明，就会提升到全局作用域的顶部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>()</span><br></pre></td></tr></table></figure>\n\n<p>实际执行时，上面的代码中的变量 a 会提升到函数顶部声明，即使 if 语句的条件是 false，也一样不影响 a 的提升。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//a声明没有赋值</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3: &#x27;</span>, a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在嵌套函数的情况，变量只会提升到最近一个函数的顶部，而不会到外部函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//b提升到函数a顶部，但不会提升到函数test。</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b: &#x27;</span>, b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>() <span class=\"comment\">//b is not defined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><blockquote>\n<p><code>let</code>不允许重复声明</p>\n</blockquote>\n<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此在函数内部不能重新声明函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 报错 Identifier &#x27;arg&#x27; has already been declared</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"const-命令\"><a href=\"#const-命令\" class=\"headerlink\" title=\"const 命令\"></a>const 命令</h1><blockquote>\n<p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n</blockquote>\n<p>一般使用场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> start = <span class=\"string\">&#x27;hi all&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getName</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jelly&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> conf = &#123;</span><br><span class=\"line\">  <span class=\"attr\">fav</span>: <span class=\"string\">&#x27;Coding&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模板</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> msg = <span class=\"string\">`<span class=\"subst\">$&#123;start&#125;</span>, my name is <span class=\"subst\">$&#123;getName()&#125;</span>, <span class=\"subst\">$&#123;conf.fav&#125;</span> is my favourite`</span></span><br></pre></td></tr></table></figure>\n\n<p>你可能不知道的事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 与引号混用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> wantToSay = <span class=\"string\">`I&#x27;m a &quot;tbfed&quot;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 支持多行文本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> slogan = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">I have a dream today!</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较适合写HTML</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> resultTpl = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;section&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;...&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/section&gt;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中，const 仅表示绑定（变量名和变量值之间的关联）是不可变的。值本身可能是可变的，如以下示例中的 obj。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">obj.<span class=\"property\">prop</span> = obj.<span class=\"property\">prop</span> + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">prop</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"全局变量和全局对象\"><a href=\"#全局变量和全局对象\" class=\"headerlink\" title=\"全局变量和全局对象\"></a>全局变量和全局对象</h1><p>在 Web 浏览器中，唯一直接位于该范围内的位置是脚本的顶层。全局范围的变量称为全局变量，可以随处访问。有两种全局变量：</p>\n<ul>\n<li>全局声明变量是普通变量。<br>它们只能在脚本的顶层通过 const、let 和类声明创建。</li>\n<li>全局对象变量被存储在所谓全局对象的属性中。<br>它们是在脚本的顶层通过 var 和函数声明创建的。<br>可以通过全局变量 globalThis 访问全局对象，它可以用来创建、读取和删除全局对象变量。<br>除此之外，全局对象变量像普通变量一样工作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span> === globalThis <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">a</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p><code>var</code>、<code>let</code>和<code>const</code>是 JavaScript 用来存储和声明变量的特殊关键字。它们每个都有唯一性（差异），将简要讨论。</p>\n<ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：</li>\n</ul>\n<p><code>var</code>:</p>\n<ul>\n<li>var 分别具有全局和函数作用域，也就是说，定义在函数外部的变量可以全局访问，定义在特定函数内部的变量只能在函数内部访问。</li>\n<li>其次，用户可以使用 var 重新声明变量，用户可以更新 var 变量。</li>\n<li>如果用户在声明之前使用 var 变量，它会使用未定义的值进行初始化，值为 undefined。</li>\n</ul>\n<p><code>let</code>:</p>\n<ul>\n<li>let 变量的作用域仅为块作用域。它不能在特定功能块之外访问，let 关键字是 var 关键字的改进版本。</li>\n<li>用户不能重新声明使用 let 关键字定义的变量，但可以更新它。</li>\n<li>用户可以使用 let 关键字在不同的功能块中声明同名变量。</li>\n<li>无需初始化即可声明。</li>\n</ul>\n<p><code>const</code>:</p>\n<ul>\n<li>const 变量的作用域是块作用域。</li>\n<li>它不能更新或重新声明到范围内</li>\n<li>没有初始化就不能声明</li>\n</ul>\n<p><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</p>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h3 id=\"1-请问-var、let-和-const-有何区别？\"><a href=\"#1-请问-var、let-和-const-有何区别？\" class=\"headerlink\" title=\"1.请问 var、let 和 const 有何区别？\"></a>1.请问 var、let 和 const 有何区别？</h3><p><strong>作用域不同：</strong></p>\n<p>var 声明的变量的作用域是当前执行上下文，或者说对于声明在任何函数外的变量来说是全局的</p>\n<p>let 、 const 声明的是块级作用域变量，只在它所在的代码块内有效</p>\n<p><strong>变量提升现象：</strong></p>\n<p>var 声明的变量会被提升到作用域顶部，并初始化为 undefined</p>\n<p>let、 const 声明的变量会被提升到顶部，但在声明代码前不能使用（暂时性死区），会被初始化 undefined</p>\n<p><strong>变量&#x2F;常量：</strong></p>\n<p>var 和 let 声明变量，const 声明只读常量</p>\n<p><strong>暂时性死区：</strong></p>\n<p>var 可以先使用，后声明，值为 undefined</p>\n<p>let 、const 必须先声明，后使用；且 const 必须初始化赋值</p>\n<p>在 let、const 声明之前就访问对应的变量与常量，会抛出 ReferenceError，产生原因：</p>\n<p>由 let&#x2F;const 声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问（摘自 ES2015 语言标准）</p>\n<p>简单来说：用 let&#x2F;const 声明的变量会先在作用域中被创建出来，但此时还未进行词法绑定，是不能被访问的，会抛出错误。<strong>从在作用域创建变量开始，到变量开始可被访问之间的一段时间，称之为 TDZ(暂时性死区)</strong></p>\n<h3 id=\"2-const-声明的变量是绝对的不可变吗？\"><a href=\"#2-const-声明的变量是绝对的不可变吗？\" class=\"headerlink\" title=\"2.const 声明的变量是绝对的不可变吗？\"></a>2.const 声明的变量是绝对的不可变吗？</h3><p>实际上，不是 const 变量的值不得改动，而是变量指向的那个内存地址不得改动。对于基础类型数据，值保存在变量指向的那个内存地址，等同于常量</p>\n<p>对于复合类型数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是不变的，至于它指向的数据结构是否变化，是不可控的。</p>\n<p>例如 const 定义一个对象，对象的属性的值是可变的。</p>\n<p><strong>原文地址</strong> <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/README.md\">第一章 变量</a><br><strong>下一章</strong>：<a href=\"https://github.com/yihan12/build-up_ES6/blob/main/strings/README.md\">第二章 模板字符串、字符串新特性</a></p>\n"},{"title":"【ES6学习笔记】之 解构赋值","date":"2023-08-13T06:23:26.686Z","_content":"\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","source":"_posts/JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值.md","raw":"---\ntitle: 【ES6学习笔记】之 解构赋值\ndate:\ntags: [JavaScript, ES6]\ncategories: [前端, JavaScript, ES6, 解构]\n---\n\n# 概览\n\n> 解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。\n\n```javascript\n// old\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n    science: 85,\n  },\n}\n\nfunction displaySummary(student) {\n  console.log('Hello, ' + student.name)\n  console.log('Your Maths score is ' + (student.scores.maths || 0))\n  console.log('Your English score is ' + (student.scores.english || 0))\n  console.log('Your Science score is ' + (student.scores.science || 0))\n}\n\ndisplaySummary(student)\n\n// Hello, John Doe\n// Your Maths score is 74\n// Your English score is 63\n// Your Science score is 85\n```\n\n用 ES6 结构赋值，我们可以这么写\n\n```javascript\n// ES6\nfunction displaySummary({\n  name,\n  scores: { maths = 0, english = 0, science = 0 },\n}) {\n  console.log('Hello, ' + name)\n  console.log('Your Maths score is ' + maths)\n  console.log('Your English score is ' + english)\n  console.log('Your Science score is ' + science)\n}\n```\n\n# 对象解构\n\n对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。\n\n```javascript\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Object Destructuring\nconst { firstname, lastname, country } = student\n\nconsole.log(firstname, lastname, country) // Glad Chinda Nigeria\n```\n\n利用解构给变量重新赋值\n\n```javascript\n// Initialize local variables\nlet country = 'Canada'\nlet firstname = 'John'\nlet lastname = 'Doe'\n\nconst student = {\n  firstname: 'Glad',\n  lastname: 'Chinda',\n  country: 'Nigeria',\n}\n\n// Reassign firstname and lastname using destructuring\n// Enclose in a pair of parentheses, since this is an assignment expression\n;({ firstname, lastname } = student)\n\n// country remains unchanged (Canada)\nconsole.log(firstname, lastname, country) // Glad Chinda Canada\n```\n\n上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为`({ firstname, lastname , country} = student);`。那么, country 的值也会被重新赋值，为'Nigeria'\n\n下面看下嵌套对象的结构：\n\n```javascript\nconst student = {\n  name: 'John Doe',\n  age: 16,\n  scores: {\n    maths: 74,\n    english: 63,\n  },\n}\n\n// We define 3 local variables: name, maths, science\nconst {\n  name,\n  scores: { maths, science = 50 },\n} = student\n\nconsole.log(\n  `${name} scored ${maths} in Maths and ${science} in Elementary Science.`\n)\n\n// John Doe scored 74 in Maths and 50 in Elementary Science.\n```\n\n使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 `const { name, scores: {maths, science} } = student;`。那么`science`的值将是`undefined`\n\n点运算配合解构赋值：\n\n```javascript\nconst person = {\n  name: 'John Doe',\n  country: 'Canada',\n  city: 'shenzhen',\n  org: '123',\n  id: '1',\n}\n\n// Assign default value of 25 to age if undefined\nconst { id = '', ...all } = person\nconsole.log(all) //{ name: 'John Doe',country: 'Canada',city:'shenzhen',org:'123',}\n```\n\n从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给`all`。\n\n- 从对象中取多个属性，有了新的处理。\n- 从对象中无损删除属性，有了新的处理。\n\n当然我们也可以删除多个属性：\n\n```\nconst person = {\n    name: 'John Doe',\n    country: 'Canada',\n    city:'shenzhen',\n    org:'123',\n    id:'1'\n};\n\n// Assign default value of 25 to age if undefined\nconst { id=\"\",name=\"\", ...all } = person;\nconsole.log(all) //{country: 'Canada',city:'shenzhen',org:'123'}\n```\n\n# 数组解构\n\n> 在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。\n\n```javascript\nconst rgb = [255, 200, 0]\n\n// Array Destructuring\nconst [red, green, blue] = rgb\n\nconsole.log(`R: ${red}, G: ${green}, B: ${blue}`) // R: 255, G: 200, B: 0\n```\n\n#### 逗号可以跳过元素\n\n```javascript\nlet [, , x] = [1, 2, 3, 4]\nconsole.log(x) // 3\n```\n\n#### 数组点运算\n\n```javascript\nlet [x, ...y] = [1, 2, 3, 4]\nconsole.log(x, y) // 1 [2,3,4]\n\nlet [x, y, ...z] = ['a'] // x='a'; y=undefined; z=[]\n\nlet [x, ...[y, z]] = ['a', 'b', 'c']\n// x = 'a'; y = 'b'; z = 'c'\n```\n\n#### 循环\n\n```javascript\nfor (let [key, value] of map) {\n  console.log(key + ' is ' + value)\n}\n```\n\n#### 交换值\n\n```javascript\n;[x, y] = [y, x]\n```\n\n#### 数组删除元素\n\n```javascript\nlet [first, ...rest] = ['a', 'b', 'c']\n// first = 'a'; rest = ['b', 'c']\n```\n\n#### 克隆数组\n\n```javascript\nconst rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n\n// Cloning with array destructuring and spread operator\nconst [...rainbowClone] = rainbow\n\nconsole.log(rainbow === rainbowClone) // false\nconsole.log(rainbowClone) // ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\n```\n\n# 字符串解构\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象\n\n```javascript\nconst [a, b, c, d, e] = 'hello'\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n属性解构赋值\n\n```javascript\nlet { length: len } = 'hello'\nlen // 5\n```\n\n**原文地址**： [Destructuring](https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md)\n","slug":"JavaScript/ES6学习笔记/【ES6学习笔记】之解构赋值","published":1,"updated":"2023-08-14T04:08:06.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwj0016m32vd5tr1dey","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>解构只是意味着将复杂的结构分解成更简单的部分。在 JavaScript 中，这种复杂的结构通常是一个对象或一个数组。使用解构语法，您可以从数组和对象中提取更小的片段。解构语法可用于变量声明或变量赋值。您还可以使用嵌套解构语法来处理嵌套结构。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// old</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">    <span class=\"attr\">science</span>: <span class=\"number\">85</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">student</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + student.<span class=\"property\">name</span>)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">maths</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">english</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + (student.<span class=\"property\">scores</span>.<span class=\"property\">science</span> || <span class=\"number\">0</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">displaySummary</span>(student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Hello, John Doe</span></span><br><span class=\"line\"><span class=\"comment\">// Your Maths score is 74</span></span><br><span class=\"line\"><span class=\"comment\">// Your English score is 63</span></span><br><span class=\"line\"><span class=\"comment\">// Your Science score is 85</span></span><br></pre></td></tr></table></figure>\n\n<p>用 ES6 结构赋值，我们可以这么写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">displaySummary</span>(<span class=\"params\">&#123;</span></span><br><span class=\"line\"><span class=\"params\">  name,</span></span><br><span class=\"line\"><span class=\"params\">  scores: &#123; maths = <span class=\"number\">0</span>, english = <span class=\"number\">0</span>, science = <span class=\"number\">0</span> &#125;,</span></span><br><span class=\"line\"><span class=\"params\">&#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello, &#x27;</span> + name)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Maths score is &#x27;</span> + maths)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your English score is &#x27;</span> + english)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Your Science score is &#x27;</span> + science)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h1><p>对象解构构像是：用变量声明属性，变量值即为属性值，简单来说，就是提取对象中的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; firstname, lastname, country &#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Nigeria</span></span><br></pre></td></tr></table></figure>\n\n<p>利用解构给变量重新赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize local variables</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> country = <span class=\"string\">&#x27;Canada&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> firstname = <span class=\"string\">&#x27;John&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lastname = <span class=\"string\">&#x27;Doe&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">firstname</span>: <span class=\"string\">&#x27;Glad&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">lastname</span>: <span class=\"string\">&#x27;Chinda&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Nigeria&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reassign firstname and lastname using destructuring</span></span><br><span class=\"line\"><span class=\"comment\">// Enclose in a pair of parentheses, since this is an assignment expression</span></span><br><span class=\"line\">;(&#123; firstname, lastname &#125; = student)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// country remains unchanged (Canada)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstname, lastname, country) <span class=\"comment\">// Glad Chinda Canada</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码，用解构赋值的方式重新给 firstname, lastname 变量赋值，所以后面打印的时候，firstname, lastname 显示是 student 内部的 firstname, lastname。country 并未重新赋值，所以还是之前定义的名字。如果将中间的代码改为<code>(&#123; firstname, lastname , country&#125; = student);</code>。那么, country 的值也会被重新赋值，为’Nigeria’</p>\n<p>下面看下嵌套对象的结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">maths</span>: <span class=\"number\">74</span>,</span><br><span class=\"line\">    <span class=\"attr\">english</span>: <span class=\"number\">63</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We define 3 local variables: name, maths, science</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  name,</span><br><span class=\"line\">  <span class=\"attr\">scores</span>: &#123; maths, science = <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">&#125; = student</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(</span><br><span class=\"line\">  <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span> scored <span class=\"subst\">$&#123;maths&#125;</span> in Maths and <span class=\"subst\">$&#123;science&#125;</span> in Elementary Science.`</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// John Doe scored 74 in Maths and 50 in Elementary Science.</span></span><br></pre></td></tr></table></figure>\n\n<p>使用嵌套对象解构时，要小心避免使用空的嵌套对象字面量。虽然它是有效的语法，但它实际上没有赋值。例如，上面的 science，如果改成 <code>const &#123; name, scores: &#123;maths, science&#125; &#125; = student;</code>。那么<code>science</code>的值将是<code>undefined</code></p>\n<p>点运算配合解构赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;John Doe&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">country</span>: <span class=\"string\">&#x27;Canada&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">city</span>: <span class=\"string\">&#x27;shenzhen&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">org</span>: <span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">&#x27;1&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Assign default value of 25 to age if undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; id = <span class=\"string\">&#x27;&#x27;</span>, ...all &#125; = person</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(all) <span class=\"comment\">//&#123; name: &#x27;John Doe&#x27;,country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;,&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>从案例中我们可以可以通过点运算+对象解构赋值，可以去除对象的属性，并将剩余属性赋值给<code>all</code>。</p>\n<ul>\n<li>从对象中取多个属性，有了新的处理。</li>\n<li>从对象中无损删除属性，有了新的处理。</li>\n</ul>\n<p>当然我们也可以删除多个属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person = &#123;</span><br><span class=\"line\">    name: &#x27;John Doe&#x27;,</span><br><span class=\"line\">    country: &#x27;Canada&#x27;,</span><br><span class=\"line\">    city:&#x27;shenzhen&#x27;,</span><br><span class=\"line\">    org:&#x27;123&#x27;,</span><br><span class=\"line\">    id:&#x27;1&#x27;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Assign default value of 25 to age if undefined</span><br><span class=\"line\">const &#123; id=&quot;&quot;,name=&quot;&quot;, ...all &#125; = person;</span><br><span class=\"line\">console.log(all) //&#123;country: &#x27;Canada&#x27;,city:&#x27;shenzhen&#x27;,org:&#x27;123&#x27;&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><blockquote>\n<p>在数组解构中，您在赋值表达式的左侧使用数组文字。数组文字上的每个变量名都映射到解构数组上同一索引处的相应项目。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rgb = [<span class=\"number\">255</span>, <span class=\"number\">200</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array Destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [red, green, blue] = rgb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`R: <span class=\"subst\">$&#123;red&#125;</span>, G: <span class=\"subst\">$&#123;green&#125;</span>, B: <span class=\"subst\">$&#123;blue&#125;</span>`</span>) <span class=\"comment\">// R: 255, G: 200, B: 0</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"逗号可以跳过元素\"><a href=\"#逗号可以跳过元素\" class=\"headerlink\" title=\"逗号可以跳过元素\"></a>逗号可以跳过元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, , x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组点运算\"><a href=\"#数组点运算\" class=\"headerlink\" title=\"数组点运算\"></a>数组点运算</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [x, ...y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y) <span class=\"comment\">// 1 [2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">&#x27;a&#x27;</span>] <span class=\"comment\">// x=&#x27;a&#x27;; y=undefined; z=[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, ...[y, z]] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// x = &#x27;a&#x27;; y = &#x27;b&#x27;; z = &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(key + <span class=\"string\">&#x27; is &#x27;</span> + value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"交换值\"><a href=\"#交换值\" class=\"headerlink\" title=\"交换值\"></a>交换值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[x, y] = [y, x]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组删除元素\"><a href=\"#数组删除元素\" class=\"headerlink\" title=\"数组删除元素\"></a>数组删除元素</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// first = &#x27;a&#x27;; rest = [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"克隆数组\"><a href=\"#克隆数组\" class=\"headerlink\" title=\"克隆数组\"></a>克隆数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> rainbow = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;yellow&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;indigo&#x27;</span>, <span class=\"string\">&#x27;violet&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cloning with array destructuring and spread operator</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [...rainbowClone] = rainbow</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbow === rainbowClone) <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rainbowClone) <span class=\"comment\">// [&#x27;red&#x27;, &#x27;orange&#x27;, &#x27;yellow&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;indigo&#x27;, &#x27;violet&#x27;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"字符串解构\"><a href=\"#字符串解构\" class=\"headerlink\" title=\"字符串解构\"></a>字符串解构</h1><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">a <span class=\"comment\">// &quot;h&quot;</span></span><br><span class=\"line\">b <span class=\"comment\">// &quot;e&quot;</span></span><br><span class=\"line\">c <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">d <span class=\"comment\">// &quot;l&quot;</span></span><br><span class=\"line\">e <span class=\"comment\">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性解构赋值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">length</span>: len &#125; = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\">len <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>原文地址</strong>： <a href=\"https://github.com/yihan12/build-up_ES6-ES12/blob/main/variable/Destructuring.md\">Destructuring</a></p>\n"},{"title":"【跟着大佬学JavaScript】之数组去重（结果对比）","date":"2022-07-20T15:36:24.591Z","_content":"\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之数组去重（结果对比）\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 数组去重]\n---\n\n## 前言\n\n数组去重在面试和工作中都是比较容易见到的问题。\n\n这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。\n\n```\n const arr = [ 1, 1, \"1\", \"1\", 0, 0, \"0\", \"0\", true, false, \"true\", \"false\", \"a\", \"A\", undefined, undefined, \"undefined\", null, null, 'null', NaN, NaN, +0, -0, new String(\"1\"), new String(\"1\"), Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], [] ];\n```\n\n## 特殊类型\n\n```\nconsole.log(1 == \"1\"); // true\nconsole.log(1 === \"1\"); // false\n\nconsole.log(0 == \"0\"); // true\nconsole.log(0 === \"0\"); // false\n\nconsole.log(0 == +0); // true\nconsole.log(0 === +0); // true\n\nconsole.log(0 == -0); // true\nconsole.log(0 === -0); // true\n\nconsole.log(+0 == -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n\nconsole.log(0 == undefined); // false\nconsole.log(0 === undefined); // false\n\nconsole.log(0 == null); // false\nconsole.log(0 === null); // false\n\nconsole.log(1 == true); // true\nconsole.log(1 === true); // false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\nconsole.log(NaN == NaN); // false\nconsole.log(NaN === NaN); // false\n\nconsole.log(new String(\"1\") == new String(\"1\")); // false\nconsole.log(new String(\"1\") === new String(\"1\")); // false\nObject.prototype.toString.call(new String('1')) // '[object String]'\n\n\nconsole.log(/a/ == /a/); // false\nconsole.log(/a/ === /a/); // false\nObject.prototype.toString.call(/a/); //'[object RegExp]'\n\n\nconsole.log(Symbol(1) == Symbol(1)); // false\nconsole.log(Symbol(1) === Symbol(1)); // false\n\nconsole.log({} == {}); // false\nconsole.log({} === {}); // false\n\nconsole.log([] == []); // false\nconsole.log([] === []); // false\n```\n\n接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。\n\n## 代码一（暴力解法）\n\n```\n// 暴力解法一\n\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const res = [array[0]];\n    let arrLen = array.length;\n    let resLen = res.length;\n\n    for (let i = 0; i < arrLen; i++) {\n      let flag = true;\n      for (let j = 0; j < resLen; j++) {\n        if (array[i] === res[j]) {\n          flag = false;\n          break;\n        }\n      }\n      if (flag) {\n        res.push(array[i]);\n        resLen = res.length;\n      }\n    }\n    return res;\n}\n// [1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n暴力解法，简单易理解，兼容性好。去重结果如上所示。\n\n## 代码二（ES6）\n\n```\n// ES6 Array.from + Set 方法一\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return Array.from(new Set(array))\n}\n\n// ES6 点运算 + Set 方法二\nfunction unique1(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 箭头函数 + 点运算 + Set 方法三\nconst unique2 = (array) => {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    return [...new Set(arr)]\n}\n\n// ES6 Map + ES5 filter  方法四\nfunction unique3(array) {\n    if (!Array.isArray(array)) {\n      console.log('type error!')\n      return\n    }\n    const seen = new Map()\n    return array.filter((a) => !seen.has(a) && seen.set(a, 1))\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码三（indexOf + forEach）\n\n> 利用 indexOf 检测元素在新数组是否存在\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    const newArr = [];\n    array.forEach((el) => {\n      if (newArr.indexOf(el) === -1) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n### 代码四（indexOf + filter）\n\n> 利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等\n\n```\n// indexOf + forEach 利用indexOf检测元素在新数组是否存在\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n        console.log('type error!')\n        return\n    }\n    return array.filter((item, index) => {\n        return array.indexOf(item) === index;\n    });\n}\n\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **两个`NaN`都会被删除**\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol(1)`不去重\n\n**重点：**\n\n```\nconsole.log([NaN].indexOf(NaN)); // -1\n```\n\n## 代码五（sort 排序，不支持 Symbol）\n\n> sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序\n\n```\n// sort()方法不支持Symbol，Symbol不支持转换成字符串\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n    const sortArr = array.sort();\n    const newArr = [];\n    sortArr.forEach((el, i) => {\n      if (sortArr[i] !== sortArr[i - 1]) {\n        newArr.push(el);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]\n```\n\n**输出结果说明：**\n\n1. `+0`、`-0`、`0`、`\"0\"`位置不同会导致去重不了\n2. `NaN`不去重\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. **sort()方法不支持处理含有`Symbol`的数组**\n\n## 代码六（includes）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const newArr = [];\n    array.forEach((el) => {\n      newArr.includes(el) ? newArr : newArr.push(el);\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码七（includes+reduce）\n\n> 利用 includes()方法检查新数组是否包含原数组的每一项\n\n```\n// 利用includes()方法检查新数组是否包含原数组的每一项\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    return array.reduce((pre, cur) => {\n      !pre.includes(cur) && pre.push(cur);\n      return pre;\n    }, []);\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. 去重`NaN`\n3. 对象`new String(\"1\")`、`/a/`、`{}`不去重\n4. 数组`[]`不去重\n5. `Symbol`不去重\n\n## 代码八（对象 key）\n\n> 利用了对象的 key 不可以重复的特性来进行去重\n\n```\n// 利用了对象的key不可以重复的特性来进行去重\nfunction unique(array) {\n    if (!Array.isArray(array)) {\n      console.log(\"type error!\");\n      return;\n    }\n\n    const obj = {};\n    const newArr = [];\n    array.forEach((val) => {\n      if (!obj[typeof val + JSON.stringify(val)]) {\n        // 将对象序列化之后作为key来使用\n        obj[typeof val + JSON.stringify(val)] = 1;\n        newArr.push(val);\n      }\n    });\n    return newArr;\n}\n```\n\n**输出：**\n\n```\n[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]\n```\n\n**输出结果说明：**\n\n1. 去重`+0`、`-0`、`0`\n2. **去重`NaN`**\n3. **去重对象`new String(\"1\")`、`{}`;两个`/a/`全部被删除了**\n4. **去重数组`[]`**\n5. **去重`Symbol`**\n\n**将不该去重的`Symbol`去重了;将两个`/a/`全部删除了**\n\n## 总结\n\n| 方法                         | 结果                                                                                                                                                                                   | 说明                                                                                                                                                   |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **for 循环暴力解法**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **ES6 解法**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []`       | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **indexOf + forEach**        | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]` | 1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                             |\n| **indexOf + filter**         | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`           | 1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                    |\n| **sort 排序，不支持 Symbol** | `[[], [], /a/, /a/, 0, \"0\", 0, 1, \"1\", String {'1'}, String {'1'}, \"A\", NaN, NaN, {}, {}, \"a\", false, \"false\", null, \"null\", true, \"true\", \"undefined\", undefined]`                    | 1.+0、-0、0、\"0\"位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组； |\n| **includes**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **includes+reduce**          | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, String {'1'}, Symbol(1), Symbol(1), {}, {}, /a/, /a/, [], []]`      | 1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(\"1\")、/a/、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；                                               |\n| **对象 key**                 | `[1, '1', 0, '0', true, false, 'true', 'false', 'a', 'A', undefined, 'undefined', null, 'null', NaN, String {'1'}, Symbol(1), {}, []]`                                                 | 1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(\"1\")、{};两个/a/全部被删除了；4.去重数组[]；5.去重 Symbol                                          |\n\n上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/unique)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [解锁多种 JavaScript 数组去重姿势](https://juejin.cn/post/6844903608467587085)\n- [数组去重的六种方法](https://juejin.cn/post/6844903790257111054)\n- [7 种方法实现数组去重](https://juejin.cn/post/6844903602197102605)\n- [JavaScript 专题之数组去重\n  ](https://github.com/mqyqingfeng/Blog/issues/27)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之数组去重（结果对比）](https://github.com/yihan12/Blog/issues/5)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之数组去重（结果对比）","published":1,"updated":"2023-08-14T04:11:10.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwj0018m32v4hss4x4f","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组去重在面试和工作中都是比较容易见到的问题。</p>\n<p>这篇文章主要是来测试多个方法，对下面这个数组的去重结果进行分析讨论。如果有不对的地方，还请大家指出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [ 1, 1, &quot;1&quot;, &quot;1&quot;, 0, 0, &quot;0&quot;, &quot;0&quot;, true, false, &quot;true&quot;, &quot;false&quot;, &quot;a&quot;, &quot;A&quot;, undefined, undefined, &quot;undefined&quot;, null, null, &#x27;null&#x27;, NaN, NaN, +0, -0, new String(&quot;1&quot;), new String(&quot;1&quot;), Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], [] ];</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊类型\"><a href=\"#特殊类型\" class=\"headerlink\" title=\"特殊类型\"></a>特殊类型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 == &quot;1&quot;); // true</span><br><span class=\"line\">console.log(1 === &quot;1&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == &quot;0&quot;); // true</span><br><span class=\"line\">console.log(0 === &quot;0&quot;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == +0); // true</span><br><span class=\"line\">console.log(0 === +0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == -0); // true</span><br><span class=\"line\">console.log(0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(+0 == -0); // true</span><br><span class=\"line\">console.log(+0 === -0); // true</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == false); // true</span><br><span class=\"line\">console.log(0 === false); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == undefined); // false</span><br><span class=\"line\">console.log(0 === undefined); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(0 == null); // false</span><br><span class=\"line\">console.log(0 === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1 == true); // true</span><br><span class=\"line\">console.log(1 === true); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(undefined == null); // true</span><br><span class=\"line\">console.log(undefined === null); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(NaN == NaN); // false</span><br><span class=\"line\">console.log(NaN === NaN); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new String(&quot;1&quot;) == new String(&quot;1&quot;)); // false</span><br><span class=\"line\">console.log(new String(&quot;1&quot;) === new String(&quot;1&quot;)); // false</span><br><span class=\"line\">Object.prototype.toString.call(new String(&#x27;1&#x27;)) // &#x27;[object String]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(/a/ == /a/); // false</span><br><span class=\"line\">console.log(/a/ === /a/); // false</span><br><span class=\"line\">Object.prototype.toString.call(/a/); //&#x27;[object RegExp]&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Symbol(1) == Symbol(1)); // false</span><br><span class=\"line\">console.log(Symbol(1) === Symbol(1)); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#123;&#125; == &#123;&#125;); // false</span><br><span class=\"line\">console.log(&#123;&#125; === &#123;&#125;); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([] == []); // false</span><br><span class=\"line\">console.log([] === []); // false</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们看看下面多个去重方法，对以上特殊类型的去重效果。</p>\n<h2 id=\"代码一（暴力解法）\"><a href=\"#代码一（暴力解法）\" class=\"headerlink\" title=\"代码一（暴力解法）\"></a>代码一（暴力解法）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 暴力解法一</span><br><span class=\"line\"></span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const res = [array[0]];</span><br><span class=\"line\">    let arrLen = array.length;</span><br><span class=\"line\">    let resLen = res.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (let i = 0; i &lt; arrLen; i++) &#123;</span><br><span class=\"line\">      let flag = true;</span><br><span class=\"line\">      for (let j = 0; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">        if (array[i] === res[j]) &#123;</span><br><span class=\"line\">          flag = false;</span><br><span class=\"line\">          break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (flag) &#123;</span><br><span class=\"line\">        res.push(array[i]);</span><br><span class=\"line\">        resLen = res.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// [1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p>暴力解法，简单易理解，兼容性好。去重结果如上所示。</p>\n<h2 id=\"代码二（ES6）\"><a href=\"#代码二（ES6）\" class=\"headerlink\" title=\"代码二（ES6）\"></a>代码二（ES6）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6 Array.from + Set 方法一</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Array.from(new Set(array))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 点运算 + Set 方法二</span><br><span class=\"line\">function unique1(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 箭头函数 + 点运算 + Set 方法三</span><br><span class=\"line\">const unique2 = (array) =&gt; &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6 Map + ES5 filter  方法四</span><br><span class=\"line\">function unique3(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">      return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const seen = new Map()</span><br><span class=\"line\">    return array.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码三（indexOf-forEach）\"><a href=\"#代码三（indexOf-forEach）\" class=\"headerlink\" title=\"代码三（indexOf + forEach）\"></a>代码三（indexOf + forEach）</h3><blockquote>\n<p>利用 indexOf 检测元素在新数组是否存在</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      if (newArr.indexOf(el) === -1) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<h3 id=\"代码四（indexOf-filter）\"><a href=\"#代码四（indexOf-filter）\" class=\"headerlink\" title=\"代码四（indexOf + filter）\"></a>代码四（indexOf + filter）</h3><blockquote>\n<p>利用 indexOf 检测元素在数组中第一次出现的位置是否和元素现在的位置相等</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// indexOf + forEach 利用indexOf检测元素在新数组是否存在</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">        console.log(&#x27;type error!&#x27;)</span><br><span class=\"line\">        return</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return array.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        return array.indexOf(item) === index;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>两个<code>NaN</code>都会被删除</strong></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol(1)</code>不去重</li>\n</ol>\n<p><strong>重点：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([NaN].indexOf(NaN)); // -1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码五（sort-排序，不支持-Symbol）\"><a href=\"#代码五（sort-排序，不支持-Symbol）\" class=\"headerlink\" title=\"代码五（sort 排序，不支持 Symbol）\"></a>代码五（sort 排序，不支持 Symbol）</h2><blockquote>\n<p>sort()方法主要是用于对数组进行排序，默认情况下该方法是将数组元素转换成字符串，然后按照 ASC 码进行排序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// sort()方法不支持Symbol，Symbol不支持转换成字符串</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const sortArr = array.sort();</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    sortArr.forEach((el, i) =&gt; &#123;</span><br><span class=\"line\">      if (sortArr[i] !== sortArr[i - 1]) &#123;</span><br><span class=\"line\">        newArr.push(el);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li><code>+0</code>、<code>-0</code>、<code>0</code>、<code>&quot;0&quot;</code>位置不同会导致去重不了</li>\n<li><code>NaN</code>不去重</li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><strong>sort()方法不支持处理含有<code>Symbol</code>的数组</strong></li>\n</ol>\n<h2 id=\"代码六（includes）\"><a href=\"#代码六（includes）\" class=\"headerlink\" title=\"代码六（includes）\"></a>代码六（includes）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((el) =&gt; &#123;</span><br><span class=\"line\">      newArr.includes(el) ? newArr : newArr.push(el);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码七（includes-reduce）\"><a href=\"#代码七（includes-reduce）\" class=\"headerlink\" title=\"代码七（includes+reduce）\"></a>代码七（includes+reduce）</h2><blockquote>\n<p>利用 includes()方法检查新数组是否包含原数组的每一项</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用includes()方法检查新数组是否包含原数组的每一项</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return array.reduce((pre, cur) =&gt; &#123;</span><br><span class=\"line\">      !pre.includes(cur) &amp;&amp; pre.push(cur);</span><br><span class=\"line\">      return pre;</span><br><span class=\"line\">    &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, String &#123;&#x27;1&#x27;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li>去重<code>NaN</code></li>\n<li>对象<code>new String(&quot;1&quot;)</code>、<code>/a/</code>、<code>&#123;&#125;</code>不去重</li>\n<li>数组<code>[]</code>不去重</li>\n<li><code>Symbol</code>不去重</li>\n</ol>\n<h2 id=\"代码八（对象-key）\"><a href=\"#代码八（对象-key）\" class=\"headerlink\" title=\"代码八（对象 key）\"></a>代码八（对象 key）</h2><blockquote>\n<p>利用了对象的 key 不可以重复的特性来进行去重</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 利用了对象的key不可以重复的特性来进行去重</span><br><span class=\"line\">function unique(array) &#123;</span><br><span class=\"line\">    if (!Array.isArray(array)) &#123;</span><br><span class=\"line\">      console.log(&quot;type error!&quot;);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\">    const newArr = [];</span><br><span class=\"line\">    array.forEach((val) =&gt; &#123;</span><br><span class=\"line\">      if (!obj[typeof val + JSON.stringify(val)]) &#123;</span><br><span class=\"line\">        // 将对象序列化之后作为key来使用</span><br><span class=\"line\">        obj[typeof val + JSON.stringify(val)] = 1;</span><br><span class=\"line\">        newArr.push(val);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, &#x27;1&#x27;, 0, &#x27;0&#x27;, true, false, &#x27;true&#x27;, &#x27;false&#x27;, &#x27;a&#x27;, &#x27;A&#x27;, undefined, &#x27;undefined&#x27;, null, &#x27;null&#x27;, NaN, String &#123;&#x27;1&#x27;&#125;, Symbol(1), &#123;&#125;, []]</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果说明：</strong></p>\n<ol>\n<li>去重<code>+0</code>、<code>-0</code>、<code>0</code></li>\n<li><strong>去重<code>NaN</code></strong></li>\n<li><strong>去重对象<code>new String(&quot;1&quot;)</code>、<code>&#123;&#125;</code>;两个<code>/a/</code>全部被删除了</strong></li>\n<li><strong>去重数组<code>[]</code></strong></li>\n<li><strong>去重<code>Symbol</code></strong></li>\n</ol>\n<p><strong>将不该去重的<code>Symbol</code>去重了;将两个<code>/a/</code>全部删除了</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>结果</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>for 循环暴力解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>ES6 解法</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + forEach</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>indexOf + filter</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.两个 NaN 都会被删除；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>sort 排序，不支持 Symbol</strong></td>\n<td><code>[[], [], /a/, /a/, 0, &quot;0&quot;, 0, 1, &quot;1&quot;, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, &quot;A&quot;, NaN, NaN, &#123;&#125;, &#123;&#125;, &quot;a&quot;, false, &quot;false&quot;, null, &quot;null&quot;, true, &quot;true&quot;, &quot;undefined&quot;, undefined]</code></td>\n<td>1.+0、-0、0、”0”位置不同会导致去重不了 2.NaN 不去重；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.sort()方法不支持处理含有 Symbol 的数组；</td>\n</tr>\n<tr>\n<td><strong>includes</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>includes+reduce</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, String &#123;&#39;1&#39;&#125;, Symbol(1), Symbol(1), &#123;&#125;, &#123;&#125;, /a/, /a/, [], []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.对象 new String(“1”)、&#x2F;a&#x2F;、{}不去重；4.数组[]不去重；5.Symbol(1)不去重；</td>\n</tr>\n<tr>\n<td><strong>对象 key</strong></td>\n<td><code>[1, &#39;1&#39;, 0, &#39;0&#39;, true, false, &#39;true&#39;, &#39;false&#39;, &#39;a&#39;, &#39;A&#39;, undefined, &#39;undefined&#39;, null, &#39;null&#39;, NaN, String &#123;&#39;1&#39;&#125;, Symbol(1), &#123;&#125;, []]</code></td>\n<td>1.去重+0、-0、0； 2.去重 NaN；3.去重对象 new String(“1”)、{};两个&#x2F;a&#x2F;全部被删除了；4.去重数组[]；5.去重 Symbol</td>\n</tr>\n</tbody></table>\n<p>上面只是简单结果的去重总结，具体的去重选择还需要根据我们业务场景来选择去重方法。</p>\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/unique\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903608467587085\">解锁多种 JavaScript 数组去重姿势</a></li>\n<li><a href=\"https://juejin.cn/post/6844903790257111054\">数组去重的六种方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844903602197102605\">7 种方法实现数组去重</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\">JavaScript 专题之数组去重\n</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/5\">【跟着大佬学 JavaScript】之数组去重（结果对比）</a></p>\n"},{"title":"【跟着大佬学JavaScript】之防抖","date":"2022-07-08T12:04:06.597Z","_content":"\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之防抖\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 防抖]\n---\n\n## 前言\n\n在前端开发中会遇到一些频繁的事件触发，比如：\n\n1. window 的 resize、scroll\n2. mousedown、mousemove、mousewheel(鼠标滚轮)\n3. keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)  \n   ……\n\n想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。\n\n这就是为什么要使用防抖。\n\n## 原理\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗一点：定义 wait=2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。\n\n## 示例代码\n\n### 代码一(根据原理)\n\n定义函数 debounce  \n根据表述，我们可以知道需要传入参数：func、wait  \n实现代码：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout; // 定义定时器，wait秒后需要清除定时器\n    return function () {\n      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器\n      if (timeout) clearTimeout(timeout);\n\n      timeout = setTimeout(function () {\n        func();\n        clearTimeout(timeout)\n      }, wait);\n    };\n}\n```\n\n### 代码二(解决函数 this 指向)\n\n我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function () {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码三(解决函数 event 对象)\n\nJavaScript 在事件处理函数中会提供事件对象 event；  \n因此，也要考虑到保持原函数的 event 对象相同\n\n式一：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, args;\n    return function () {\n          context = this;\n          args = arguments;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n式二：\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context;\n    return function (...args) {\n          context = this;\n          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n          if (timeout) clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n                func.apply(context, args);\n                clearTimeout(timeout);\n          }, wait);\n    };\n}\n```\n\n### 代码四(函数返回值)\n\n此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。\n\n这里做出的处理，是将`func.apply(context, args)`单独拿出来，输出原函数的`result`。\n\n```\nfunction debounce(func, wait = 500) {\n    let timeout, context, result;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n\n        // 这里是不立即执行的原代码\n        timeout = setTimeout(function () {\n            clearTimeout(timeout);\n            return showResult(context, args); // 将this，arguments代入函数\n        }, wait);\n        return result;\n    };\n}\n```\n\n### 代码五(立刻执行)\n\n因为原理中，每次触发完后还需要等待 wait 秒执行。  \n但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    return function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n        // 这里是不立即执行的原代码\n            timeout = setTimeout(function () {\n                clearTimeout(timeout);\n                return showResult(context, args); // 将this，arguments代入函数\n            }, wait);\n        }\n        return result\n    };\n}\n```\n\n### 代码六(取消)\n\n增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。\n\n```\nfunction debounce(func, wait = 500, immediate = false) {\n    let timeout, context, result, callNow;\n\n    function showResult(e1, e2) {\n        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result\n        return result;\n    }\n\n    const debounced = function (...args) {\n        context = this;\n        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n            // 这里是立即执行的判断代码\n            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false\n            timeout = setTimeout(function () {\n                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;\n            }, wait);\n            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数\n        } else {\n            // 这里是不立即执行的原代码\n                timeout = setTimeout(function () {\n                    clearTimeout(timeout);\n                    return showResult(context, args); // 将this，arguments代入函数\n                }, wait);\n        }\n        return result\n    };\n\n    debounced.cancel = function () {\n        // 去除定时器，\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        // 将初始变量全部设置为undefined\n        timeout = context = result = callNow = undefined;\n    };\n    return debounced;\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出防抖函数 debounce](https://github.com/yygmind/blog/issues/39)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之防抖](https://github.com/yihan12/Blog/issues/1)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之防抖","published":1,"updated":"2023-08-14T04:12:31.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwk001cm32vd79n8hyk","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中会遇到一些频繁的事件触发，比如：</p>\n<ol>\n<li>window 的 resize、scroll</li>\n<li>mousedown、mousemove、mousewheel(鼠标滚轮)</li>\n<li>keyup(弹起键盘)、keydown(按下键盘)、keypress(按下字符键盘)<br>……</li>\n</ol>\n<p>想象一下窗口的 resize 事件或者是一个元素的 onmouseover 事件 - 他们触发时，执行的非常迅速，并且触发很多次。如果你的回调过重，你可能使浏览器死掉。</p>\n<p>这就是为什么要使用防抖。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗一点：定义 wait&#x3D;2000，持续点击按钮，前后点击间隔都在 2 秒内，则在最后一次点击按钮后，等待 2 秒再执行 func 方法。如果点击完按钮，2 秒后未再次点击按钮，则 2 秒后直接执行 func 方法。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><h3 id=\"代码一-根据原理\"><a href=\"#代码一-根据原理\" class=\"headerlink\" title=\"代码一(根据原理)\"></a>代码一(根据原理)</h3><p>定义函数 debounce<br>根据表述，我们可以知道需要传入参数：func、wait<br>实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout; // 定义定时器，wait秒后需要清除定时器</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">      // 如果再次触发函数时，已有timeout，则清空销毁当前timeout，再以新的事件重新设置定时器</span><br><span class=\"line\">      if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">      timeout = setTimeout(function () &#123;</span><br><span class=\"line\">        func();</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二-解决函数-this-指向\"><a href=\"#代码二-解决函数-this-指向\" class=\"headerlink\" title=\"代码二(解决函数 this 指向)\"></a>代码二(解决函数 this 指向)</h3><p>我们之前的原函数指向哪，如果使用我们的 debounce 函数包裹后，也要将 this 指向正确的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码三-解决函数-event-对象\"><a href=\"#代码三-解决函数-event-对象\" class=\"headerlink\" title=\"代码三(解决函数 event 对象)\"></a>代码三(解决函数 event 对象)</h3><p>JavaScript 在事件处理函数中会提供事件对象 event；<br>因此，也要考虑到保持原函数的 event 对象相同</p>\n<p>式一：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, args;</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          args = arguments;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>式二：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context;</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">          context = this;</span><br><span class=\"line\">          // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">          if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">          timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">          &#125;, wait);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码四-函数返回值\"><a href=\"#代码四-函数返回值\" class=\"headerlink\" title=\"代码四(函数返回值)\"></a>代码四(函数返回值)</h3><p>此时需要注意一个问题，就是我们在执行原函数时可能有返回值，我们需要处理 debounce 函数，在最后也要有相同返回值。</p>\n<p>这里做出的处理，是将<code>func.apply(context, args)</code>单独拿出来，输出原函数的<code>result</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500) &#123;</span><br><span class=\"line\">    let timeout, context, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">        timeout = setTimeout(function () &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">            return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码五-立刻执行\"><a href=\"#代码五-立刻执行\" class=\"headerlink\" title=\"代码五(立刻执行)\"></a>代码五(立刻执行)</h3><p>因为原理中，每次触发完后还需要等待 wait 秒执行。<br>但是某些场景，比如按钮点击后调用接口，会使整个时间变长，这时候就需要定义 immediate，点击按钮，立即执行调用接口，还要达到 wait 秒内防抖的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">        // 这里是不立即执行的原代码</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码六-取消\"><a href=\"#代码六-取消\" class=\"headerlink\" title=\"代码六(取消)\"></a>代码六(取消)</h3><p>增加取消防抖的方法：只需要定义 cancel 方法，去除定时器，将初始变量全部设置为 undefined。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait = 500, immediate = false) &#123;</span><br><span class=\"line\">    let timeout, context, result, callNow;</span><br><span class=\"line\"></span><br><span class=\"line\">    function showResult(e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2); // 绑定e1,e2的同时，输出result</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        // 如果再次触发函数时，已有timeout，则清空销毁timeout，在往下执行</span><br><span class=\"line\">        if (timeout) clearTimeout(timeout);</span><br><span class=\"line\">        if (immediate) &#123;</span><br><span class=\"line\">            // 这里是立即执行的判断代码</span><br><span class=\"line\">            callNow = !timeout; // timeout最开始定义为undefined，如果未设置定时器，则!timeout返回true;否则返回false</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null; // 这里时定时器走完，让timeout为null，则上一步!timeout依然返回true;</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">            if (callNow) return showResult(context, args); //刚进入timeout=undefined以及，wait时间走完timeout = null，两种情况都会立即执行函数</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // 这里是不立即执行的原代码</span><br><span class=\"line\">                timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                    clearTimeout(timeout);</span><br><span class=\"line\">                    return showResult(context, args); // 将this，arguments代入函数</span><br><span class=\"line\">                &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = function () &#123;</span><br><span class=\"line\">        // 去除定时器，</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将初始变量全部设置为undefined</span><br><span class=\"line\">        timeout = context = result = callNow = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/39\">深入浅出防抖函数 debounce</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/1\">【跟着大佬学 JavaScript】之防抖</a></p>\n"},{"title":"【跟着大佬学JavaScript】之节流","date":"2022-07-08T16:07:09.822Z","_content":"\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之节流\ndate:\ntags: [JavaScript]\ncategories: [前端, JavaScript, JavaScript深入理解, 节流]\n---\n\n## 前言\n\njs 的典型的场景\n\n- 监听页面的 scroll 事件\n- 拖拽事件\n- 监听鼠标的 mousemove 事件  \n  ...\n\n这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。\n\n## 原理\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 实现方式\n\n目前比较主流的实现方式有两种：时间戳、定时器。\n\n### 时间戳实现\n\n使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous = now）。\n\n由于首次 previous = 0，则此时函数第一次触发就会立即执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。\n\n```\n// 由于一开始now - 0 > wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件\nfunction throttle(func, wait = 500) {\n    let context, now;\n    let previous = 0; // 设置过去的执行时间初始值为0\n    return function (...args) {\n        context = this;\n        now = +(Date.now() || new Date().getTime());\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    };\n}\n```\n\n### 定时器实现\n\n使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。\n\n由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。\n\n后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。\n\n```\n// 由于一进入就创建了定时器，所以不会立即触发函数执行\nfunction throttle(func, wait = 500) {\n    let context, timeout;\n\n    return function (...args) {\n        context = this;\n\n        if (!timeout) {\n            timeout = setTimeout(function () {\n                timeout = null;\n                func.apply(context, args);\n            }, wait);\n        }\n    };\n}\n```\n\n### 合并版本\n\n如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。\n\n下面，我们将定时器和时间戳合并，组成一个全新的节流版本。\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n    return throttled;\n}\n```\n\n### 合并版本优化\n\n由于合并后的版本并没用返回值的优化+取消功能。\n\n下面对代码进行返回值+取消功能优化：\n\n```\nfunction throttle(func, wait = 500) {\n    let context, timeout, result;\n    let previous = 0;\n\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = +(Date.now() || new Date().getTime()); // 当前时间\n        // 下次触发 func 剩余时间\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        retrun result\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n### 功能性优化\n\n有时候，我们也希望无头有尾，或者有头无尾。\n\n```\nfunction throttle(func, wait = 500, options = {}) {\n    let context, timeout, result;\n    let previous = 0;\n\n   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\n    if (!(options.leading === false && options.trailing === false)) {\n        leading = !!options.leading; // 默认去除立即执行部分\n        trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n    }\n\n    // 返回原函数的return\n    const showResult = function (e1, e2) {\n        result = func.apply(e1, e2);\n        return result;\n    };\n\n    // 获取当前时间\n    const getNow = function () {\n        return +(Date.now() || new Date().getTime());\n    };\n\n    const throttled = function (...args) {\n        context = this;\n        const now = getNow(); // 当前时间\n        // 下次触发 func 剩余时间\n        if (!previous && leading === false) previous = now;\n        const remaining = wait - (now - previous);\n\n        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            return showResult(context, args);\n        } else if (!timeout && trailing !== false) {\n            // 剩余的情况就是remaining<=wait的情况，这里使用setTimeout就可以最后也会执行一次\n            timeout = setTimeout(function () {\n                timeout = null;\n                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n                return showResult(context, args);\n            }, remaining);\n        }\n        return result;\n    };\n\n    throttled.cancel = function () {\n        if (timeout !== undefined) {\n            clearTimeout(timeout);\n        }\n        previous = 0;\n        context = timeout = result = undefined;\n    };\n    return throttled;\n}\n```\n\n这里，如果 options 不传参数，函数默认设置\n\n```\nlet leading = false\nlet trailing = true\n```\n\n也就是无头有尾。\n\n如果同时设置无头无尾，则会直接采用默认设置，无头有尾。\n\n```\n// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作\nif (!(options.leading === false && options.trailing === false)) {\n    leading = !!options.leading; // 默认去除立即执行部分\n    trailing = \"trailing\" in options ? !!options.trailing : true; // 默认保留尾部\n}\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/throttle)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [JavaScript 专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)\n- [underscore.js](https://underscorejs.net/docs/underscore.html)\n- [深入浅出节流函数 throttle](https://github.com/yygmind/blog/issues/38)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之节流](https://github.com/yihan12/Blog/issues/2)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之节流","published":1,"updated":"2023-08-14T04:11:58.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwk001em32v2o373t03","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>js 的典型的场景</p>\n<ul>\n<li>监听页面的 scroll 事件</li>\n<li>拖拽事件</li>\n<li>监听鼠标的 mousemove 事件<br>…</li>\n</ul>\n<p>这些事件会频繁触发会影响性能，如果使用节流，降低频次，保留了用户体验，又提升了执行速度，节省资源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><p>目前比较主流的实现方式有两种：时间戳、定时器。</p>\n<h3 id=\"时间戳实现\"><a href=\"#时间戳实现\" class=\"headerlink\" title=\"时间戳实现\"></a>时间戳实现</h3><p>使用时间戳实现：首先初始化执行事件的时间 previous 为 0，然后将当前的时间戳减去上次执行时间（now - previous），如果大于 wait，则直接执行函数，并且将此时的执行时间 now 赋给 previous（previous &#x3D; now）。</p>\n<p>由于首次 previous &#x3D; 0，则此时函数第一次触发就会立即执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，则不会再执行函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一开始now - 0 &gt; wait，则这个写法，时间会立即执行，没过一秒会执行一次，停止触发，则不会再执行事件</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, now;</span><br><span class=\"line\">    let previous = 0; // 设置过去的执行时间初始值为0</span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        now = +(Date.now() || new Date().getTime());</span><br><span class=\"line\">        if (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器实现\"><a href=\"#定时器实现\" class=\"headerlink\" title=\"定时器实现\"></a>定时器实现</h3><p>使用定时器实现：首先初始化 timeout，然后定义!timeout 为 true 的情况下，直接执行 setTimeout，，等待 wait 时间后执行函数，然后清空 timeout，以此类推，重新进入也会按上述执行。</p>\n<p>由于进入函数，就执行 setTimeout，所以不会立即触发函数执行。</p>\n<p>后续则每隔 wait 时间执行一次，如果停止触发，而后还会触发执行一次函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 由于一进入就创建了定时器，所以不会立即触发函数执行</span><br><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    return function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, wait);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本\"><a href=\"#合并版本\" class=\"headerlink\" title=\"合并版本\"></a>合并版本</h3><p>如果，我们需要既刚开始就立即执行，停止触发后，还会触发执行一次函数。</p>\n<p>下面，我们将定时器和时间戳合并，组成一个全新的节流版本。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并版本优化\"><a href=\"#合并版本优化\" class=\"headerlink\" title=\"合并版本优化\"></a>合并版本优化</h3><p>由于合并后的版本并没用返回值的优化+取消功能。</p>\n<p>下面对代码进行返回值+取消功能优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = +(Date.now() || new Date().getTime()); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = +(Date.now() || new Date().getTime()); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        retrun result</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"功能性优化\"><a href=\"#功能性优化\" class=\"headerlink\" title=\"功能性优化\"></a>功能性优化</h3><p>有时候，我们也希望无头有尾，或者有头无尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(func, wait = 500, options = &#123;&#125;) &#123;</span><br><span class=\"line\">    let context, timeout, result;</span><br><span class=\"line\">    let previous = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">   // 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">    if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">        leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">        trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 返回原函数的return</span><br><span class=\"line\">    const showResult = function (e1, e2) &#123;</span><br><span class=\"line\">        result = func.apply(e1, e2);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 获取当前时间</span><br><span class=\"line\">    const getNow = function () &#123;</span><br><span class=\"line\">        return +(Date.now() || new Date().getTime());</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    const throttled = function (...args) &#123;</span><br><span class=\"line\">        context = this;</span><br><span class=\"line\">        const now = getNow(); // 当前时间</span><br><span class=\"line\">        // 下次触发 func 剩余时间</span><br><span class=\"line\">        if (!previous &amp;&amp; leading === false) previous = now;</span><br><span class=\"line\">        const remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有剩余时间或者改了系统时间,这时候不需要等待，直接立即执行，这样就会第一次就执行</span><br><span class=\"line\">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class=\"line\">            if (timeout) &#123;</span><br><span class=\"line\">                clearTimeout(timeout);</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">            return showResult(context, args);</span><br><span class=\"line\">        &#125; else if (!timeout &amp;&amp; trailing !== false) &#123;</span><br><span class=\"line\">            // 剩余的情况就是remaining&lt;=wait的情况，这里使用setTimeout就可以最后也会执行一次</span><br><span class=\"line\">            timeout = setTimeout(function () &#123;</span><br><span class=\"line\">                timeout = null;</span><br><span class=\"line\">                previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">                return showResult(context, args);</span><br><span class=\"line\">            &#125;, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    throttled.cancel = function () &#123;</span><br><span class=\"line\">        if (timeout !== undefined) &#123;</span><br><span class=\"line\">            clearTimeout(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = 0;</span><br><span class=\"line\">        context = timeout = result = undefined;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里，如果 options 不传参数，函数默认设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let leading = false</span><br><span class=\"line\">let trailing = true</span><br></pre></td></tr></table></figure>\n\n<p>也就是无头有尾。</p>\n<p>如果同时设置无头无尾，则会直接采用默认设置，无头有尾。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果同时设置无头无尾，则直接使用默认设置,其他情况，则走下述操作</span><br><span class=\"line\">if (!(options.leading === false &amp;&amp; options.trailing === false)) &#123;</span><br><span class=\"line\">    leading = !!options.leading; // 默认去除立即执行部分</span><br><span class=\"line\">    trailing = &quot;trailing&quot; in options ? !!options.trailing : true; // 默认保留尾部</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/throttle\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></li>\n<li><a href=\"https://underscorejs.net/docs/underscore.html\">underscore.js</a></li>\n<li><a href=\"https://github.com/yygmind/blog/issues/38\">深入浅出节流函数 throttle</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/2\">【跟着大佬学 JavaScript】之节流</a></p>\n"},{"title":"【源码剖析】$mount挂载","date":"2023-09-08T01:40:41.316Z","_content":"\n### 说明\n\n- 从`new Vue`这个过程最后，`vm.$mount(vm.$options.el)`可以看到 el 挂载。这一章将研究这一过程。具体分析 vue 如何将组件挂载到页面成为真实 Dom 的。\n\n这是`new Vue`过程的代码\n\n```javascript\nif (vm.$options.el) {\n  // 挂载el\n  vm.$mount(vm.$options.el)\n}\n```\n\n### 代码剖析\n\n看了很多相关文章，大部分文章并没有讲述为啥要先分析 compiler 版本代码`$mount`，再去分析 runtime-only 版本的代码上的`$mount`。所有一开始就会有点懵，为啥要这么去分析。\n\n> /src/platforms/web/entry-runtime-with-compiler.js\n\n```javascript\n// 最开始通过mount获取并缓存了Vue原型上的$mount方法，然后又重新定义了Vue.prototype.$mount\n// 执行到到最后，通过return mount.call(this, el, hydrating) 重新调用mount缓存下来的原型方法。\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 使用query来获取要挂载DOM元素节点\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  // 判断el是否为body，或者document，如果是则返回，因为本身index.html已经含有html,body元素\n  // 如果el是body或者文档标签，会替换原本的html和body.\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' &&\n      warn(\n        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n      )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  /*处理模板templete，编译成render函数，render不存在的时候才会编译template，否则优先使用render*/\n  // 判断options中是否有render方法，有则直接调用mount方法，\n  // 如果没有render，则需要调用compileToFunctions生成render再调用mount方法\n  if (!options.render) {\n    /*template存在的时候取template，不存在的时候取el的outerHTML*/\n    let template = options.template\n    // 会判断有没有写template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        /*当template为DOM节点的时候*/\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      //\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n\n      const { render, staticRenderFns } = compileToFunctions(\n        template,\n        {\n          outputSourceRange: process.env.NODE_ENV !== 'production',\n          shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments,\n        },\n        this\n      )\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  // 执行runtime-only版本的$mounted\n  return mount.call(this, el, hydrating)\n}\n```\n\n通过这部分代码可以看出：\n\n1. 一开始通过定义`mount`缓存了 Vue 原型上原始的`$mount`方法`const mount = Vue.prototype.$mount`；\n2. 然后又重新定义了`Vue.prototype.$mount`方法。\n3. 执行到最后，又重新调用缓存的原始`Vue.prototype.$mount`方法`return mount.call(this, el, hydrating)`,这时候就会执行到`runtime/index`的`$mount`方法。\n4. 其中有一部分是判断内部有无`render`函数，若无则通过`compileToFunctions`方法生成 render 再调用 mount 方法.若无则直接执行`return mount.call(this, el, hydrating)`\n\n那么 entry-runtime-with-compiler.js 文件中的`$mount`到底干了些什么呢。\n\n先分析`query(el)`做了些什么\n\n> /src/platforms/web/util/index.js\n\n```javascript\nexport function query(el: string | Element): Element {\n  if (typeof el === 'string') {\n    // 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象\n    const selected = document.querySelector(el)\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' &&\n        warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    // 如果是Element对象（Dom对象），就直接返回\n    return el\n  }\n}\n```\n\n这段代码比较简单：\n\n1. 判断`el`是字符串，就从页面中找到该 DOM 对象。\n2. 如果未找到就报错。\n3. 如果`el`不是字符串就直接返回 el DOM 对象，因为`$mount`可以直接接收一个 DOM 元素,可以像这么写：\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount(document.querySelector('#app'))\n```\n\n我们平时在 main.js 入口文件中，也会这么去写\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app')\n```\n\n`el = el&&query(el)`就是处理上述两种写法。\n\n`query`方法获取到 DOM 元素后，往下走，判断 el 元素如果是 body 或者 document,就报错 并且 return。\n因为 index.html 里已经有了 html 和 body。\n\n```javascript\nif (el === document.body || el === document.documentElement) {\n  process.env.NODE_ENV !== 'production' &&\n    warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n  return this\n}\n```\n\n1. `el = el&&query(el)`,此操作是获取到我们定义的 DOM 节点，`'#app'`或`document.querySelector('#app')`;\n2. 判断`options`中是否含有 `render` 方法。如果我们直接手写`render`函数,就会直接执行`return mount.call(this, el, hydrating)`然后就回去执行之前缓存的原型方法。\n3. 如果没有`render`方法.会将`template`做为参数，运行时调用`compileToFunctions`方法，转化为`render`函数，再去调用`mount.call`方法。\n\n然后执行到 mount 变量缓存的 runtime-only 版本的`$mount`方法\n\n> /src/platforms/web/runtime/index.js\n\n```javascript\nVue.prototype.$mount = function (\n  el?: string | Element, //el可以是string，也可以是Element\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined // 这里el就已经是DOM对象（query(el)处理后）\n  return mountComponent(this, el, hydrating)\n}\n```\n\n其实这一段很简单，\n\n1. 主要是确定了`Vue.prototype.$mount`传参的类型，el 可以传字符串，比如我们平时的\"app\"。或者直接传 DOM 对象。\n2. 然后则是将 el 通过`query(el)`将字符串形式的 el 返回成 DOM 对象。\n3. 其中的`inBrower`主要是判断是否浏览器环境，判断是否有`window`对象：`export const inBrowser = typeof window !== 'undefined'`\n4. 最后就是最重要的`mountComponent(this, el, hydrating)`执行\n\n接下来先分析`query(el)`做了些什么\n\n> /src/platforms/web/util/index.js\n\n```javascript\nexport function query(el: string | Element): Element {\n  if (typeof el === 'string') {\n    // 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象\n    const selected = document.querySelector(el)\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' &&\n        warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    // 如果是Element对象（Dom对象），就直接返回\n    return el\n  }\n}\n```\n\n这段代码比较简单：\n\n1. 判断`el`是字符串，就从页面中找到该 DOM 对象。\n2. 如果未找到就报错。\n3. 如果`el`不是字符串就直接返回 el DOM 对象。\n\n最后我们来分析最重要的这部分代码\n\n> /src/core/instance/lifecycle.js\n\n```javascript\nexport function mountComponent(\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el // 把el用vm.$el做缓存\n\n  // 如果此时还是没有render方法，那就要抛出错误提示\n  if (!vm.$options.render) {\n    // 判断是否有render函数，如果没有写render函数，并且template未转换成render函数。就创建一个空的VNode\n    vm.$options.render = createEmptyVNode\n    // 下面这部分分是：如果你没有用template，又没写render函数，在开发环境就会报此警告\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (\n        (vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el ||\n        el\n      ) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount') //beforeMount\n\n  let updateComponent //构建updateComponent方法，更新组件需要用到\n  //  和性能埋点相关的\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      // 主要是执行渲染Watcher\n      // vm._render()生成VNode，然后调_update,把它传入\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  // 渲染Watcher\n  new Watcher(\n    vm,\n    updateComponent,\n    noop, // 空function\n    {\n      before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate')\n        }\n      },\n    },\n    true /* isRenderWatcher */\n  )\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  // 手动挂载实例\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n1. 首先判断`render`函数是否已经构建好，如果为构建好久报错;\n2. 如果为报错就构建`updateComponent`方法，这个方法每次更新组件的时候就会调这个方法；\n3. 然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式\n4. 最后手动挂载实例。\n\n### 总结\n\n1. 是否 compile 版本，判断先执行那一部分代码。\n2. entry-runtime-with-compiler.js 会去判断是否有 render 函数，如果有就执行`return mount.call(this, el, hydrating)`然后就回去执行之前缓存的原型方法. 如果没有`render`方法.会将`template`做为参数，运行时调用`compileToFunctions`方法，转化为`render`函数，再去调用`return mount.call(this, el, hydrating)`方法。\n3. 然后到了 runtime-only 版本的 mount。首先判断`render`函数是否已经构建好，如果为构建好久报错；如果为报错就构建`updateComponent`方法，这个方法每次更新组件的时候就会调这个方法；\n4. 然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式\n5. 最后手动挂载实例。\n\n**下一章：**[【源码剖析】render 的实现](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91render%E7%9A%84%E5%AE%9E%E7%8E%B0.md)  \n**本章：** [【源码剖析】$mount 挂载](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%24mount%E6%8C%82%E8%BD%BD.md)  \n**上一章：** [【源码剖析】initState 初始化](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md)\n","source":"_posts/Vue/Vue2源码分析/【源码剖析】$mount挂载.md","raw":"---\ntitle: 【源码剖析】$mount挂载\ndate:\ntags: [Vue, 源码剖析]\ncategories: [前端, Vue, Vue2源码剖析]\n---\n\n### 说明\n\n- 从`new Vue`这个过程最后，`vm.$mount(vm.$options.el)`可以看到 el 挂载。这一章将研究这一过程。具体分析 vue 如何将组件挂载到页面成为真实 Dom 的。\n\n这是`new Vue`过程的代码\n\n```javascript\nif (vm.$options.el) {\n  // 挂载el\n  vm.$mount(vm.$options.el)\n}\n```\n\n### 代码剖析\n\n看了很多相关文章，大部分文章并没有讲述为啥要先分析 compiler 版本代码`$mount`，再去分析 runtime-only 版本的代码上的`$mount`。所有一开始就会有点懵，为啥要这么去分析。\n\n> /src/platforms/web/entry-runtime-with-compiler.js\n\n```javascript\n// 最开始通过mount获取并缓存了Vue原型上的$mount方法，然后又重新定义了Vue.prototype.$mount\n// 执行到到最后，通过return mount.call(this, el, hydrating) 重新调用mount缓存下来的原型方法。\nconst mount = Vue.prototype.$mount\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 使用query来获取要挂载DOM元素节点\n  el = el && query(el)\n\n  /* istanbul ignore if */\n  // 判断el是否为body，或者document，如果是则返回，因为本身index.html已经含有html,body元素\n  // 如果el是body或者文档标签，会替换原本的html和body.\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' &&\n      warn(\n        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n      )\n    return this\n  }\n\n  const options = this.$options\n  // resolve template/el and convert to render function\n  /*处理模板templete，编译成render函数，render不存在的时候才会编译template，否则优先使用render*/\n  // 判断options中是否有render方法，有则直接调用mount方法，\n  // 如果没有render，则需要调用compileToFunctions生成render再调用mount方法\n  if (!options.render) {\n    /*template存在的时候取template，不存在的时候取el的outerHTML*/\n    let template = options.template\n    // 会判断有没有写template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        /*当template为DOM节点的时候*/\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      //\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile')\n      }\n\n      const { render, staticRenderFns } = compileToFunctions(\n        template,\n        {\n          outputSourceRange: process.env.NODE_ENV !== 'production',\n          shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments,\n        },\n        this\n      )\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end')\n        measure(`vue ${this._name} compile`, 'compile', 'compile end')\n      }\n    }\n  }\n  // 执行runtime-only版本的$mounted\n  return mount.call(this, el, hydrating)\n}\n```\n\n通过这部分代码可以看出：\n\n1. 一开始通过定义`mount`缓存了 Vue 原型上原始的`$mount`方法`const mount = Vue.prototype.$mount`；\n2. 然后又重新定义了`Vue.prototype.$mount`方法。\n3. 执行到最后，又重新调用缓存的原始`Vue.prototype.$mount`方法`return mount.call(this, el, hydrating)`,这时候就会执行到`runtime/index`的`$mount`方法。\n4. 其中有一部分是判断内部有无`render`函数，若无则通过`compileToFunctions`方法生成 render 再调用 mount 方法.若无则直接执行`return mount.call(this, el, hydrating)`\n\n那么 entry-runtime-with-compiler.js 文件中的`$mount`到底干了些什么呢。\n\n先分析`query(el)`做了些什么\n\n> /src/platforms/web/util/index.js\n\n```javascript\nexport function query(el: string | Element): Element {\n  if (typeof el === 'string') {\n    // 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象\n    const selected = document.querySelector(el)\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' &&\n        warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    // 如果是Element对象（Dom对象），就直接返回\n    return el\n  }\n}\n```\n\n这段代码比较简单：\n\n1. 判断`el`是字符串，就从页面中找到该 DOM 对象。\n2. 如果未找到就报错。\n3. 如果`el`不是字符串就直接返回 el DOM 对象，因为`$mount`可以直接接收一个 DOM 元素,可以像这么写：\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount(document.querySelector('#app'))\n```\n\n我们平时在 main.js 入口文件中，也会这么去写\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nnew Vue({\n  render: (h) => h(App),\n}).$mount('#app')\n```\n\n`el = el&&query(el)`就是处理上述两种写法。\n\n`query`方法获取到 DOM 元素后，往下走，判断 el 元素如果是 body 或者 document,就报错 并且 return。\n因为 index.html 里已经有了 html 和 body。\n\n```javascript\nif (el === document.body || el === document.documentElement) {\n  process.env.NODE_ENV !== 'production' &&\n    warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n  return this\n}\n```\n\n1. `el = el&&query(el)`,此操作是获取到我们定义的 DOM 节点，`'#app'`或`document.querySelector('#app')`;\n2. 判断`options`中是否含有 `render` 方法。如果我们直接手写`render`函数,就会直接执行`return mount.call(this, el, hydrating)`然后就回去执行之前缓存的原型方法。\n3. 如果没有`render`方法.会将`template`做为参数，运行时调用`compileToFunctions`方法，转化为`render`函数，再去调用`mount.call`方法。\n\n然后执行到 mount 变量缓存的 runtime-only 版本的`$mount`方法\n\n> /src/platforms/web/runtime/index.js\n\n```javascript\nVue.prototype.$mount = function (\n  el?: string | Element, //el可以是string，也可以是Element\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined // 这里el就已经是DOM对象（query(el)处理后）\n  return mountComponent(this, el, hydrating)\n}\n```\n\n其实这一段很简单，\n\n1. 主要是确定了`Vue.prototype.$mount`传参的类型，el 可以传字符串，比如我们平时的\"app\"。或者直接传 DOM 对象。\n2. 然后则是将 el 通过`query(el)`将字符串形式的 el 返回成 DOM 对象。\n3. 其中的`inBrower`主要是判断是否浏览器环境，判断是否有`window`对象：`export const inBrowser = typeof window !== 'undefined'`\n4. 最后就是最重要的`mountComponent(this, el, hydrating)`执行\n\n接下来先分析`query(el)`做了些什么\n\n> /src/platforms/web/util/index.js\n\n```javascript\nexport function query(el: string | Element): Element {\n  if (typeof el === 'string') {\n    // 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象\n    const selected = document.querySelector(el)\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' &&\n        warn('Cannot find element: ' + el)\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    // 如果是Element对象（Dom对象），就直接返回\n    return el\n  }\n}\n```\n\n这段代码比较简单：\n\n1. 判断`el`是字符串，就从页面中找到该 DOM 对象。\n2. 如果未找到就报错。\n3. 如果`el`不是字符串就直接返回 el DOM 对象。\n\n最后我们来分析最重要的这部分代码\n\n> /src/core/instance/lifecycle.js\n\n```javascript\nexport function mountComponent(\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  vm.$el = el // 把el用vm.$el做缓存\n\n  // 如果此时还是没有render方法，那就要抛出错误提示\n  if (!vm.$options.render) {\n    // 判断是否有render函数，如果没有写render函数，并且template未转换成render函数。就创建一个空的VNode\n    vm.$options.render = createEmptyVNode\n    // 下面这部分分是：如果你没有用template，又没写render函数，在开发环境就会报此警告\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (\n        (vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el ||\n        el\n      ) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n          vm\n        )\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        )\n      }\n    }\n  }\n  callHook(vm, 'beforeMount') //beforeMount\n\n  let updateComponent //构建updateComponent方法，更新组件需要用到\n  //  和性能埋点相关的\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = () => {\n      const name = vm._name\n      const id = vm._uid\n      const startTag = `vue-perf-start:${id}`\n      const endTag = `vue-perf-end:${id}`\n\n      mark(startTag)\n      const vnode = vm._render()\n      mark(endTag)\n      measure(`vue ${name} render`, startTag, endTag)\n\n      mark(startTag)\n      vm._update(vnode, hydrating)\n      mark(endTag)\n      measure(`vue ${name} patch`, startTag, endTag)\n    }\n  } else {\n    updateComponent = () => {\n      // 主要是执行渲染Watcher\n      // vm._render()生成VNode，然后调_update,把它传入\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  // 渲染Watcher\n  new Watcher(\n    vm,\n    updateComponent,\n    noop, // 空function\n    {\n      before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate')\n        }\n      },\n    },\n    true /* isRenderWatcher */\n  )\n  hydrating = false\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  // 手动挂载实例\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, 'mounted')\n  }\n  return vm\n}\n```\n\n1. 首先判断`render`函数是否已经构建好，如果为构建好久报错;\n2. 如果为报错就构建`updateComponent`方法，这个方法每次更新组件的时候就会调这个方法；\n3. 然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式\n4. 最后手动挂载实例。\n\n### 总结\n\n1. 是否 compile 版本，判断先执行那一部分代码。\n2. entry-runtime-with-compiler.js 会去判断是否有 render 函数，如果有就执行`return mount.call(this, el, hydrating)`然后就回去执行之前缓存的原型方法. 如果没有`render`方法.会将`template`做为参数，运行时调用`compileToFunctions`方法，转化为`render`函数，再去调用`return mount.call(this, el, hydrating)`方法。\n3. 然后到了 runtime-only 版本的 mount。首先判断`render`函数是否已经构建好，如果为构建好久报错；如果为报错就构建`updateComponent`方法，这个方法每次更新组件的时候就会调这个方法；\n4. 然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式\n5. 最后手动挂载实例。\n\n**下一章：**[【源码剖析】render 的实现](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91render%E7%9A%84%E5%AE%9E%E7%8E%B0.md)  \n**本章：** [【源码剖析】$mount 挂载](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%24mount%E6%8C%82%E8%BD%BD.md)  \n**上一章：** [【源码剖析】initState 初始化](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md)\n","slug":"Vue/Vue2源码分析/【源码剖析】$mount挂载","published":1,"updated":"2023-09-08T01:41:39.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwl001im32v2hsqeyi5","content":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ul>\n<li>从<code>new Vue</code>这个过程最后，<code>vm.$mount(vm.$options.el)</code>可以看到 el 挂载。这一章将研究这一过程。具体分析 vue 如何将组件挂载到页面成为真实 Dom 的。</li>\n</ul>\n<p>这是<code>new Vue</code>过程的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 挂载el</span></span><br><span class=\"line\">  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码剖析\"><a href=\"#代码剖析\" class=\"headerlink\" title=\"代码剖析\"></a>代码剖析</h3><p>看了很多相关文章，大部分文章并没有讲述为啥要先分析 compiler 版本代码<code>$mount</code>，再去分析 runtime-only 版本的代码上的<code>$mount</code>。所有一开始就会有点懵，为啥要这么去分析。</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最开始通过mount获取并缓存了Vue原型上的$mount方法，然后又重新定义了Vue.prototype.$mount</span></span><br><span class=\"line\"><span class=\"comment\">// 执行到到最后，通过return mount.call(this, el, hydrating) 重新调用mount缓存下来的原型方法。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mount = <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  el?: string | Element,</span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用query来获取要挂载DOM元素节点</span></span><br><span class=\"line\">  el = el &amp;&amp; <span class=\"title function_\">query</span>(el)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断el是否为body，或者document，如果是则返回，因为本身index.html已经含有html,body元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果el是body或者文档标签，会替换原本的html和body.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (el === <span class=\"variable language_\">document</span>.<span class=\"property\">body</span> || el === <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>) &#123;</span><br><span class=\"line\">    process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">        <span class=\"string\">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"variable language_\">this</span>.<span class=\"property\">$options</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve template/el and convert to render function</span></span><br><span class=\"line\">  <span class=\"comment\">/*处理模板templete，编译成render函数，render不存在的时候才会编译template，否则优先使用render*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断options中是否有render方法，有则直接调用mount方法，</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果没有render，则需要调用compileToFunctions生成render再调用mount方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*template存在的时候取template，不存在的时候取el的outerHTML*/</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = options.<span class=\"property\">template</span></span><br><span class=\"line\">    <span class=\"comment\">// 会判断有没有写template</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> template === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (template.<span class=\"title function_\">charAt</span>(<span class=\"number\">0</span>) === <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">          template = <span class=\"title function_\">idToTemplate</span>(template)</span><br><span class=\"line\">          <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">              <span class=\"string\">`Template element not found or is empty: <span class=\"subst\">$&#123;options.template&#125;</span>`</span>,</span><br><span class=\"line\">              <span class=\"variable language_\">this</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (template.<span class=\"property\">nodeType</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*当template为DOM节点的时候*/</span></span><br><span class=\"line\">        template = template.<span class=\"property\">innerHTML</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;invalid template option:&#x27;</span> + template, <span class=\"variable language_\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//</span></span><br><span class=\"line\">      template = <span class=\"title function_\">getOuterHTML</span>(el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">mark</span>(<span class=\"string\">&#x27;compile&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = <span class=\"title function_\">compileToFunctions</span>(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">outputSourceRange</span>: process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>,</span><br><span class=\"line\">          shouldDecodeNewlines,</span><br><span class=\"line\">          shouldDecodeNewlinesForHref,</span><br><span class=\"line\">          <span class=\"attr\">delimiters</span>: options.<span class=\"property\">delimiters</span>,</span><br><span class=\"line\">          <span class=\"attr\">comments</span>: options.<span class=\"property\">comments</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">      options.<span class=\"property\">render</span> = render</span><br><span class=\"line\">      options.<span class=\"property\">staticRenderFns</span> = staticRenderFns</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">mark</span>(<span class=\"string\">&#x27;compile end&#x27;</span>)</span><br><span class=\"line\">        <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> compile`</span>, <span class=\"string\">&#x27;compile&#x27;</span>, <span class=\"string\">&#x27;compile end&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行runtime-only版本的$mounted</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> mount.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, el, hydrating)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这部分代码可以看出：</p>\n<ol>\n<li>一开始通过定义<code>mount</code>缓存了 Vue 原型上原始的<code>$mount</code>方法<code>const mount = Vue.prototype.$mount</code>；</li>\n<li>然后又重新定义了<code>Vue.prototype.$mount</code>方法。</li>\n<li>执行到最后，又重新调用缓存的原始<code>Vue.prototype.$mount</code>方法<code>return mount.call(this, el, hydrating)</code>,这时候就会执行到<code>runtime/index</code>的<code>$mount</code>方法。</li>\n<li>其中有一部分是判断内部有无<code>render</code>函数，若无则通过<code>compileToFunctions</code>方法生成 render 再调用 mount 方法.若无则直接执行<code>return mount.call(this, el, hydrating)</code></li>\n</ol>\n<p>那么 entry-runtime-with-compiler.js 文件中的<code>$mount</code>到底干了些什么呢。</p>\n<p>先分析<code>query(el)</code>做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;util&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">query</span>(<span class=\"params\">el: string | Element</span>): <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> el === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> selected = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(el)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Cannot find element: &#x27;</span> + el)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selected</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是Element对象（Dom对象），就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> el</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单：</p>\n<ol>\n<li>判断<code>el</code>是字符串，就从页面中找到该 DOM 对象。</li>\n<li>如果未找到就报错。</li>\n<li>如果<code>el</code>不是字符串就直接返回 el DOM 对象，因为<code>$mount</code>可以直接接收一个 DOM 元素,可以像这么写：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">&#125;).$mount(<span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#app&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们平时在 main.js 入口文件中，也会这么去写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">&#125;).$mount(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>el = el&amp;&amp;query(el)</code>就是处理上述两种写法。</p>\n<p><code>query</code>方法获取到 DOM 元素后，往下走，判断 el 元素如果是 body 或者 document,就报错 并且 return。<br>因为 index.html 里已经有了 html 和 body。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (el === <span class=\"variable language_\">document</span>.<span class=\"property\">body</span> || el === <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>) &#123;</span><br><span class=\"line\">  process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">      <span class=\"string\">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>el = el&amp;&amp;query(el)</code>,此操作是获取到我们定义的 DOM 节点，<code>&#39;#app&#39;</code>或<code>document.querySelector(&#39;#app&#39;)</code>;</li>\n<li>判断<code>options</code>中是否含有 <code>render</code> 方法。如果我们直接手写<code>render</code>函数,就会直接执行<code>return mount.call(this, el, hydrating)</code>然后就回去执行之前缓存的原型方法。</li>\n<li>如果没有<code>render</code>方法.会将<code>template</code>做为参数，运行时调用<code>compileToFunctions</code>方法，转化为<code>render</code>函数，再去调用<code>mount.call</code>方法。</li>\n</ol>\n<p>然后执行到 mount 变量缓存的 runtime-only 版本的<code>$mount</code>方法</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  el?: string | Element, <span class=\"comment\">//el可以是string，也可以是Element</span></span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  el = el &amp;&amp; inBrowser ? <span class=\"title function_\">query</span>(el) : <span class=\"literal\">undefined</span> <span class=\"comment\">// 这里el就已经是DOM对象（query(el)处理后）</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">mountComponent</span>(<span class=\"variable language_\">this</span>, el, hydrating)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这一段很简单，</p>\n<ol>\n<li>主要是确定了<code>Vue.prototype.$mount</code>传参的类型，el 可以传字符串，比如我们平时的”app”。或者直接传 DOM 对象。</li>\n<li>然后则是将 el 通过<code>query(el)</code>将字符串形式的 el 返回成 DOM 对象。</li>\n<li>其中的<code>inBrower</code>主要是判断是否浏览器环境，判断是否有<code>window</code>对象：<code>export const inBrowser = typeof window !== &#39;undefined&#39;</code></li>\n<li>最后就是最重要的<code>mountComponent(this, el, hydrating)</code>执行</li>\n</ol>\n<p>接下来先分析<code>query(el)</code>做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;util&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">query</span>(<span class=\"params\">el: string | Element</span>): <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> el === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> selected = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(el)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Cannot find element: &#x27;</span> + el)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selected</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是Element对象（Dom对象），就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> el</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单：</p>\n<ol>\n<li>判断<code>el</code>是字符串，就从页面中找到该 DOM 对象。</li>\n<li>如果未找到就报错。</li>\n<li>如果<code>el</code>不是字符串就直接返回 el DOM 对象。</li>\n</ol>\n<p>最后我们来分析最重要的这部分代码</p>\n<blockquote>\n<p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  vm: Component,</span></span><br><span class=\"line\"><span class=\"params\">  el: ?Element,</span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">$el</span> = el <span class=\"comment\">// 把el用vm.$el做缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果此时还是没有render方法，那就要抛出错误提示</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"property\">$options</span>.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有render函数，如果没有写render函数，并且template未转换成render函数。就创建一个空的VNode</span></span><br><span class=\"line\">    vm.<span class=\"property\">$options</span>.<span class=\"property\">render</span> = createEmptyVNode</span><br><span class=\"line\">    <span class=\"comment\">// 下面这部分分是：如果你没有用template，又没写render函数，在开发环境就会报此警告</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (vm.<span class=\"property\">$options</span>.<span class=\"property\">template</span> &amp;&amp; vm.<span class=\"property\">$options</span>.<span class=\"property\">template</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">0</span>) !== <span class=\"string\">&#x27;#&#x27;</span>) ||</span><br><span class=\"line\">        vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span> ||</span><br><span class=\"line\">        el</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">          <span class=\"string\">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">          <span class=\"string\">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeMount&#x27;</span>) <span class=\"comment\">//beforeMount</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> updateComponent <span class=\"comment\">//构建updateComponent方法，更新组件需要用到</span></span><br><span class=\"line\">  <span class=\"comment\">//  和性能埋点相关的</span></span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = vm.<span class=\"property\">_name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> id = vm.<span class=\"property\">_uid</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> startTag = <span class=\"string\">`vue-perf-start:<span class=\"subst\">$&#123;id&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> endTag = <span class=\"string\">`vue-perf-end:<span class=\"subst\">$&#123;id&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> vnode = vm.<span class=\"title function_\">_render</span>()</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">      vm.<span class=\"title function_\">_update</span>(vnode, hydrating)</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 主要是执行渲染Watcher</span></span><br><span class=\"line\">      <span class=\"comment\">// vm._render()生成VNode，然后调_update,把它传入</span></span><br><span class=\"line\">      vm.<span class=\"title function_\">_update</span>(vm.<span class=\"title function_\">_render</span>(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class=\"line\">  <span class=\"comment\">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class=\"line\">  <span class=\"comment\">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\">  <span class=\"comment\">// 渲染Watcher</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Watcher</span>(</span><br><span class=\"line\">    vm,</span><br><span class=\"line\">    updateComponent,</span><br><span class=\"line\">    noop, <span class=\"comment\">// 空function</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"title function_\">before</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vm.<span class=\"property\">_isMounted</span> &amp;&amp; !vm.<span class=\"property\">_isDestroyed</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeUpdate&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"literal\">true</span> <span class=\"comment\">/* isRenderWatcher */</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  hydrating = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// manually mounted instance, call mounted on self</span></span><br><span class=\"line\">  <span class=\"comment\">// mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\">  <span class=\"comment\">// 手动挂载实例</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.<span class=\"property\">$vnode</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    vm.<span class=\"property\">_isMounted</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;mounted&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vm</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先判断<code>render</code>函数是否已经构建好，如果为构建好久报错;</li>\n<li>如果为报错就构建<code>updateComponent</code>方法，这个方法每次更新组件的时候就会调这个方法；</li>\n<li>然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式</li>\n<li>最后手动挂载实例。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>是否 compile 版本，判断先执行那一部分代码。</li>\n<li>entry-runtime-with-compiler.js 会去判断是否有 render 函数，如果有就执行<code>return mount.call(this, el, hydrating)</code>然后就回去执行之前缓存的原型方法. 如果没有<code>render</code>方法.会将<code>template</code>做为参数，运行时调用<code>compileToFunctions</code>方法，转化为<code>render</code>函数，再去调用<code>return mount.call(this, el, hydrating)</code>方法。</li>\n<li>然后到了 runtime-only 版本的 mount。首先判断<code>render</code>函数是否已经构建好，如果为构建好久报错；如果为报错就构建<code>updateComponent</code>方法，这个方法每次更新组件的时候就会调这个方法；</li>\n<li>然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式</li>\n<li>最后手动挂载实例。</li>\n</ol>\n<p><strong>下一章：</strong><a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91render%E7%9A%84%E5%AE%9E%E7%8E%B0.md\">【源码剖析】render 的实现</a><br><strong>本章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%24mount%E6%8C%82%E8%BD%BD.md\">【源码剖析】$mount 挂载</a><br><strong>上一章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md\">【源码剖析】initState 初始化</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ul>\n<li>从<code>new Vue</code>这个过程最后，<code>vm.$mount(vm.$options.el)</code>可以看到 el 挂载。这一章将研究这一过程。具体分析 vue 如何将组件挂载到页面成为真实 Dom 的。</li>\n</ul>\n<p>这是<code>new Vue</code>过程的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 挂载el</span></span><br><span class=\"line\">  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码剖析\"><a href=\"#代码剖析\" class=\"headerlink\" title=\"代码剖析\"></a>代码剖析</h3><p>看了很多相关文章，大部分文章并没有讲述为啥要先分析 compiler 版本代码<code>$mount</code>，再去分析 runtime-only 版本的代码上的<code>$mount</code>。所有一开始就会有点懵，为啥要这么去分析。</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;entry-runtime-with-compiler.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最开始通过mount获取并缓存了Vue原型上的$mount方法，然后又重新定义了Vue.prototype.$mount</span></span><br><span class=\"line\"><span class=\"comment\">// 执行到到最后，通过return mount.call(this, el, hydrating) 重新调用mount缓存下来的原型方法。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mount = <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span></span><br><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  el?: string | Element,</span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用query来获取要挂载DOM元素节点</span></span><br><span class=\"line\">  el = el &amp;&amp; <span class=\"title function_\">query</span>(el)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断el是否为body，或者document，如果是则返回，因为本身index.html已经含有html,body元素</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果el是body或者文档标签，会替换原本的html和body.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (el === <span class=\"variable language_\">document</span>.<span class=\"property\">body</span> || el === <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>) &#123;</span><br><span class=\"line\">    process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">      <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">        <span class=\"string\">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = <span class=\"variable language_\">this</span>.<span class=\"property\">$options</span></span><br><span class=\"line\">  <span class=\"comment\">// resolve template/el and convert to render function</span></span><br><span class=\"line\">  <span class=\"comment\">/*处理模板templete，编译成render函数，render不存在的时候才会编译template，否则优先使用render*/</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断options中是否有render方法，有则直接调用mount方法，</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果没有render，则需要调用compileToFunctions生成render再调用mount方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*template存在的时候取template，不存在的时候取el的outerHTML*/</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = options.<span class=\"property\">template</span></span><br><span class=\"line\">    <span class=\"comment\">// 会判断有没有写template</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> template === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (template.<span class=\"title function_\">charAt</span>(<span class=\"number\">0</span>) === <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">          template = <span class=\"title function_\">idToTemplate</span>(template)</span><br><span class=\"line\">          <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">              <span class=\"string\">`Template element not found or is empty: <span class=\"subst\">$&#123;options.template&#125;</span>`</span>,</span><br><span class=\"line\">              <span class=\"variable language_\">this</span></span><br><span class=\"line\">            )</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (template.<span class=\"property\">nodeType</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*当template为DOM节点的时候*/</span></span><br><span class=\"line\">        template = template.<span class=\"property\">innerHTML</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;invalid template option:&#x27;</span> + template, <span class=\"variable language_\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//</span></span><br><span class=\"line\">      template = <span class=\"title function_\">getOuterHTML</span>(el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">mark</span>(<span class=\"string\">&#x27;compile&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = <span class=\"title function_\">compileToFunctions</span>(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">outputSourceRange</span>: process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>,</span><br><span class=\"line\">          shouldDecodeNewlines,</span><br><span class=\"line\">          shouldDecodeNewlinesForHref,</span><br><span class=\"line\">          <span class=\"attr\">delimiters</span>: options.<span class=\"property\">delimiters</span>,</span><br><span class=\"line\">          <span class=\"attr\">comments</span>: options.<span class=\"property\">comments</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"variable language_\">this</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">      options.<span class=\"property\">render</span> = render</span><br><span class=\"line\">      options.<span class=\"property\">staticRenderFns</span> = staticRenderFns</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">mark</span>(<span class=\"string\">&#x27;compile end&#x27;</span>)</span><br><span class=\"line\">        <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> compile`</span>, <span class=\"string\">&#x27;compile&#x27;</span>, <span class=\"string\">&#x27;compile end&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 执行runtime-only版本的$mounted</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> mount.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, el, hydrating)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这部分代码可以看出：</p>\n<ol>\n<li>一开始通过定义<code>mount</code>缓存了 Vue 原型上原始的<code>$mount</code>方法<code>const mount = Vue.prototype.$mount</code>；</li>\n<li>然后又重新定义了<code>Vue.prototype.$mount</code>方法。</li>\n<li>执行到最后，又重新调用缓存的原始<code>Vue.prototype.$mount</code>方法<code>return mount.call(this, el, hydrating)</code>,这时候就会执行到<code>runtime/index</code>的<code>$mount</code>方法。</li>\n<li>其中有一部分是判断内部有无<code>render</code>函数，若无则通过<code>compileToFunctions</code>方法生成 render 再调用 mount 方法.若无则直接执行<code>return mount.call(this, el, hydrating)</code></li>\n</ol>\n<p>那么 entry-runtime-with-compiler.js 文件中的<code>$mount</code>到底干了些什么呢。</p>\n<p>先分析<code>query(el)</code>做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;util&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">query</span>(<span class=\"params\">el: string | Element</span>): <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> el === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> selected = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(el)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Cannot find element: &#x27;</span> + el)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selected</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是Element对象（Dom对象），就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> el</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单：</p>\n<ol>\n<li>判断<code>el</code>是字符串，就从页面中找到该 DOM 对象。</li>\n<li>如果未找到就报错。</li>\n<li>如果<code>el</code>不是字符串就直接返回 el DOM 对象，因为<code>$mount</code>可以直接接收一个 DOM 元素,可以像这么写：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">&#125;).$mount(<span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;#app&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>我们平时在 main.js 入口文件中，也会这么去写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Vue</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">App</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./App.vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\">(<span class=\"params\">h</span>) =&gt;</span> <span class=\"title function_\">h</span>(<span class=\"title class_\">App</span>),</span><br><span class=\"line\">&#125;).$mount(<span class=\"string\">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>el = el&amp;&amp;query(el)</code>就是处理上述两种写法。</p>\n<p><code>query</code>方法获取到 DOM 元素后，往下走，判断 el 元素如果是 body 或者 document,就报错 并且 return。<br>因为 index.html 里已经有了 html 和 body。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (el === <span class=\"variable language_\">document</span>.<span class=\"property\">body</span> || el === <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>) &#123;</span><br><span class=\"line\">  process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">      <span class=\"string\">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>el = el&amp;&amp;query(el)</code>,此操作是获取到我们定义的 DOM 节点，<code>&#39;#app&#39;</code>或<code>document.querySelector(&#39;#app&#39;)</code>;</li>\n<li>判断<code>options</code>中是否含有 <code>render</code> 方法。如果我们直接手写<code>render</code>函数,就会直接执行<code>return mount.call(this, el, hydrating)</code>然后就回去执行之前缓存的原型方法。</li>\n<li>如果没有<code>render</code>方法.会将<code>template</code>做为参数，运行时调用<code>compileToFunctions</code>方法，转化为<code>render</code>函数，再去调用<code>mount.call</code>方法。</li>\n</ol>\n<p>然后执行到 mount 变量缓存的 runtime-only 版本的<code>$mount</code>方法</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;runtime&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">$mount</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  el?: string | Element, <span class=\"comment\">//el可以是string，也可以是Element</span></span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  el = el &amp;&amp; inBrowser ? <span class=\"title function_\">query</span>(el) : <span class=\"literal\">undefined</span> <span class=\"comment\">// 这里el就已经是DOM对象（query(el)处理后）</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">mountComponent</span>(<span class=\"variable language_\">this</span>, el, hydrating)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这一段很简单，</p>\n<ol>\n<li>主要是确定了<code>Vue.prototype.$mount</code>传参的类型，el 可以传字符串，比如我们平时的”app”。或者直接传 DOM 对象。</li>\n<li>然后则是将 el 通过<code>query(el)</code>将字符串形式的 el 返回成 DOM 对象。</li>\n<li>其中的<code>inBrower</code>主要是判断是否浏览器环境，判断是否有<code>window</code>对象：<code>export const inBrowser = typeof window !== &#39;undefined&#39;</code></li>\n<li>最后就是最重要的<code>mountComponent(this, el, hydrating)</code>执行</li>\n</ol>\n<p>接下来先分析<code>query(el)</code>做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;platforms&#x2F;web&#x2F;util&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">query</span>(<span class=\"params\">el: string | Element</span>): <span class=\"title class_\">Element</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> el === <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果el是string形式，我们就去找document是否能找到el命名的元素，未找到就会报错提示，如果找到，返回的就是找到的DOM对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> selected = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(el)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selected) &#123;</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Cannot find element: &#x27;</span> + el)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> selected</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是Element对象（Dom对象），就直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> el</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码比较简单：</p>\n<ol>\n<li>判断<code>el</code>是字符串，就从页面中找到该 DOM 对象。</li>\n<li>如果未找到就报错。</li>\n<li>如果<code>el</code>不是字符串就直接返回 el DOM 对象。</li>\n</ol>\n<p>最后我们来分析最重要的这部分代码</p>\n<blockquote>\n<p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;lifecycle.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mountComponent</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">  vm: Component,</span></span><br><span class=\"line\"><span class=\"params\">  el: ?Element,</span></span><br><span class=\"line\"><span class=\"params\">  hydrating?: boolean</span></span><br><span class=\"line\"><span class=\"params\"></span>): <span class=\"title class_\">Component</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">$el</span> = el <span class=\"comment\">// 把el用vm.$el做缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果此时还是没有render方法，那就要抛出错误提示</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!vm.<span class=\"property\">$options</span>.<span class=\"property\">render</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有render函数，如果没有写render函数，并且template未转换成render函数。就创建一个空的VNode</span></span><br><span class=\"line\">    vm.<span class=\"property\">$options</span>.<span class=\"property\">render</span> = createEmptyVNode</span><br><span class=\"line\">    <span class=\"comment\">// 下面这部分分是：如果你没有用template，又没写render函数，在开发环境就会报此警告</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        (vm.<span class=\"property\">$options</span>.<span class=\"property\">template</span> &amp;&amp; vm.<span class=\"property\">$options</span>.<span class=\"property\">template</span>.<span class=\"title function_\">charAt</span>(<span class=\"number\">0</span>) !== <span class=\"string\">&#x27;#&#x27;</span>) ||</span><br><span class=\"line\">        vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span> ||</span><br><span class=\"line\">        el</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">          <span class=\"string\">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">warn</span>(</span><br><span class=\"line\">          <span class=\"string\">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeMount&#x27;</span>) <span class=\"comment\">//beforeMount</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> updateComponent <span class=\"comment\">//构建updateComponent方法，更新组件需要用到</span></span><br><span class=\"line\">  <span class=\"comment\">//  和性能埋点相关的</span></span><br><span class=\"line\">  <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">    updateComponent = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = vm.<span class=\"property\">_name</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> id = vm.<span class=\"property\">_uid</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> startTag = <span class=\"string\">`vue-perf-start:<span class=\"subst\">$&#123;id&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> endTag = <span class=\"string\">`vue-perf-end:<span class=\"subst\">$&#123;id&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">      <span class=\"keyword\">const</span> vnode = vm.<span class=\"title function_\">_render</span>()</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">      vm.<span class=\"title function_\">_update</span>(vnode, hydrating)</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    updateComponent = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 主要是执行渲染Watcher</span></span><br><span class=\"line\">      <span class=\"comment\">// vm._render()生成VNode，然后调_update,把它传入</span></span><br><span class=\"line\">      vm.<span class=\"title function_\">_update</span>(vm.<span class=\"title function_\">_render</span>(), hydrating)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class=\"line\">  <span class=\"comment\">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class=\"line\">  <span class=\"comment\">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class=\"line\">  <span class=\"comment\">// 渲染Watcher</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Watcher</span>(</span><br><span class=\"line\">    vm,</span><br><span class=\"line\">    updateComponent,</span><br><span class=\"line\">    noop, <span class=\"comment\">// 空function</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"title function_\">before</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (vm.<span class=\"property\">_isMounted</span> &amp;&amp; !vm.<span class=\"property\">_isDestroyed</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeUpdate&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"literal\">true</span> <span class=\"comment\">/* isRenderWatcher */</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  hydrating = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// manually mounted instance, call mounted on self</span></span><br><span class=\"line\">  <span class=\"comment\">// mounted is called for render-created child components in its inserted hook</span></span><br><span class=\"line\">  <span class=\"comment\">// 手动挂载实例</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vm.<span class=\"property\">$vnode</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    vm.<span class=\"property\">_isMounted</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;mounted&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vm</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>首先判断<code>render</code>函数是否已经构建好，如果为构建好久报错;</li>\n<li>如果为报错就构建<code>updateComponent</code>方法，这个方法每次更新组件的时候就会调这个方法；</li>\n<li>然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式</li>\n<li>最后手动挂载实例。</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>是否 compile 版本，判断先执行那一部分代码。</li>\n<li>entry-runtime-with-compiler.js 会去判断是否有 render 函数，如果有就执行<code>return mount.call(this, el, hydrating)</code>然后就回去执行之前缓存的原型方法. 如果没有<code>render</code>方法.会将<code>template</code>做为参数，运行时调用<code>compileToFunctions</code>方法，转化为<code>render</code>函数，再去调用<code>return mount.call(this, el, hydrating)</code>方法。</li>\n<li>然后到了 runtime-only 版本的 mount。首先判断<code>render</code>函数是否已经构建好，如果为构建好久报错；如果为报错就构建<code>updateComponent</code>方法，这个方法每次更新组件的时候就会调这个方法；</li>\n<li>然后 new Watch 是 Vue 响应式处理中的依赖收集过程，其原理采用了观察者模式</li>\n<li>最后手动挂载实例。</li>\n</ol>\n<p><strong>下一章：</strong><a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91render%E7%9A%84%E5%AE%9E%E7%8E%B0.md\">【源码剖析】render 的实现</a><br><strong>本章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%24mount%E6%8C%82%E8%BD%BD.md\">【源码剖析】$mount 挂载</a><br><strong>上一章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md\">【源码剖析】initState 初始化</a></p>\n"},{"title":"【源码剖析】new Vue 发生了什么","date":"2023-09-07T09:34:13.133Z","_content":"\n### 说明\n\n- vue 业务代码写了几年，对其痛点有了相应了解，想更深入理解其痛点原因。\n- 学习源码中的思路，了解其 api 输出的原理。\n- vue2.6 已经到终版，对比大佬之前版本的源码分析，可以看其最后某些代码优化。\n\n### 代码剖析\n\n`new` 关键字在 Javascript 语言中代表实例化是一个对象，而 `Vue` 实际上是一个类，类在 Javascript 中是用 Function 来实现的。所以我们得找到`Vue`函数，从而去分析其函数执行究竟做了些什么\n\n> /src/core/instance/index.js\n\n```javascript\nfunction Vue(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n可以看到 `Vue` 只能通过 `new` 关键字初始化，然后会调用 `this._init` 方法\n\n> src/core/instance/init.js\n\n```javascript\nexport function initMixin(Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    /*初始化生命周期*/\n    initLifecycle(vm)\n    /*初始化事件*/\n    initEvents(vm)\n    /*初始化render*/\n    initRender(vm)\n    /*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    /*初始化props、methods、data、computed与watch*/\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    /*调用created钩子函数并且触发created钩子事件*/\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n\n上述代码只是在 Vue 的原型上增加`_init`方法，构造 Vue 实例的时候会调用这个`_init`方法来初始化 Vue 实例。\n\n接下来我们逐段分析`Vue.prototype._init`方法中的代码：\n\n```javascript\nif (options && options._isComponent) {\n  // optimize internal component instantiation\n  // since dynamic options merging is pretty slow, and none of the\n  // internal component options needs special treatment.\n  initInternalComponent(vm, options)\n} else {\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n}\n```\n\n这段主要是**对 Vue 提供的 props、data、methods 等选项进行合并处理**。会将我们传入的 options 合并到`vm.$options`上。我们可以通过 vm.$option.el,访问到我们`options`传入的 el。\n\n跳过内部函数，接着往下执行可以看到：\n\n```javascript\n/* istanbul ignore else */\nif (process.env.NODE_ENV !== 'production') {\n  initProxy(vm)\n} else {\n  vm._renderProxy = vm\n}\n```\n\n这里主要是**设置渲染函数的作用域代理，其目的是提供更好的提示信息**（如：在模板内访问实例不存在的属性，则会在非生产环境下提供准确的报错信息）\n\n再往下执行可以发现，`new Vue`最重要的部分。\n\n```javascript\n/*初始化生命周期*/\ninitLifecycle(vm)\n/*初始化事件*/\ninitEvents(vm)\n/*初始化render*/\ninitRender(vm)\n/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/\ncallHook(vm, 'beforeCreate')\ninitInjections(vm) // resolve injections before data/props\n/*初始化props、methods、data、computed与watch*/\ninitState(vm)\ninitProvide(vm) // resolve provide after data/props\n/*调用created钩子函数并且触发created钩子事件*/\ncallHook(vm, 'created')\n```\n\n从上述代码，不难看出：Vue 初始化主要执行了：**初始化生命周期`initLifecycle`、初始化事件中心`initEvents`、初始化渲染`initEvents`、初始化 data、props、methods、computed、watch； 调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件；调用 created 钩子函数并且触发 created 钩子事件**。\n\n在初始化的最后的代码\n\n```javascript\nif (vm.$options.el) {\n  // 挂载el\n  vm.$mount(vm.$options.el)\n}\n```\n\n判断是否有了属性，如果有 `el` 属性，则调用 `vm.$mount` 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。\n\n### 总结\n\n**全文从构造函数`Vue`开始，执行 `new Vue()` 调用 Vue 的原型方法`Vue.prototype._init()` 方法，依次处理：**\n\n- **合并配置**\n- **设置渲染函数的作用域代理**\n- **初始化生命周期`initLifecycle(vm)`**\n- **初始化事件`initEvents(vm)`**\n- **初始化渲染（render）`initRender(vm)`**\n- **调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件`callHook(vm, 'beforeCreate')`**\n- **初始化 data、props、methods、computed、watch 等`initState(vm)`;**\n- **调用 created 钩子函数并且触发 created 钩子事件`callHook(vm, 'created')`**\n- **挂载 el`vm.$mount(vm.$options.el)`**\n\n下一章节，先去分析其中比较简单的一部分`initState(vm)`，这部分主要是 props,methods,data,computed,watch 初始化。\n**下一章：** [【源码剖析】initState 初始化](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md)\n**本章：** [【源码剖析】new Vue 发生了什么](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91new%20Vue%20%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.md)\n","source":"_posts/Vue/Vue2源码分析/【源码剖析】new Vue 发生了什么.md","raw":"---\ntitle: 【源码剖析】new Vue 发生了什么\ndate:\ntags: [Vue, 源码剖析]\ncategories: [前端, Vue, Vue2源码剖析]\n---\n\n### 说明\n\n- vue 业务代码写了几年，对其痛点有了相应了解，想更深入理解其痛点原因。\n- 学习源码中的思路，了解其 api 输出的原理。\n- vue2.6 已经到终版，对比大佬之前版本的源码分析，可以看其最后某些代码优化。\n\n### 代码剖析\n\n`new` 关键字在 Javascript 语言中代表实例化是一个对象，而 `Vue` 实际上是一个类，类在 Javascript 中是用 Function 来实现的。所以我们得找到`Vue`函数，从而去分析其函数执行究竟做了些什么\n\n> /src/core/instance/index.js\n\n```javascript\nfunction Vue(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n可以看到 `Vue` 只能通过 `new` 关键字初始化，然后会调用 `this._init` 方法\n\n> src/core/instance/init.js\n\n```javascript\nexport function initMixin(Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    /*初始化生命周期*/\n    initLifecycle(vm)\n    /*初始化事件*/\n    initEvents(vm)\n    /*初始化render*/\n    initRender(vm)\n    /*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    /*初始化props、methods、data、computed与watch*/\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    /*调用created钩子函数并且触发created钩子事件*/\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n\n上述代码只是在 Vue 的原型上增加`_init`方法，构造 Vue 实例的时候会调用这个`_init`方法来初始化 Vue 实例。\n\n接下来我们逐段分析`Vue.prototype._init`方法中的代码：\n\n```javascript\nif (options && options._isComponent) {\n  // optimize internal component instantiation\n  // since dynamic options merging is pretty slow, and none of the\n  // internal component options needs special treatment.\n  initInternalComponent(vm, options)\n} else {\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n}\n```\n\n这段主要是**对 Vue 提供的 props、data、methods 等选项进行合并处理**。会将我们传入的 options 合并到`vm.$options`上。我们可以通过 vm.$option.el,访问到我们`options`传入的 el。\n\n跳过内部函数，接着往下执行可以看到：\n\n```javascript\n/* istanbul ignore else */\nif (process.env.NODE_ENV !== 'production') {\n  initProxy(vm)\n} else {\n  vm._renderProxy = vm\n}\n```\n\n这里主要是**设置渲染函数的作用域代理，其目的是提供更好的提示信息**（如：在模板内访问实例不存在的属性，则会在非生产环境下提供准确的报错信息）\n\n再往下执行可以发现，`new Vue`最重要的部分。\n\n```javascript\n/*初始化生命周期*/\ninitLifecycle(vm)\n/*初始化事件*/\ninitEvents(vm)\n/*初始化render*/\ninitRender(vm)\n/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/\ncallHook(vm, 'beforeCreate')\ninitInjections(vm) // resolve injections before data/props\n/*初始化props、methods、data、computed与watch*/\ninitState(vm)\ninitProvide(vm) // resolve provide after data/props\n/*调用created钩子函数并且触发created钩子事件*/\ncallHook(vm, 'created')\n```\n\n从上述代码，不难看出：Vue 初始化主要执行了：**初始化生命周期`initLifecycle`、初始化事件中心`initEvents`、初始化渲染`initEvents`、初始化 data、props、methods、computed、watch； 调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件；调用 created 钩子函数并且触发 created 钩子事件**。\n\n在初始化的最后的代码\n\n```javascript\nif (vm.$options.el) {\n  // 挂载el\n  vm.$mount(vm.$options.el)\n}\n```\n\n判断是否有了属性，如果有 `el` 属性，则调用 `vm.$mount` 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。\n\n### 总结\n\n**全文从构造函数`Vue`开始，执行 `new Vue()` 调用 Vue 的原型方法`Vue.prototype._init()` 方法，依次处理：**\n\n- **合并配置**\n- **设置渲染函数的作用域代理**\n- **初始化生命周期`initLifecycle(vm)`**\n- **初始化事件`initEvents(vm)`**\n- **初始化渲染（render）`initRender(vm)`**\n- **调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件`callHook(vm, 'beforeCreate')`**\n- **初始化 data、props、methods、computed、watch 等`initState(vm)`;**\n- **调用 created 钩子函数并且触发 created 钩子事件`callHook(vm, 'created')`**\n- **挂载 el`vm.$mount(vm.$options.el)`**\n\n下一章节，先去分析其中比较简单的一部分`initState(vm)`，这部分主要是 props,methods,data,computed,watch 初始化。\n**下一章：** [【源码剖析】initState 初始化](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md)\n**本章：** [【源码剖析】new Vue 发生了什么](https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91new%20Vue%20%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.md)\n","slug":"Vue/Vue2源码分析/【源码剖析】new Vue 发生了什么","published":1,"updated":"2023-09-07T09:35:31.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwl001km32vc5q96x5v","content":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ul>\n<li>vue 业务代码写了几年，对其痛点有了相应了解，想更深入理解其痛点原因。</li>\n<li>学习源码中的思路，了解其 api 输出的原理。</li>\n<li>vue2.6 已经到终版，对比大佬之前版本的源码分析，可以看其最后某些代码优化。</li>\n</ul>\n<h3 id=\"代码剖析\"><a href=\"#代码剖析\" class=\"headerlink\" title=\"代码剖析\"></a>代码剖析</h3><p><code>new</code> 关键字在 Javascript 语言中代表实例化是一个对象，而 <code>Vue</code> 实际上是一个类，类在 Javascript 中是用 Function 来实现的。所以我们得找到<code>Vue</code>函数，从而去分析其函数执行究竟做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Vue</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !(<span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Vue</span>)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">_init</span>(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>Vue</code> 只能通过 <code>new</code> 关键字初始化，然后会调用 <code>this._init</code> 方法</p>\n<blockquote>\n<p>src&#x2F;core&#x2F;instance&#x2F;init.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initMixin</span>(<span class=\"params\">Vue: Class&lt;Component&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">_init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">options?: <span class=\"built_in\">Object</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// a uid</span></span><br><span class=\"line\">    vm.<span class=\"property\">_uid</span> = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> startTag, endTag</span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = <span class=\"string\">`vue-perf-start:<span class=\"subst\">$&#123;vm._uid&#125;</span>`</span></span><br><span class=\"line\">      endTag = <span class=\"string\">`vue-perf-end:<span class=\"subst\">$&#123;vm._uid&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a flag to avoid this being observed</span></span><br><span class=\"line\">    vm.<span class=\"property\">_isVue</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// merge options</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options.<span class=\"property\">_isComponent</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// optimize internal component instantiation</span></span><br><span class=\"line\">      <span class=\"comment\">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class=\"line\">      <span class=\"comment\">// internal component options needs special treatment.</span></span><br><span class=\"line\">      <span class=\"title function_\">initInternalComponent</span>(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">$options</span> = <span class=\"title function_\">mergeOptions</span>(</span><br><span class=\"line\">        <span class=\"title function_\">resolveConstructorOptions</span>(vm.<span class=\"property\">constructor</span>),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">initProxy</span>(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">_renderProxy</span> = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// expose real self</span></span><br><span class=\"line\">    vm.<span class=\"property\">_self</span> = vm</span><br><span class=\"line\">    <span class=\"comment\">/*初始化生命周期*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initLifecycle</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*初始化事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initEvents</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*初始化render*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initRender</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">initInjections</span>(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\">    <span class=\"comment\">/*初始化props、methods、data、computed与watch*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initState</span>(vm)</span><br><span class=\"line\">    <span class=\"title function_\">initProvide</span>(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\">    <span class=\"comment\">/*调用created钩子函数并且触发created钩子事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">_name</span> = <span class=\"title function_\">formatComponentName</span>(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">      vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码只是在 Vue 的原型上增加<code>_init</code>方法，构造 Vue 实例的时候会调用这个<code>_init</code>方法来初始化 Vue 实例。</p>\n<p>接下来我们逐段分析<code>Vue.prototype._init</code>方法中的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (options &amp;&amp; options.<span class=\"property\">_isComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// optimize internal component instantiation</span></span><br><span class=\"line\">  <span class=\"comment\">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class=\"line\">  <span class=\"comment\">// internal component options needs special treatment.</span></span><br><span class=\"line\">  <span class=\"title function_\">initInternalComponent</span>(vm, options)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">$options</span> = <span class=\"title function_\">mergeOptions</span>(</span><br><span class=\"line\">    <span class=\"title function_\">resolveConstructorOptions</span>(vm.<span class=\"property\">constructor</span>),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段主要是<strong>对 Vue 提供的 props、data、methods 等选项进行合并处理</strong>。会将我们传入的 options 合并到<code>vm.$options</code>上。我们可以通过 vm.$option.el,访问到我们<code>options</code>传入的 el。</p>\n<p>跳过内部函数，接着往下执行可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">initProxy</span>(vm)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">_renderProxy</span> = vm</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要是<strong>设置渲染函数的作用域代理，其目的是提供更好的提示信息</strong>（如：在模板内访问实例不存在的属性，则会在非生产环境下提供准确的报错信息）</p>\n<p>再往下执行可以发现，<code>new Vue</code>最重要的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*初始化生命周期*/</span></span><br><span class=\"line\"><span class=\"title function_\">initLifecycle</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*初始化事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">initEvents</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*初始化render*/</span></span><br><span class=\"line\"><span class=\"title function_\">initRender</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\"><span class=\"title function_\">initInjections</span>(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\"><span class=\"comment\">/*初始化props、methods、data、computed与watch*/</span></span><br><span class=\"line\"><span class=\"title function_\">initState</span>(vm)</span><br><span class=\"line\"><span class=\"title function_\">initProvide</span>(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\"><span class=\"comment\">/*调用created钩子函数并且触发created钩子事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码，不难看出：Vue 初始化主要执行了：<strong>初始化生命周期<code>initLifecycle</code>、初始化事件中心<code>initEvents</code>、初始化渲染<code>initEvents</code>、初始化 data、props、methods、computed、watch； 调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件；调用 created 钩子函数并且触发 created 钩子事件</strong>。</p>\n<p>在初始化的最后的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 挂载el</span></span><br><span class=\"line\">  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断是否有了属性，如果有 <code>el</code> 属性，则调用 <code>vm.$mount</code> 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>全文从构造函数<code>Vue</code>开始，执行 <code>new Vue()</code> 调用 Vue 的原型方法<code>Vue.prototype._init()</code> 方法，依次处理：</strong></p>\n<ul>\n<li><strong>合并配置</strong></li>\n<li><strong>设置渲染函数的作用域代理</strong></li>\n<li><strong>初始化生命周期<code>initLifecycle(vm)</code></strong></li>\n<li><strong>初始化事件<code>initEvents(vm)</code></strong></li>\n<li><strong>初始化渲染（render）<code>initRender(vm)</code></strong></li>\n<li><strong>调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件<code>callHook(vm, &#39;beforeCreate&#39;)</code></strong></li>\n<li><strong>初始化 data、props、methods、computed、watch 等<code>initState(vm)</code>;</strong></li>\n<li><strong>调用 created 钩子函数并且触发 created 钩子事件<code>callHook(vm, &#39;created&#39;)</code></strong></li>\n<li><strong>挂载 el<code>vm.$mount(vm.$options.el)</code></strong></li>\n</ul>\n<p>下一章节，先去分析其中比较简单的一部分<code>initState(vm)</code>，这部分主要是 props,methods,data,computed,watch 初始化。<br><strong>下一章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md\">【源码剖析】initState 初始化</a><br><strong>本章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91new%20Vue%20%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.md\">【源码剖析】new Vue 发生了什么</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ul>\n<li>vue 业务代码写了几年，对其痛点有了相应了解，想更深入理解其痛点原因。</li>\n<li>学习源码中的思路，了解其 api 输出的原理。</li>\n<li>vue2.6 已经到终版，对比大佬之前版本的源码分析，可以看其最后某些代码优化。</li>\n</ul>\n<h3 id=\"代码剖析\"><a href=\"#代码剖析\" class=\"headerlink\" title=\"代码剖析\"></a>代码剖析</h3><p><code>new</code> 关键字在 Javascript 语言中代表实例化是一个对象，而 <code>Vue</code> 实际上是一个类，类在 Javascript 中是用 Function 来实现的。所以我们得找到<code>Vue</code>函数，从而去分析其函数执行究竟做了些什么</p>\n<blockquote>\n<p>&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Vue</span>(<span class=\"params\">options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; !(<span class=\"variable language_\">this</span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Vue</span>)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">warn</span>(<span class=\"string\">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">_init</span>(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>Vue</code> 只能通过 <code>new</code> 关键字初始化，然后会调用 <code>this._init</code> 方法</p>\n<blockquote>\n<p>src&#x2F;core&#x2F;instance&#x2F;init.js</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">initMixin</span>(<span class=\"params\">Vue: Class&lt;Component&gt;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Vue</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">_init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">options?: <span class=\"built_in\">Object</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">vm</span>: <span class=\"title class_\">Component</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// a uid</span></span><br><span class=\"line\">    vm.<span class=\"property\">_uid</span> = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> startTag, endTag</span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = <span class=\"string\">`vue-perf-start:<span class=\"subst\">$&#123;vm._uid&#125;</span>`</span></span><br><span class=\"line\">      endTag = <span class=\"string\">`vue-perf-end:<span class=\"subst\">$&#123;vm._uid&#125;</span>`</span></span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a flag to avoid this being observed</span></span><br><span class=\"line\">    vm.<span class=\"property\">_isVue</span> = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// merge options</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options &amp;&amp; options.<span class=\"property\">_isComponent</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// optimize internal component instantiation</span></span><br><span class=\"line\">      <span class=\"comment\">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class=\"line\">      <span class=\"comment\">// internal component options needs special treatment.</span></span><br><span class=\"line\">      <span class=\"title function_\">initInternalComponent</span>(vm, options)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">$options</span> = <span class=\"title function_\">mergeOptions</span>(</span><br><span class=\"line\">        <span class=\"title function_\">resolveConstructorOptions</span>(vm.<span class=\"property\">constructor</span>),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">initProxy</span>(vm)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">_renderProxy</span> = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// expose real self</span></span><br><span class=\"line\">    vm.<span class=\"property\">_self</span> = vm</span><br><span class=\"line\">    <span class=\"comment\">/*初始化生命周期*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initLifecycle</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*初始化事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initEvents</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*初始化render*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initRender</span>(vm)</span><br><span class=\"line\">    <span class=\"comment\">/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\">    <span class=\"title function_\">initInjections</span>(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\">    <span class=\"comment\">/*初始化props、methods、data、computed与watch*/</span></span><br><span class=\"line\">    <span class=\"title function_\">initState</span>(vm)</span><br><span class=\"line\">    <span class=\"title function_\">initProvide</span>(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\">    <span class=\"comment\">/*调用created钩子函数并且触发created钩子事件*/</span></span><br><span class=\"line\">    <span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* istanbul ignore if */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span> &amp;&amp; config.<span class=\"property\">performance</span> &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm.<span class=\"property\">_name</span> = <span class=\"title function_\">formatComponentName</span>(vm, <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"title function_\">mark</span>(endTag)</span><br><span class=\"line\">      <span class=\"title function_\">measure</span>(<span class=\"string\">`vue <span class=\"subst\">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">      vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码只是在 Vue 的原型上增加<code>_init</code>方法，构造 Vue 实例的时候会调用这个<code>_init</code>方法来初始化 Vue 实例。</p>\n<p>接下来我们逐段分析<code>Vue.prototype._init</code>方法中的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (options &amp;&amp; options.<span class=\"property\">_isComponent</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// optimize internal component instantiation</span></span><br><span class=\"line\">  <span class=\"comment\">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class=\"line\">  <span class=\"comment\">// internal component options needs special treatment.</span></span><br><span class=\"line\">  <span class=\"title function_\">initInternalComponent</span>(vm, options)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">$options</span> = <span class=\"title function_\">mergeOptions</span>(</span><br><span class=\"line\">    <span class=\"title function_\">resolveConstructorOptions</span>(vm.<span class=\"property\">constructor</span>),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段主要是<strong>对 Vue 提供的 props、data、methods 等选项进行合并处理</strong>。会将我们传入的 options 合并到<code>vm.$options</code>上。我们可以通过 vm.$option.el,访问到我们<code>options</code>传入的 el。</p>\n<p>跳过内部函数，接着往下执行可以看到：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* istanbul ignore else */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> !== <span class=\"string\">&#x27;production&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">initProxy</span>(vm)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  vm.<span class=\"property\">_renderProxy</span> = vm</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里主要是<strong>设置渲染函数的作用域代理，其目的是提供更好的提示信息</strong>（如：在模板内访问实例不存在的属性，则会在非生产环境下提供准确的报错信息）</p>\n<p>再往下执行可以发现，<code>new Vue</code>最重要的部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*初始化生命周期*/</span></span><br><span class=\"line\"><span class=\"title function_\">initLifecycle</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*初始化事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">initEvents</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*初始化render*/</span></span><br><span class=\"line\"><span class=\"title function_\">initRender</span>(vm)</span><br><span class=\"line\"><span class=\"comment\">/*调用beforeCreate钩子函数并且触发beforeCreate钩子事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;beforeCreate&#x27;</span>)</span><br><span class=\"line\"><span class=\"title function_\">initInjections</span>(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\"><span class=\"comment\">/*初始化props、methods、data、computed与watch*/</span></span><br><span class=\"line\"><span class=\"title function_\">initState</span>(vm)</span><br><span class=\"line\"><span class=\"title function_\">initProvide</span>(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\"><span class=\"comment\">/*调用created钩子函数并且触发created钩子事件*/</span></span><br><span class=\"line\"><span class=\"title function_\">callHook</span>(vm, <span class=\"string\">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码，不难看出：Vue 初始化主要执行了：<strong>初始化生命周期<code>initLifecycle</code>、初始化事件中心<code>initEvents</code>、初始化渲染<code>initEvents</code>、初始化 data、props、methods、computed、watch； 调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件；调用 created 钩子函数并且触发 created 钩子事件</strong>。</p>\n<p>在初始化的最后的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 挂载el</span></span><br><span class=\"line\">  vm.$mount(vm.<span class=\"property\">$options</span>.<span class=\"property\">el</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断是否有了属性，如果有 <code>el</code> 属性，则调用 <code>vm.$mount</code> 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>全文从构造函数<code>Vue</code>开始，执行 <code>new Vue()</code> 调用 Vue 的原型方法<code>Vue.prototype._init()</code> 方法，依次处理：</strong></p>\n<ul>\n<li><strong>合并配置</strong></li>\n<li><strong>设置渲染函数的作用域代理</strong></li>\n<li><strong>初始化生命周期<code>initLifecycle(vm)</code></strong></li>\n<li><strong>初始化事件<code>initEvents(vm)</code></strong></li>\n<li><strong>初始化渲染（render）<code>initRender(vm)</code></strong></li>\n<li><strong>调用 beforeCreate 钩子函数并且触发 beforeCreate 钩子事件<code>callHook(vm, &#39;beforeCreate&#39;)</code></strong></li>\n<li><strong>初始化 data、props、methods、computed、watch 等<code>initState(vm)</code>;</strong></li>\n<li><strong>调用 created 钩子函数并且触发 created 钩子事件<code>callHook(vm, &#39;created&#39;)</code></strong></li>\n<li><strong>挂载 el<code>vm.$mount(vm.$options.el)</code></strong></li>\n</ul>\n<p>下一章节，先去分析其中比较简单的一部分<code>initState(vm)</code>，这部分主要是 props,methods,data,computed,watch 初始化。<br><strong>下一章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91initState%20%E5%88%9D%E5%A7%8B%E5%8C%96.md\">【源码剖析】initState 初始化</a><br><strong>本章：</strong> <a href=\"https://github.com/yihan12/Blog/blob/main/vue2.6-analysis/%E3%80%90%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%91new%20Vue%20%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.md\">【源码剖析】new Vue 发生了什么</a></p>\n"},{"title":"ES6模块和CommonJS的异同","date":"2024-11-09T02:08:48.973Z","_content":"\n# 相同点\n\n- 对引入对象进行赋值，即对对象内部属性的值的改变\n\n# 区别\n\n- commonJS 模块运行时加载，ES6 模块是输出编译时输出接口\n- commonJS 模块 require 同步加载模块，ES6 import 是异步的\n- commonJS 模块 require 对模块的浅拷贝，ES6 import 是对模块的引入，只存只读不改变其值 指针指向不能变类似 const\n- import 接口 read-only 不能改变变量值，\n","source":"_posts/JavaScript/JavaScript面试/ES6模块和CommonJS的异同.md","raw":"---\ntitle: ES6模块和CommonJS的异同\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, ES6模块和CommonJS的异同]\n---\n\n# 相同点\n\n- 对引入对象进行赋值，即对对象内部属性的值的改变\n\n# 区别\n\n- commonJS 模块运行时加载，ES6 模块是输出编译时输出接口\n- commonJS 模块 require 同步加载模块，ES6 import 是异步的\n- commonJS 模块 require 对模块的浅拷贝，ES6 import 是对模块的引入，只存只读不改变其值 指针指向不能变类似 const\n- import 接口 read-only 不能改变变量值，\n","slug":"JavaScript/JavaScript面试/ES6模块和CommonJS的异同","published":1,"updated":"2024-11-09T02:16:46.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwm001om32vcywbabj5","content":"<h1 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h1><ul>\n<li>对引入对象进行赋值，即对对象内部属性的值的改变</li>\n</ul>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li>commonJS 模块运行时加载，ES6 模块是输出编译时输出接口</li>\n<li>commonJS 模块 require 同步加载模块，ES6 import 是异步的</li>\n<li>commonJS 模块 require 对模块的浅拷贝，ES6 import 是对模块的引入，只存只读不改变其值 指针指向不能变类似 const</li>\n<li>import 接口 read-only 不能改变变量值，</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h1><ul>\n<li>对引入对象进行赋值，即对对象内部属性的值的改变</li>\n</ul>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li>commonJS 模块运行时加载，ES6 模块是输出编译时输出接口</li>\n<li>commonJS 模块 require 同步加载模块，ES6 import 是异步的</li>\n<li>commonJS 模块 require 对模块的浅拷贝，ES6 import 是对模块的引入，只存只读不改变其值 指针指向不能变类似 const</li>\n<li>import 接口 read-only 不能改变变量值，</li>\n</ul>\n"},{"title":"LeetCode 004：寻找两个正序数组的中位数","date":"2023-12-16T13:10:48.053Z","_content":"\n# LeetCode 第 4 号问题：寻找两个正序数组的中位数\n\n### 题目地址\n\n> https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n### 题目描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组  nums1 和  nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。\n\n你可以假设  nums1  和  nums2  不会同时为空。\n\n**示例 1:**\n\n```javascript\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n### 思路\n\n暴力解决方法:拼接后找中位数\n\n### 代码一\n\n```javascript\nconst findMedianSortedArrays = function (nums1, nums2) {\n  let arr = nums1.concat(nums2) // 合并两个数组\n  arr.sort((a, b) => a - b) // 新数组从小到大排序\n  let length = arr.length\n  if (length % 2 == 0) {\n    /**\n     * 数组长度为偶数，输出中间两数之和的平均值\n     */\n    return (arr[length / 2] + arr[length / 2 - 1]) / 2\n  } else {\n    /**\n     * 数组长度为奇数，输出中间数\n     */\n    return arr[(length - 1) / 2]\n  }\n}\n```\n\n### 代码二\n\n代码最少的方法，时间复杂度为 O((m + n)log(m + n))\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst findMedianSortedArrays = function (nums1, nums2) {\n  const arr = [...nums1, ...nums2].sort((a, b) => a - b)\n  const { length } = arr\n  return length % 2\n    ? arr[Math.floor(length / 2)]\n    : (arr[length / 2] + arr[length / 2 - 1]) / 2\n}\n```\n","source":"_posts/leetcode/Array/LeetCode 004：寻找两个正序数组的中位数.md","raw":"---\ntitle: LeetCode 004：寻找两个正序数组的中位数\ndate:\ntags: [leetcode, 栈]\ncategories: [前端, leetcode, 004寻找两个正序数组的中位数]\n---\n\n# LeetCode 第 4 号问题：寻找两个正序数组的中位数\n\n### 题目地址\n\n> https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\n\n### 题目描述\n\n给定两个大小为 m 和 n 的正序（从小到大）数组  nums1 和  nums2。\n\n请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。\n\n你可以假设  nums1  和  nums2  不会同时为空。\n\n**示例 1:**\n\n```javascript\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n```\n\n### 思路\n\n暴力解决方法:拼接后找中位数\n\n### 代码一\n\n```javascript\nconst findMedianSortedArrays = function (nums1, nums2) {\n  let arr = nums1.concat(nums2) // 合并两个数组\n  arr.sort((a, b) => a - b) // 新数组从小到大排序\n  let length = arr.length\n  if (length % 2 == 0) {\n    /**\n     * 数组长度为偶数，输出中间两数之和的平均值\n     */\n    return (arr[length / 2] + arr[length / 2 - 1]) / 2\n  } else {\n    /**\n     * 数组长度为奇数，输出中间数\n     */\n    return arr[(length - 1) / 2]\n  }\n}\n```\n\n### 代码二\n\n代码最少的方法，时间复杂度为 O((m + n)log(m + n))\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst findMedianSortedArrays = function (nums1, nums2) {\n  const arr = [...nums1, ...nums2].sort((a, b) => a - b)\n  const { length } = arr\n  return length % 2\n    ? arr[Math.floor(length / 2)]\n    : (arr[length / 2] + arr[length / 2 - 1]) / 2\n}\n```\n","slug":"leetcode/Array/LeetCode 004：寻找两个正序数组的中位数","published":1,"updated":"2024-10-20T02:02:48.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwm001sm32vhc8f9kr0","content":"<h1 id=\"LeetCode-第-4-号问题：寻找两个正序数组的中位数\"><a href=\"#LeetCode-第-4-号问题：寻找两个正序数组的中位数\" class=\"headerlink\" title=\"LeetCode 第 4 号问题：寻找两个正序数组的中位数\"></a>LeetCode 第 4 号问题：寻找两个正序数组的中位数</h1><h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组  nums1 和  nums2。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。</p>\n<p>你可以假设  nums1  和  nums2  不会同时为空。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 <span class=\"number\">2.0</span></span><br><span class=\"line\">示例 <span class=\"number\">2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 (<span class=\"number\">2</span> + <span class=\"number\">3</span>)/<span class=\"number\">2</span> = <span class=\"number\">2.5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>暴力解决方法:拼接后找中位数</p>\n<h3 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> findMedianSortedArrays = <span class=\"keyword\">function</span> (<span class=\"params\">nums1, nums2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = nums1.<span class=\"title function_\">concat</span>(nums2) <span class=\"comment\">// 合并两个数组</span></span><br><span class=\"line\">  arr.<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b) <span class=\"comment\">// 新数组从小到大排序</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组长度为偶数，输出中间两数之和的平均值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (arr[length / <span class=\"number\">2</span>] + arr[length / <span class=\"number\">2</span> - <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组长度为奇数，输出中间数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[(length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二\"><a href=\"#代码二\" class=\"headerlink\" title=\"代码二\"></a>代码二</h3><p>代码最少的方法，时间复杂度为 O((m + n)log(m + n))</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">nums1</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">nums2</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> findMedianSortedArrays = <span class=\"keyword\">function</span> (<span class=\"params\">nums1, nums2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [...nums1, ...nums2].<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = arr</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length % <span class=\"number\">2</span></span><br><span class=\"line\">    ? arr[<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(length / <span class=\"number\">2</span>)]</span><br><span class=\"line\">    : (arr[length / <span class=\"number\">2</span>] + arr[length / <span class=\"number\">2</span> - <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"LeetCode-第-4-号问题：寻找两个正序数组的中位数\"><a href=\"#LeetCode-第-4-号问题：寻找两个正序数组的中位数\" class=\"headerlink\" title=\"LeetCode 第 4 号问题：寻找两个正序数组的中位数\"></a>LeetCode 第 4 号问题：寻找两个正序数组的中位数</h1><h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组  nums1 和  nums2。</p>\n<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为  O(log(m + n))。</p>\n<p>你可以假设  nums1  和  nums2  不会同时为空。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 <span class=\"number\">2.0</span></span><br><span class=\"line\">示例 <span class=\"number\">2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">nums1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">nums2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">则中位数是 (<span class=\"number\">2</span> + <span class=\"number\">3</span>)/<span class=\"number\">2</span> = <span class=\"number\">2.5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>暴力解决方法:拼接后找中位数</p>\n<h3 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> findMedianSortedArrays = <span class=\"keyword\">function</span> (<span class=\"params\">nums1, nums2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = nums1.<span class=\"title function_\">concat</span>(nums2) <span class=\"comment\">// 合并两个数组</span></span><br><span class=\"line\">  arr.<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b) <span class=\"comment\">// 新数组从小到大排序</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组长度为偶数，输出中间两数之和的平均值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (arr[length / <span class=\"number\">2</span>] + arr[length / <span class=\"number\">2</span> - <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组长度为奇数，输出中间数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[(length - <span class=\"number\">1</span>) / <span class=\"number\">2</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码二\"><a href=\"#代码二\" class=\"headerlink\" title=\"代码二\"></a>代码二</h3><p>代码最少的方法，时间复杂度为 O((m + n)log(m + n))</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">nums1</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">nums2</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> findMedianSortedArrays = <span class=\"keyword\">function</span> (<span class=\"params\">nums1, nums2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [...nums1, ...nums2].<span class=\"title function_\">sort</span>(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = arr</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length % <span class=\"number\">2</span></span><br><span class=\"line\">    ? arr[<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(length / <span class=\"number\">2</span>)]</span><br><span class=\"line\">    : (arr[length / <span class=\"number\">2</span>] + arr[length / <span class=\"number\">2</span> - <span class=\"number\">1</span>]) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"如何提取url的参数","date":"2024-11-09T01:15:04.123Z","_content":"\n```javascript\nlet url = 'https://baidu.com?a=1&b=12&c=info'\nlet getUrlParams = function (URL) {\n  let url = URL.split('?')[1]\n  let urlsearchparam = new URLSearchParams(url)\n  const params = Object.fromEntries(urlsearchparam.entries())\n  return params\n}\nconsole.log(getUrlParams(url))\n```\n","source":"_posts/JavaScript/JavaScript面试/如何提取url的参数.md","raw":"---\ntitle: 如何提取url的参数\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, 如何提取url的参数]\n---\n\n```javascript\nlet url = 'https://baidu.com?a=1&b=12&c=info'\nlet getUrlParams = function (URL) {\n  let url = URL.split('?')[1]\n  let urlsearchparam = new URLSearchParams(url)\n  const params = Object.fromEntries(urlsearchparam.entries())\n  return params\n}\nconsole.log(getUrlParams(url))\n```\n","slug":"JavaScript/JavaScript面试/如何提取url的参数","published":1,"updated":"2024-11-09T01:18:55.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwn001vm32v6gnt55vv","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;https://baidu.com?a=1&amp;b=12&amp;c=info&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getUrlParams = <span class=\"keyword\">function</span> (<span class=\"params\">URL</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = <span class=\"variable constant_\">URL</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;?&#x27;</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> urlsearchparam = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(url)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(urlsearchparam.<span class=\"title function_\">entries</span>())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getUrlParams</span>(url))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;https://baidu.com?a=1&amp;b=12&amp;c=info&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> getUrlParams = <span class=\"keyword\">function</span> (<span class=\"params\">URL</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = <span class=\"variable constant_\">URL</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;?&#x27;</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> urlsearchparam = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(url)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> params = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(urlsearchparam.<span class=\"title function_\">entries</span>())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> params</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getUrlParams</span>(url))</span><br></pre></td></tr></table></figure>\n"},{"title":"输入url,到页面展示的过程","date":"2024-11-09T02:18:23.078Z","_content":"\n# 过程\n\n- 输入 url\n- 浏览器缓存 - 系统缓存 - 路由器缓存 有缓存显示页面内容，没有就往下执行\n- http 请求前 DNS 解析 ip 地址\n- tcp 连接 三次握手 浏览器发送 http 请求 请求数据包\n- 服务器收到请求，返回数据到浏览器\n- http 响应\n- 读取页面内容 渲染 解析代码\n- 生成 DOM 树，解析 css 样式，js 交互，渲染显示页面\n","source":"_posts/JavaScript/JavaScript面试/输入url,到页面展示的过程.md","raw":"---\ntitle: 输入url,到页面展示的过程\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, 输入url, 到页面展示的过程]\n---\n\n# 过程\n\n- 输入 url\n- 浏览器缓存 - 系统缓存 - 路由器缓存 有缓存显示页面内容，没有就往下执行\n- http 请求前 DNS 解析 ip 地址\n- tcp 连接 三次握手 浏览器发送 http 请求 请求数据包\n- 服务器收到请求，返回数据到浏览器\n- http 响应\n- 读取页面内容 渲染 解析代码\n- 生成 DOM 树，解析 css 样式，js 交互，渲染显示页面\n","slug":"JavaScript/JavaScript面试/输入url,到页面展示的过程","published":1,"updated":"2024-11-09T02:23:21.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwn001ym32vebfs6bm7","content":"<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><ul>\n<li>输入 url</li>\n<li>浏览器缓存 - 系统缓存 - 路由器缓存 有缓存显示页面内容，没有就往下执行</li>\n<li>http 请求前 DNS 解析 ip 地址</li>\n<li>tcp 连接 三次握手 浏览器发送 http 请求 请求数据包</li>\n<li>服务器收到请求，返回数据到浏览器</li>\n<li>http 响应</li>\n<li>读取页面内容 渲染 解析代码</li>\n<li>生成 DOM 树，解析 css 样式，js 交互，渲染显示页面</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h1><ul>\n<li>输入 url</li>\n<li>浏览器缓存 - 系统缓存 - 路由器缓存 有缓存显示页面内容，没有就往下执行</li>\n<li>http 请求前 DNS 解析 ip 地址</li>\n<li>tcp 连接 三次握手 浏览器发送 http 请求 请求数据包</li>\n<li>服务器收到请求，返回数据到浏览器</li>\n<li>http 响应</li>\n<li>读取页面内容 渲染 解析代码</li>\n<li>生成 DOM 树，解析 css 样式，js 交互，渲染显示页面</li>\n</ul>\n"},{"title":"LeetCode 011：盛最多水的容器","date":"2023-12-17T08:32:28.608Z","_content":"\n### 题目地址\n\n> https://leetcode.cn/problems/container-with-most-water/\n\n### 题目描述\n\n```\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n说明：你不能倾斜容器。\n示例 1：\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例 2：\n\n输入：height = [1,1]\n输出：1\n\n```\n\n### 解答\n\n#### 代码一\n\n```javascript\nvar maxArea = function (height) {\n  let len = height.length\n  if (len <= 1) return 0\n  let result = 0,\n    i = 0,\n    j = len - 1\n  while (i < j) {\n    let sum = Math.min(height[i], height[j]) * (j - i)\n    result = Math.max(result, sum)\n    if (height[i] < height[j]) {\n      i++\n    } else {\n      j--\n    }\n  }\n  return result\n}\n```\n","source":"_posts/leetcode/Array/LeetCode 011：盛最多水的容器.md","raw":"---\ntitle: LeetCode 011：盛最多水的容器\ndate:\ntags: [leetcode, 数组]\ncategories: [前端, leetcode, 020盛最多水的容器]\n---\n\n### 题目地址\n\n> https://leetcode.cn/problems/container-with-most-water/\n\n### 题目描述\n\n```\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n说明：你不能倾斜容器。\n示例 1：\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例 2：\n\n输入：height = [1,1]\n输出：1\n\n```\n\n### 解答\n\n#### 代码一\n\n```javascript\nvar maxArea = function (height) {\n  let len = height.length\n  if (len <= 1) return 0\n  let result = 0,\n    i = 0,\n    j = len - 1\n  while (i < j) {\n    let sum = Math.min(height[i], height[j]) * (j - i)\n    result = Math.max(result, sum)\n    if (height[i] < height[j]) {\n      i++\n    } else {\n      j--\n    }\n  }\n  return result\n}\n```\n","slug":"leetcode/Array/LeetCode 011：盛最多水的容器","published":1,"updated":"2023-12-17T08:34:00.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwo0021m32vhzjeg88v","content":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/container-with-most-water/\">https://leetcode.cn/problems/container-with-most-water/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span><br><span class=\"line\"></span><br><span class=\"line\">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class=\"line\"></span><br><span class=\"line\">返回容器可以储存的最大水量。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：你不能倾斜容器。</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：height = [1,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><h4 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"keyword\">function</span> (<span class=\"params\">height</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = height.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>,</span><br><span class=\"line\">    i = <span class=\"number\">0</span>,</span><br><span class=\"line\">    j = len - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(height[i], height[j]) * (j - i)</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(result, sum)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/container-with-most-water/\">https://leetcode.cn/problems/container-with-most-water/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span><br><span class=\"line\"></span><br><span class=\"line\">找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class=\"line\"></span><br><span class=\"line\">返回容器可以储存的最大水量。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：你不能倾斜容器。</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class=\"line\">输出：49</span><br><span class=\"line\">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：height = [1,1]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><h4 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxArea = <span class=\"keyword\">function</span> (<span class=\"params\">height</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = height.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>,</span><br><span class=\"line\">    i = <span class=\"number\">0</span>,</span><br><span class=\"line\">    j = len - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(height[i], height[j]) * (j - i)</span><br><span class=\"line\">    result = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(result, sum)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode 020：有效的括号","date":"2023-08-27T10:07:39.718Z","_content":"\n### 题目描述\n\n[有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']'  的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 每个右括号都有一个对应的相同类型的左括号。\n\n#### 示例 1：\n\n```\n输入：s = \"()\"\n输出：true\n```\n\n#### 示例  2：\n\n```\n输入：s = \"()[]{}\"\n输出：true\n```\n\n#### 示例  3：\n\n```\n输入：s = \"(]\"\n输出：false\n```\n\n### Map 解答\n\n```javascript\nconst isValid = function (s) {\n  if (s.length == 1) {\n    return false\n  }\n  const sVar = new Map([\n    ['(', ')'],\n    ['[', ']'],\n    ['{', '}'],\n  ])\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    if (sVar.has(s[i])) {\n      stack.push(s[i])\n    } else if (sVar.get(stack[stack.length - 1]) == s[i]) {\n      stack.pop()\n    } else {\n      // stack.push(s[i])\n      return false\n    }\n  }\n  if (stack.length == 0) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n","source":"_posts/leetcode/Stack/LeetCode 020：有效的括号.md","raw":"---\ntitle: LeetCode 020：有效的括号\ndate:\ntags: [leetcode, 栈]\ncategories: [前端, leetcode, 020有效的括号]\n---\n\n### 题目描述\n\n[有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']'  的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 每个右括号都有一个对应的相同类型的左括号。\n\n#### 示例 1：\n\n```\n输入：s = \"()\"\n输出：true\n```\n\n#### 示例  2：\n\n```\n输入：s = \"()[]{}\"\n输出：true\n```\n\n#### 示例  3：\n\n```\n输入：s = \"(]\"\n输出：false\n```\n\n### Map 解答\n\n```javascript\nconst isValid = function (s) {\n  if (s.length == 1) {\n    return false\n  }\n  const sVar = new Map([\n    ['(', ')'],\n    ['[', ']'],\n    ['{', '}'],\n  ])\n  const stack = []\n  for (let i = 0; i < s.length; i++) {\n    if (sVar.has(s[i])) {\n      stack.push(s[i])\n    } else if (sVar.get(stack[stack.length - 1]) == s[i]) {\n      stack.pop()\n    } else {\n      // stack.push(s[i])\n      return false\n    }\n  }\n  if (stack.length == 0) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n","slug":"leetcode/Stack/LeetCode 020：有效的括号","published":1,"updated":"2023-08-27T10:10:03.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwo0024m32v58hqcafm","content":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p><a href=\"https://leetcode.cn/problems/valid-parentheses/\">有效的括号</a></p>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’  的字符串 s ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<h4 id=\"示例-1：\"><a href=\"#示例-1：\" class=\"headerlink\" title=\"示例 1：\"></a>示例 1：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-2：\"><a href=\"#示例-2：\" class=\"headerlink\" title=\"示例  2：\"></a>示例  2：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-3：\"><a href=\"#示例-3：\" class=\"headerlink\" title=\"示例  3：\"></a>示例  3：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;(]&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-解答\"><a href=\"#Map-解答\" class=\"headerlink\" title=\"Map 解答\"></a>Map 解答</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isValid = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sVar = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">    [<span class=\"string\">&#x27;(&#x27;</span>, <span class=\"string\">&#x27;)&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;[&#x27;</span>, <span class=\"string\">&#x27;]&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;&#123;&#x27;</span>, <span class=\"string\">&#x27;&#125;&#x27;</span>],</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sVar.<span class=\"title function_\">has</span>(s[i])) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(s[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sVar.<span class=\"title function_\">get</span>(stack[stack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]) == s[i]) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// stack.push(s[i])</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack.<span class=\"property\">length</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p><a href=\"https://leetcode.cn/problems/valid-parentheses/\">有效的括号</a></p>\n<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’  的字符串 s ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n<h4 id=\"示例-1：\"><a href=\"#示例-1：\" class=\"headerlink\" title=\"示例 1：\"></a>示例 1：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-2：\"><a href=\"#示例-2：\" class=\"headerlink\" title=\"示例  2：\"></a>示例  2：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-3：\"><a href=\"#示例-3：\" class=\"headerlink\" title=\"示例  3：\"></a>示例  3：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;(]&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-解答\"><a href=\"#Map-解答\" class=\"headerlink\" title=\"Map 解答\"></a>Map 解答</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isValid = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> sVar = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">    [<span class=\"string\">&#x27;(&#x27;</span>, <span class=\"string\">&#x27;)&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;[&#x27;</span>, <span class=\"string\">&#x27;]&#x27;</span>],</span><br><span class=\"line\">    [<span class=\"string\">&#x27;&#123;&#x27;</span>, <span class=\"string\">&#x27;&#125;&#x27;</span>],</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stack = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sVar.<span class=\"title function_\">has</span>(s[i])) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">push</span>(s[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sVar.<span class=\"title function_\">get</span>(stack[stack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]) == s[i]) &#123;</span><br><span class=\"line\">      stack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// stack.push(s[i])</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack.<span class=\"property\">length</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"前端白屏时间长的原因有哪些，怎么优化","date":"2024-11-09T01:38:25.005Z","_content":"\n# 白屏时间\n\n> 空白->显示第一个画面时间\n\n# 重要性\n\n提升用户体验，减少用户跳出，提升整体页面的留存率\n\n# 原因\n\n- css 放在 head 里，阻塞渲染，加载时间长会出现页面长时间白屏\n- js 加载和执行会阻塞页面解析和渲染\n\n# 优化\n\n- DNS 解析\n  - DNS 缓存优化\n  - DNS 预加载策略\n  - 确定可靠的 DNS 服务器\n- 对浏览器页面的下载 解析 渲染过程\n  - 尽可能精简 HTML 代码和结构\n  - 尽可能优化 css 文件和结构\n  - 合理放置 js 代码 尽量不要使用内敛 js\n  - 将渲染首屏 css 内敛到 html 中 快速下载 css\n  - 延迟首屏不需要的图片加载 优先加载首屏所需的图片\n- 文件体积\n  - 尽量减少 css js 体积，放在 head 标签\n  - js defer 属性：先加载后执行不阻塞代码执行\n","source":"_posts/JavaScript/JavaScript面试/白屏时间.md","raw":"---\ntitle: 前端白屏时间长的原因有哪些，怎么优化\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, 前端白屏时间长的原因有哪些，怎么优化]\n---\n\n# 白屏时间\n\n> 空白->显示第一个画面时间\n\n# 重要性\n\n提升用户体验，减少用户跳出，提升整体页面的留存率\n\n# 原因\n\n- css 放在 head 里，阻塞渲染，加载时间长会出现页面长时间白屏\n- js 加载和执行会阻塞页面解析和渲染\n\n# 优化\n\n- DNS 解析\n  - DNS 缓存优化\n  - DNS 预加载策略\n  - 确定可靠的 DNS 服务器\n- 对浏览器页面的下载 解析 渲染过程\n  - 尽可能精简 HTML 代码和结构\n  - 尽可能优化 css 文件和结构\n  - 合理放置 js 代码 尽量不要使用内敛 js\n  - 将渲染首屏 css 内敛到 html 中 快速下载 css\n  - 延迟首屏不需要的图片加载 优先加载首屏所需的图片\n- 文件体积\n  - 尽量减少 css js 体积，放在 head 标签\n  - js defer 属性：先加载后执行不阻塞代码执行\n","slug":"JavaScript/JavaScript面试/白屏时间","published":1,"updated":"2024-11-09T01:50:21.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwp0027m32vcy031zwg","content":"<h1 id=\"白屏时间\"><a href=\"#白屏时间\" class=\"headerlink\" title=\"白屏时间\"></a>白屏时间</h1><blockquote>\n<p>空白-&gt;显示第一个画面时间</p>\n</blockquote>\n<h1 id=\"重要性\"><a href=\"#重要性\" class=\"headerlink\" title=\"重要性\"></a>重要性</h1><p>提升用户体验，减少用户跳出，提升整体页面的留存率</p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><ul>\n<li>css 放在 head 里，阻塞渲染，加载时间长会出现页面长时间白屏</li>\n<li>js 加载和执行会阻塞页面解析和渲染</li>\n</ul>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><ul>\n<li>DNS 解析<ul>\n<li>DNS 缓存优化</li>\n<li>DNS 预加载策略</li>\n<li>确定可靠的 DNS 服务器</li>\n</ul>\n</li>\n<li>对浏览器页面的下载 解析 渲染过程<ul>\n<li>尽可能精简 HTML 代码和结构</li>\n<li>尽可能优化 css 文件和结构</li>\n<li>合理放置 js 代码 尽量不要使用内敛 js</li>\n<li>将渲染首屏 css 内敛到 html 中 快速下载 css</li>\n<li>延迟首屏不需要的图片加载 优先加载首屏所需的图片</li>\n</ul>\n</li>\n<li>文件体积<ul>\n<li>尽量减少 css js 体积，放在 head 标签</li>\n<li>js defer 属性：先加载后执行不阻塞代码执行</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"白屏时间\"><a href=\"#白屏时间\" class=\"headerlink\" title=\"白屏时间\"></a>白屏时间</h1><blockquote>\n<p>空白-&gt;显示第一个画面时间</p>\n</blockquote>\n<h1 id=\"重要性\"><a href=\"#重要性\" class=\"headerlink\" title=\"重要性\"></a>重要性</h1><p>提升用户体验，减少用户跳出，提升整体页面的留存率</p>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><ul>\n<li>css 放在 head 里，阻塞渲染，加载时间长会出现页面长时间白屏</li>\n<li>js 加载和执行会阻塞页面解析和渲染</li>\n</ul>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><ul>\n<li>DNS 解析<ul>\n<li>DNS 缓存优化</li>\n<li>DNS 预加载策略</li>\n<li>确定可靠的 DNS 服务器</li>\n</ul>\n</li>\n<li>对浏览器页面的下载 解析 渲染过程<ul>\n<li>尽可能精简 HTML 代码和结构</li>\n<li>尽可能优化 css 文件和结构</li>\n<li>合理放置 js 代码 尽量不要使用内敛 js</li>\n<li>将渲染首屏 css 内敛到 html 中 快速下载 css</li>\n<li>延迟首屏不需要的图片加载 优先加载首屏所需的图片</li>\n</ul>\n</li>\n<li>文件体积<ul>\n<li>尽量减少 css js 体积，放在 head 标签</li>\n<li>js defer 属性：先加载后执行不阻塞代码执行</li>\n</ul>\n</li>\n</ul>\n"},{"title":"LeetCode 039：组合总和","date":"2023-08-25T01:00:31.147Z","_content":"\n# 题目地址\n\n> https://leetcode.cn/problems/combination-sum/\n\n# 题目描述\n\n```\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n\n\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n\n示例 2：\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n\n示例 3：\n\n输入: candidates = [2], target = 1\n输出: []\n\n```\n\n# 解法\n\n### 思路\n\n### 代码\n\n```javascript\n\n```\n","source":"_posts/leetcode/String/ LeetCode 039：组合总和.md","raw":"---\ntitle: LeetCode 039：组合总和\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 039组合总和]\n---\n\n# 题目地址\n\n> https://leetcode.cn/problems/combination-sum/\n\n# 题目描述\n\n```\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n\n\n示例 1：\n\n输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n\n示例 2：\n\n输入: candidates = [2,3,5], target = 8\n输出: [[2,2,2,2],[2,3,3],[3,5]]\n\n示例 3：\n\n输入: candidates = [2], target = 1\n输出: []\n\n```\n\n# 解法\n\n### 思路\n\n### 代码\n\n```javascript\n\n```\n","slug":"leetcode/String/ LeetCode 039：组合总和","published":1,"updated":"2023-08-25T01:02:25.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwp002am32v31iq3b39","content":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/combination-sum/\">https://leetcode.cn/problems/combination-sum/</a></p>\n</blockquote>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span><br><span class=\"line\"></span><br><span class=\"line\">对于给定的输入，保证和为 target 的不同组合数少于 150 个。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：candidates = [2,3,6,7], target = 7</span><br><span class=\"line\">输出：[[2,2,3],[7]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class=\"line\">7 也是一个候选， 7 = 7 。</span><br><span class=\"line\">仅有这两种组合。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,5], target = 8</span><br><span class=\"line\">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2], target = 1</span><br><span class=\"line\">输出: []</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h1><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/combination-sum/\">https://leetcode.cn/problems/combination-sum/</a></p>\n</blockquote>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span><br><span class=\"line\"></span><br><span class=\"line\">对于给定的输入，保证和为 target 的不同组合数少于 150 个。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：candidates = [2,3,6,7], target = 7</span><br><span class=\"line\">输出：[[2,2,3],[7]]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class=\"line\">7 也是一个候选， 7 = 7 。</span><br><span class=\"line\">仅有这两种组合。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,5], target = 8</span><br><span class=\"line\">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2], target = 1</span><br><span class=\"line\">输出: []</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h1><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode 003：无重复字符的最长子串","date":"2023-08-19T01:22:20.479Z","_content":"\n### 题目地址\n\n> https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\n\n### 题目描述\n\n```md\n给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。\n\n示例  1:\n\n输入: \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是  \"wke\"，所以其长度为 3。\n  请注意，你的答案必须是 子串 的长度，\"pwke\"  是一个子序列，不是子串。\n```\n\n### 解法 滑动窗口+双指针\n\n#### 思路\n\n- 1. 因为需要找无重复的子串，我们可以定义初始化的子串是第一个字符，也就是 `let newStr = str[0]`。\n- 2. 然后我们每次往后去加一个字符也就是 str[i]。\n- 3. 这时候就需要判断 str[i]是否在 newStr 中，并且知道它所在的位置，`let j = newStr.indexOf(str[i]);`。\n- 4. 如果 j 为-1 就是 newStr 不存在 str[i],就是把 str[i]的数据加到 newStr 的后面，`newStr = newStr + str[i]`;否则，从 j 的位置删除前面的数据后，再加上 str[i]，`newStr = newStr.substring(j+1,newStr.length);newStr = newStr + str[i]`\n- 5. 最后将存的最大值和当前的最大值比较。\n- 6. 循环上述操作，从而得出最后的最大值 max。\n\n#### 代码一\n\n> 使用方法：indexOf + substring + Math.max\n\n```javascript\n/**\n * @param {string} str\n * @return {number}\n */\nconst lengthOfLongestSubstring = function (str) {\n  let len = str.length\n  if (len <= 1) {\n    return len\n  }\n  let newStr = str[0]\n  let max = 1\n  for (let i = 1; i < len; i++) {\n    let j = newStr.indexOf(str[i])\n    if (j !== -1) newStr = newStr.substring(j + 1, newStr.length)\n    newStr = newStr + str[i]\n    max = Math.max(max, newStr.length)\n  }\n  return max\n}\n```\n\n#### 代码二\n\n> 使用方法：push + splice + indexOf + charAt + Math.max\n\n代码二的逻辑基本与代码一一致，唯一区别在于方法的使用\n\n```javascript\nconst lengthOfLongestSubstring = function (s) {\n  let arr = [],\n    max = 0\n  for (let i = 0; i < s.length; i++) {\n    let index = arr.indexOf(s[i])\n    if (index !== -1) {\n      arr.splice(0, index + 1)\n    }\n    arr.push(s.charAt(i))\n    max = Math.max(arr.length, max)\n  }\n  return max\n}\n```\n\n#### 代码三\n\n> 使用方法：Map 数据结构 + Math.max\n\n代码三的思路也是与代码一一致，优点：indexOf 会自带循环获取下标的逻辑，时间上会比 Map 慢\n\n```javascript\nconst lengthOfLongestSubstring = function (s) {\n  let map = new Map(),\n    max = 0\n  for (let i = 0, j = 0; j < s.length; j++) {\n    if (map.has(s[j])) {\n      i = Math.max(map.get(s[j]) + 1, i)\n    }\n    max = Math.max(max, j - i + 1)\n    map.set(s[j], j)\n  }\n  return max\n}\n```\n","source":"_posts/leetcode/String/LeetCode 003：无重复字符的最长子串.md","raw":"---\ntitle: LeetCode 003：无重复字符的最长子串\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 003无重复字符的最长子串]\n---\n\n### 题目地址\n\n> https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\n\n### 题目描述\n\n```md\n给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。\n\n示例  1:\n\n输入: \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是  \"wke\"，所以其长度为 3。\n  请注意，你的答案必须是 子串 的长度，\"pwke\"  是一个子序列，不是子串。\n```\n\n### 解法 滑动窗口+双指针\n\n#### 思路\n\n- 1. 因为需要找无重复的子串，我们可以定义初始化的子串是第一个字符，也就是 `let newStr = str[0]`。\n- 2. 然后我们每次往后去加一个字符也就是 str[i]。\n- 3. 这时候就需要判断 str[i]是否在 newStr 中，并且知道它所在的位置，`let j = newStr.indexOf(str[i]);`。\n- 4. 如果 j 为-1 就是 newStr 不存在 str[i],就是把 str[i]的数据加到 newStr 的后面，`newStr = newStr + str[i]`;否则，从 j 的位置删除前面的数据后，再加上 str[i]，`newStr = newStr.substring(j+1,newStr.length);newStr = newStr + str[i]`\n- 5. 最后将存的最大值和当前的最大值比较。\n- 6. 循环上述操作，从而得出最后的最大值 max。\n\n#### 代码一\n\n> 使用方法：indexOf + substring + Math.max\n\n```javascript\n/**\n * @param {string} str\n * @return {number}\n */\nconst lengthOfLongestSubstring = function (str) {\n  let len = str.length\n  if (len <= 1) {\n    return len\n  }\n  let newStr = str[0]\n  let max = 1\n  for (let i = 1; i < len; i++) {\n    let j = newStr.indexOf(str[i])\n    if (j !== -1) newStr = newStr.substring(j + 1, newStr.length)\n    newStr = newStr + str[i]\n    max = Math.max(max, newStr.length)\n  }\n  return max\n}\n```\n\n#### 代码二\n\n> 使用方法：push + splice + indexOf + charAt + Math.max\n\n代码二的逻辑基本与代码一一致，唯一区别在于方法的使用\n\n```javascript\nconst lengthOfLongestSubstring = function (s) {\n  let arr = [],\n    max = 0\n  for (let i = 0; i < s.length; i++) {\n    let index = arr.indexOf(s[i])\n    if (index !== -1) {\n      arr.splice(0, index + 1)\n    }\n    arr.push(s.charAt(i))\n    max = Math.max(arr.length, max)\n  }\n  return max\n}\n```\n\n#### 代码三\n\n> 使用方法：Map 数据结构 + Math.max\n\n代码三的思路也是与代码一一致，优点：indexOf 会自带循环获取下标的逻辑，时间上会比 Map 慢\n\n```javascript\nconst lengthOfLongestSubstring = function (s) {\n  let map = new Map(),\n    max = 0\n  for (let i = 0, j = 0; j < s.length; j++) {\n    if (map.has(s[j])) {\n      i = Math.max(map.get(s[j]) + 1, i)\n    }\n    max = Math.max(max, j - i + 1)\n    map.set(s[j], j)\n  }\n  return max\n}\n```\n","slug":"leetcode/String/LeetCode 003：无重复字符的最长子串","published":1,"updated":"2023-08-19T01:24:22.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwq002dm32v43vzdi54","content":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\">https://leetcode.com/problems/longest-substring-without-repeating-characters/description/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">示例  1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是  &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">  请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;  是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法-滑动窗口-双指针\"><a href=\"#解法-滑动窗口-双指针\" class=\"headerlink\" title=\"解法 滑动窗口+双指针\"></a>解法 滑动窗口+双指针</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><ol>\n<li>因为需要找无重复的子串，我们可以定义初始化的子串是第一个字符，也就是 <code>let newStr = str[0]</code>。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>然后我们每次往后去加一个字符也就是 str[i]。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>这时候就需要判断 str[i]是否在 newStr 中，并且知道它所在的位置，<code>let j = newStr.indexOf(str[i]);</code>。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>如果 j 为-1 就是 newStr 不存在 str[i],就是把 str[i]的数据加到 newStr 的后面，<code>newStr = newStr + str[i]</code>;否则，从 j 的位置删除前面的数据后，再加上 str[i]，<code>newStr = newStr.substring(j+1,newStr.length);newStr = newStr + str[i]</code></li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>最后将存的最大值和当前的最大值比较。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>循环上述操作，从而得出最后的最大值 max。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h4><blockquote>\n<p>使用方法：indexOf + substring + Math.max</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">string</span>&#125; <span class=\"variable\">str</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = str.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStr = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = newStr.<span class=\"title function_\">indexOf</span>(str[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j !== -<span class=\"number\">1</span>) newStr = newStr.<span class=\"title function_\">substring</span>(j + <span class=\"number\">1</span>, newStr.<span class=\"property\">length</span>)</span><br><span class=\"line\">    newStr = newStr + str[i]</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, newStr.<span class=\"property\">length</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码二\"><a href=\"#代码二\" class=\"headerlink\" title=\"代码二\"></a>代码二</h4><blockquote>\n<p>使用方法：push + splice + indexOf + charAt + Math.max</p>\n</blockquote>\n<p>代码二的逻辑基本与代码一一致，唯一区别在于方法的使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [],</span><br><span class=\"line\">    max = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = arr.<span class=\"title function_\">indexOf</span>(s[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      arr.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.<span class=\"title function_\">push</span>(s.<span class=\"title function_\">charAt</span>(i))</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(arr.<span class=\"property\">length</span>, max)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码三\"><a href=\"#代码三\" class=\"headerlink\" title=\"代码三\"></a>代码三</h4><blockquote>\n<p>使用方法：Map 数据结构 + Math.max</p>\n</blockquote>\n<p>代码三的思路也是与代码一一致，优点：indexOf 会自带循环获取下标的逻辑，时间上会比 Map 慢</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(),</span><br><span class=\"line\">    max = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; j &lt; s.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.<span class=\"title function_\">has</span>(s[j])) &#123;</span><br><span class=\"line\">      i = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(map.<span class=\"title function_\">get</span>(s[j]) + <span class=\"number\">1</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(s[j], j)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/description/\">https://leetcode.com/problems/longest-substring-without-repeating-characters/description/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个字符串，请你找出其中不含有重复字符的   最长子串   的长度。</span><br><span class=\"line\"></span><br><span class=\"line\">示例  1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是  &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">  请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;  是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法-滑动窗口-双指针\"><a href=\"#解法-滑动窗口-双指针\" class=\"headerlink\" title=\"解法 滑动窗口+双指针\"></a>解法 滑动窗口+双指针</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><ol>\n<li>因为需要找无重复的子串，我们可以定义初始化的子串是第一个字符，也就是 <code>let newStr = str[0]</code>。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>然后我们每次往后去加一个字符也就是 str[i]。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>这时候就需要判断 str[i]是否在 newStr 中，并且知道它所在的位置，<code>let j = newStr.indexOf(str[i]);</code>。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>如果 j 为-1 就是 newStr 不存在 str[i],就是把 str[i]的数据加到 newStr 的后面，<code>newStr = newStr + str[i]</code>;否则，从 j 的位置删除前面的数据后，再加上 str[i]，<code>newStr = newStr.substring(j+1,newStr.length);newStr = newStr + str[i]</code></li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>最后将存的最大值和当前的最大值比较。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>循环上述操作，从而得出最后的最大值 max。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"代码一\"><a href=\"#代码一\" class=\"headerlink\" title=\"代码一\"></a>代码一</h4><blockquote>\n<p>使用方法：indexOf + substring + Math.max</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">string</span>&#125; <span class=\"variable\">str</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = str.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newStr = str[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> max = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = newStr.<span class=\"title function_\">indexOf</span>(str[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j !== -<span class=\"number\">1</span>) newStr = newStr.<span class=\"title function_\">substring</span>(j + <span class=\"number\">1</span>, newStr.<span class=\"property\">length</span>)</span><br><span class=\"line\">    newStr = newStr + str[i]</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, newStr.<span class=\"property\">length</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码二\"><a href=\"#代码二\" class=\"headerlink\" title=\"代码二\"></a>代码二</h4><blockquote>\n<p>使用方法：push + splice + indexOf + charAt + Math.max</p>\n</blockquote>\n<p>代码二的逻辑基本与代码一一致，唯一区别在于方法的使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = [],</span><br><span class=\"line\">    max = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = arr.<span class=\"title function_\">indexOf</span>(s[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      arr.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, index + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr.<span class=\"title function_\">push</span>(s.<span class=\"title function_\">charAt</span>(i))</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(arr.<span class=\"property\">length</span>, max)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码三\"><a href=\"#代码三\" class=\"headerlink\" title=\"代码三\"></a>代码三</h4><blockquote>\n<p>使用方法：Map 数据结构 + Math.max</p>\n</blockquote>\n<p>代码三的思路也是与代码一一致，优点：indexOf 会自带循环获取下标的逻辑，时间上会比 Map 慢</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lengthOfLongestSubstring = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(),</span><br><span class=\"line\">    max = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; j &lt; s.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map.<span class=\"title function_\">has</span>(s[j])) &#123;</span><br><span class=\"line\">      i = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(map.<span class=\"title function_\">get</span>(s[j]) + <span class=\"number\">1</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    max = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(max, j - i + <span class=\"number\">1</span>)</span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(s[j], j)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode 005：最长回文子串","date":"2023-08-22T03:52:50.530Z","_content":"\n### 题目地址\n\n> [https://leetcode.cn/problems/longest-palindromic-substring/](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n### 题目描述\n\n```\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n示例 1：\n\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n### 解法一 中心扩散法\n\n#### 由简入繁\n\n先看一个最简单的字符串，比如'aabaaabaa'；\n\n1. 第一步,i=0,这时候 res='a',如果回文子串长度是奇数，左边无值，右边有值，这时候最长回文子串是'a'，如果回文子串长度是偶数，res='aa'这时候最长回文子串是'aa';\n2. 第二步,i=1,这时候 res='a',如果回文子串长度是奇数,左边有一个值'a',右边的值为'b'，这时候当前 i 位置最长回文子串是'a',如果回文子串长度是偶数，res='aa'或者 res='ab'这时候最长回文子串是'aa';\n3. 第三步,i=2,这时候 res='b',如果回文子串长度是奇数,左边第一个值'a',右边第一个值为'a'，res='aba',左边第二个值'a'，右边第二个值'a'，res='aabaa',这时候最长回文子串还是'aabaa',如果回文子串长度是偶数,最长的长度为 1;\n4. 第四步,i=3,...这时候最长回文子串还是第三步的'aabaa';\n5. 第五步,i=4,这时候 res='a' ... 这时候最长回文子串还是第三步的'aabaaabaa';\n   ....\n\n#### 思路\n\n- 1. 如果 s 的长度是 1 或者 0 的时候，s 的最长回文子串就是它本身，例如'a',直接返回 s。\n\n```javascript\nif (s.length < 2) {\n  return s\n}\n```\n\n- 2. 遍历整个 s\n     例:s 字符串 'acaca',遍历字符串，区分 i 为奇数和偶数的情况；\n     在 s 的范围内（所以需要 `m>=0 ,n<s.length`），从中心往两边去遍历，如果`s[m] == s[n]`,如果如果此时回文字符串的长度大于之前最大长度则取 n-m-1\n\n```javascript\nconst longestPalindrome = function (s) {\n  if (s.length < 2) {\n    return s\n  }\n  let res = ''\n  for (let i = 0; i < s.length; i++) {\n    // 回文子串长度是奇数\n    helper(i, i)\n    // 回文子串长度是偶数\n    helper(i, i + 1)\n  }\n\n  function helper(m, n) {\n    while (m >= 0 && n < s.length && s[m] == s[n]) {\n      m--\n      n++\n    }\n    // 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻\n    // 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1\n    if (n - m - 1 > res.length) {\n      // slice也要取[m+1,n-1]这个区间\n      res = s.slice(m + 1, n)\n    }\n  }\n  return res\n}\n```\n\n### 解法二 动态规划\n\n### 思路\n\n1. 状态定义\n   dp[i,j]：字符串 s 从索引 i 到 j 的子串是否是回文串\n\n- true： s[i,j] 是回文串\n- false：s[i,j] 不是回文串\n\n2. 转移方程\n   dp[i][j] = dp[i+1][j-1] && s[i] == s[j]\n\n- s[i] == s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度\n- dp[i+1][j-1]：true\n  - 说明 s[i,j]的**子串 s[i+1][j-1]**也是回文串\n  - 说明，i 是从最大值开始遍历的，j 是从最小值开始遍历的\n- 特殊情况\n  - j===i：s[i]和是[j]值是同一个值\n  - j - i === 1:表示 s[i]和是[j]为相邻值，则需要是 s[i]===s[j]\n\n### 代码\n\n```javascript\nconst longestPalindrome = function (s) {\n  if (!s || s.length < 2) return s\n  let res = s[0]\n  const dp = []\n  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]\n  for (let i = s.length - 1; i >= 0; i--) {\n    dp[i] = []\n    for (let j = i; j < s.length; j++) {\n      if (j - i === 0) dp[i][j] = true // j===i的时候，值是同一个值\n      // specail case 1\n      else if (j - i === 1 && s[i] === s[j])\n        dp[i][\n          j\n        ] = true // j - i === 1的时候，表示s[i]和是[j]为相邻值，则需要是s[i]===s[j]\n      // specail case 2\n      else if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        // 所有的i+1和j-1为true,并且s[i] === s[j]\n        // state transition\n        dp[i][j] = true\n      }\n\n      if (dp[i][j] && j - i + 1 > res.length) {\n        // update res\n        res = s.slice(i, j + 1)\n      }\n    }\n  }\n\n  return res\n}\n```\n","source":"_posts/leetcode/String/LeetCode 005：最长回文子串.md","raw":"---\ntitle: LeetCode 005：最长回文子串\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 005最长回文子串]\n---\n\n### 题目地址\n\n> [https://leetcode.cn/problems/longest-palindromic-substring/](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n### 题目描述\n\n```\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n示例 1：\n\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n### 解法一 中心扩散法\n\n#### 由简入繁\n\n先看一个最简单的字符串，比如'aabaaabaa'；\n\n1. 第一步,i=0,这时候 res='a',如果回文子串长度是奇数，左边无值，右边有值，这时候最长回文子串是'a'，如果回文子串长度是偶数，res='aa'这时候最长回文子串是'aa';\n2. 第二步,i=1,这时候 res='a',如果回文子串长度是奇数,左边有一个值'a',右边的值为'b'，这时候当前 i 位置最长回文子串是'a',如果回文子串长度是偶数，res='aa'或者 res='ab'这时候最长回文子串是'aa';\n3. 第三步,i=2,这时候 res='b',如果回文子串长度是奇数,左边第一个值'a',右边第一个值为'a'，res='aba',左边第二个值'a'，右边第二个值'a'，res='aabaa',这时候最长回文子串还是'aabaa',如果回文子串长度是偶数,最长的长度为 1;\n4. 第四步,i=3,...这时候最长回文子串还是第三步的'aabaa';\n5. 第五步,i=4,这时候 res='a' ... 这时候最长回文子串还是第三步的'aabaaabaa';\n   ....\n\n#### 思路\n\n- 1. 如果 s 的长度是 1 或者 0 的时候，s 的最长回文子串就是它本身，例如'a',直接返回 s。\n\n```javascript\nif (s.length < 2) {\n  return s\n}\n```\n\n- 2. 遍历整个 s\n     例:s 字符串 'acaca',遍历字符串，区分 i 为奇数和偶数的情况；\n     在 s 的范围内（所以需要 `m>=0 ,n<s.length`），从中心往两边去遍历，如果`s[m] == s[n]`,如果如果此时回文字符串的长度大于之前最大长度则取 n-m-1\n\n```javascript\nconst longestPalindrome = function (s) {\n  if (s.length < 2) {\n    return s\n  }\n  let res = ''\n  for (let i = 0; i < s.length; i++) {\n    // 回文子串长度是奇数\n    helper(i, i)\n    // 回文子串长度是偶数\n    helper(i, i + 1)\n  }\n\n  function helper(m, n) {\n    while (m >= 0 && n < s.length && s[m] == s[n]) {\n      m--\n      n++\n    }\n    // 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻\n    // 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1\n    if (n - m - 1 > res.length) {\n      // slice也要取[m+1,n-1]这个区间\n      res = s.slice(m + 1, n)\n    }\n  }\n  return res\n}\n```\n\n### 解法二 动态规划\n\n### 思路\n\n1. 状态定义\n   dp[i,j]：字符串 s 从索引 i 到 j 的子串是否是回文串\n\n- true： s[i,j] 是回文串\n- false：s[i,j] 不是回文串\n\n2. 转移方程\n   dp[i][j] = dp[i+1][j-1] && s[i] == s[j]\n\n- s[i] == s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度\n- dp[i+1][j-1]：true\n  - 说明 s[i,j]的**子串 s[i+1][j-1]**也是回文串\n  - 说明，i 是从最大值开始遍历的，j 是从最小值开始遍历的\n- 特殊情况\n  - j===i：s[i]和是[j]值是同一个值\n  - j - i === 1:表示 s[i]和是[j]为相邻值，则需要是 s[i]===s[j]\n\n### 代码\n\n```javascript\nconst longestPalindrome = function (s) {\n  if (!s || s.length < 2) return s\n  let res = s[0]\n  const dp = []\n  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]\n  for (let i = s.length - 1; i >= 0; i--) {\n    dp[i] = []\n    for (let j = i; j < s.length; j++) {\n      if (j - i === 0) dp[i][j] = true // j===i的时候，值是同一个值\n      // specail case 1\n      else if (j - i === 1 && s[i] === s[j])\n        dp[i][\n          j\n        ] = true // j - i === 1的时候，表示s[i]和是[j]为相邻值，则需要是s[i]===s[j]\n      // specail case 2\n      else if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        // 所有的i+1和j-1为true,并且s[i] === s[j]\n        // state transition\n        dp[i][j] = true\n      }\n\n      if (dp[i][j] && j - i + 1 > res.length) {\n        // update res\n        res = s.slice(i, j + 1)\n      }\n    }\n  }\n\n  return res\n}\n```\n","slug":"leetcode/String/LeetCode 005：最长回文子串","published":1,"updated":"2023-08-22T03:53:40.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwr002gm32vfpo1etqm","content":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-palindromic-substring/\">https://leetcode.cn/problems/longest-palindromic-substring/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个字符串 s，找到 s 中最长的回文子串。</span><br><span class=\"line\">如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法一-中心扩散法\"><a href=\"#解法一-中心扩散法\" class=\"headerlink\" title=\"解法一 中心扩散法\"></a>解法一 中心扩散法</h3><h4 id=\"由简入繁\"><a href=\"#由简入繁\" class=\"headerlink\" title=\"由简入繁\"></a>由简入繁</h4><p>先看一个最简单的字符串，比如’aabaaabaa’；</p>\n<ol>\n<li>第一步,i&#x3D;0,这时候 res&#x3D;’a’,如果回文子串长度是奇数，左边无值，右边有值，这时候最长回文子串是’a’，如果回文子串长度是偶数，res&#x3D;’aa’这时候最长回文子串是’aa’;</li>\n<li>第二步,i&#x3D;1,这时候 res&#x3D;’a’,如果回文子串长度是奇数,左边有一个值’a’,右边的值为’b’，这时候当前 i 位置最长回文子串是’a’,如果回文子串长度是偶数，res&#x3D;’aa’或者 res&#x3D;’ab’这时候最长回文子串是’aa’;</li>\n<li>第三步,i&#x3D;2,这时候 res&#x3D;’b’,如果回文子串长度是奇数,左边第一个值’a’,右边第一个值为’a’，res&#x3D;’aba’,左边第二个值’a’，右边第二个值’a’，res&#x3D;’aabaa’,这时候最长回文子串还是’aabaa’,如果回文子串长度是偶数,最长的长度为 1;</li>\n<li>第四步,i&#x3D;3,…这时候最长回文子串还是第三步的’aabaa’;</li>\n<li>第五步,i&#x3D;4,这时候 res&#x3D;’a’ … 这时候最长回文子串还是第三步的’aabaaabaa’;<br>….</li>\n</ol>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><ol>\n<li>如果 s 的长度是 1 或者 0 的时候，s 的最长回文子串就是它本身，例如’a’,直接返回 s。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><ol start=\"2\">\n<li>遍历整个 s<br>例:s 字符串 ‘acaca’,遍历字符串，区分 i 为奇数和偶数的情况；<br>在 s 的范围内（所以需要 <code>m&gt;=0 ,n&lt;s.length</code>），从中心往两边去遍历，如果<code>s[m] == s[n]</code>,如果如果此时回文字符串的长度大于之前最大长度则取 n-m-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> longestPalindrome = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回文子串长度是奇数</span></span><br><span class=\"line\">    <span class=\"title function_\">helper</span>(i, i)</span><br><span class=\"line\">    <span class=\"comment\">// 回文子串长度是偶数</span></span><br><span class=\"line\">    <span class=\"title function_\">helper</span>(i, i + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">helper</span>(<span class=\"params\">m, n</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m &gt;= <span class=\"number\">0</span> &amp;&amp; n &lt; s.<span class=\"property\">length</span> &amp;&amp; s[m] == s[n]) &#123;</span><br><span class=\"line\">      m--</span><br><span class=\"line\">      n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n - m - <span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// slice也要取[m+1,n-1]这个区间</span></span><br><span class=\"line\">      res = s.<span class=\"title function_\">slice</span>(m + <span class=\"number\">1</span>, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法二-动态规划\"><a href=\"#解法二-动态规划\" class=\"headerlink\" title=\"解法二 动态规划\"></a>解法二 动态规划</h3><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>状态定义<br>dp[i,j]：字符串 s 从索引 i 到 j 的子串是否是回文串</li>\n</ol>\n<ul>\n<li>true： s[i,j] 是回文串</li>\n<li>false：s[i,j] 不是回文串</li>\n</ul>\n<ol start=\"2\">\n<li>转移方程<br>dp[i][j] &#x3D; dp[i+1][j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</li>\n</ol>\n<ul>\n<li>s[i] &#x3D;&#x3D; s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度</li>\n<li>dp[i+1][j-1]：true<ul>\n<li>说明 s[i,j]的**子串 s[i+1][j-1]**也是回文串</li>\n<li>说明，i 是从最大值开始遍历的，j 是从最小值开始遍历的</li>\n</ul>\n</li>\n<li>特殊情况<ul>\n<li>j&#x3D;&#x3D;&#x3D;i：s[i]和是[j]值是同一个值</li>\n<li>j - i &#x3D;&#x3D;&#x3D; 1:表示 s[i]和是[j]为相邻值，则需要是 s[i]&#x3D;&#x3D;&#x3D;s[j]</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> longestPalindrome = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!s || s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = s[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = []</span><br><span class=\"line\">  <span class=\"comment\">// 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    dp[i] = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; s.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - i === <span class=\"number\">0</span>) dp[i][j] = <span class=\"literal\">true</span> <span class=\"comment\">// j===i的时候，值是同一个值</span></span><br><span class=\"line\">      <span class=\"comment\">// specail case 1</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j - i === <span class=\"number\">1</span> &amp;&amp; s[i] === s[j])</span><br><span class=\"line\">        dp[i][</span><br><span class=\"line\">          j</span><br><span class=\"line\">        ] = <span class=\"literal\">true</span> <span class=\"comment\">// j - i === 1的时候，表示s[i]和是[j]为相邻值，则需要是s[i]===s[j]</span></span><br><span class=\"line\">      <span class=\"comment\">// specail case 2</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] === s[j] &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有的i+1和j-1为true,并且s[i] === s[j]</span></span><br><span class=\"line\">        <span class=\"comment\">// state transition</span></span><br><span class=\"line\">        dp[i][j] = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// update res</span></span><br><span class=\"line\">        res = s.<span class=\"title function_\">slice</span>(i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-palindromic-substring/\">https://leetcode.cn/problems/longest-palindromic-substring/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个字符串 s，找到 s 中最长的回文子串。</span><br><span class=\"line\">如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法一-中心扩散法\"><a href=\"#解法一-中心扩散法\" class=\"headerlink\" title=\"解法一 中心扩散法\"></a>解法一 中心扩散法</h3><h4 id=\"由简入繁\"><a href=\"#由简入繁\" class=\"headerlink\" title=\"由简入繁\"></a>由简入繁</h4><p>先看一个最简单的字符串，比如’aabaaabaa’；</p>\n<ol>\n<li>第一步,i&#x3D;0,这时候 res&#x3D;’a’,如果回文子串长度是奇数，左边无值，右边有值，这时候最长回文子串是’a’，如果回文子串长度是偶数，res&#x3D;’aa’这时候最长回文子串是’aa’;</li>\n<li>第二步,i&#x3D;1,这时候 res&#x3D;’a’,如果回文子串长度是奇数,左边有一个值’a’,右边的值为’b’，这时候当前 i 位置最长回文子串是’a’,如果回文子串长度是偶数，res&#x3D;’aa’或者 res&#x3D;’ab’这时候最长回文子串是’aa’;</li>\n<li>第三步,i&#x3D;2,这时候 res&#x3D;’b’,如果回文子串长度是奇数,左边第一个值’a’,右边第一个值为’a’，res&#x3D;’aba’,左边第二个值’a’，右边第二个值’a’，res&#x3D;’aabaa’,这时候最长回文子串还是’aabaa’,如果回文子串长度是偶数,最长的长度为 1;</li>\n<li>第四步,i&#x3D;3,…这时候最长回文子串还是第三步的’aabaa’;</li>\n<li>第五步,i&#x3D;4,这时候 res&#x3D;’a’ … 这时候最长回文子串还是第三步的’aabaaabaa’;<br>….</li>\n</ol>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li><ol>\n<li>如果 s 的长度是 1 或者 0 的时候，s 的最长回文子串就是它本身，例如’a’,直接返回 s。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><ol start=\"2\">\n<li>遍历整个 s<br>例:s 字符串 ‘acaca’,遍历字符串，区分 i 为奇数和偶数的情况；<br>在 s 的范围内（所以需要 <code>m&gt;=0 ,n&lt;s.length</code>），从中心往两边去遍历，如果<code>s[m] == s[n]</code>,如果如果此时回文字符串的长度大于之前最大长度则取 n-m-1</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> longestPalindrome = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回文子串长度是奇数</span></span><br><span class=\"line\">    <span class=\"title function_\">helper</span>(i, i)</span><br><span class=\"line\">    <span class=\"comment\">// 回文子串长度是偶数</span></span><br><span class=\"line\">    <span class=\"title function_\">helper</span>(i, i + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">helper</span>(<span class=\"params\">m, n</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m &gt;= <span class=\"number\">0</span> &amp;&amp; n &lt; s.<span class=\"property\">length</span> &amp;&amp; s[m] == s[n]) &#123;</span><br><span class=\"line\">      m--</span><br><span class=\"line\">      n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n - m - <span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// slice也要取[m+1,n-1]这个区间</span></span><br><span class=\"line\">      res = s.<span class=\"title function_\">slice</span>(m + <span class=\"number\">1</span>, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解法二-动态规划\"><a href=\"#解法二-动态规划\" class=\"headerlink\" title=\"解法二 动态规划\"></a>解法二 动态规划</h3><h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>状态定义<br>dp[i,j]：字符串 s 从索引 i 到 j 的子串是否是回文串</li>\n</ol>\n<ul>\n<li>true： s[i,j] 是回文串</li>\n<li>false：s[i,j] 不是回文串</li>\n</ul>\n<ol start=\"2\">\n<li>转移方程<br>dp[i][j] &#x3D; dp[i+1][j-1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]</li>\n</ol>\n<ul>\n<li>s[i] &#x3D;&#x3D; s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度</li>\n<li>dp[i+1][j-1]：true<ul>\n<li>说明 s[i,j]的**子串 s[i+1][j-1]**也是回文串</li>\n<li>说明，i 是从最大值开始遍历的，j 是从最小值开始遍历的</li>\n</ul>\n</li>\n<li>特殊情况<ul>\n<li>j&#x3D;&#x3D;&#x3D;i：s[i]和是[j]值是同一个值</li>\n<li>j - i &#x3D;&#x3D;&#x3D; 1:表示 s[i]和是[j]为相邻值，则需要是 s[i]&#x3D;&#x3D;&#x3D;s[j]</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> longestPalindrome = <span class=\"keyword\">function</span> (<span class=\"params\">s</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!s || s.<span class=\"property\">length</span> &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = s[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dp = []</span><br><span class=\"line\">  <span class=\"comment\">// 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = s.<span class=\"property\">length</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    dp[i] = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &lt; s.<span class=\"property\">length</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (j - i === <span class=\"number\">0</span>) dp[i][j] = <span class=\"literal\">true</span> <span class=\"comment\">// j===i的时候，值是同一个值</span></span><br><span class=\"line\">      <span class=\"comment\">// specail case 1</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j - i === <span class=\"number\">1</span> &amp;&amp; s[i] === s[j])</span><br><span class=\"line\">        dp[i][</span><br><span class=\"line\">          j</span><br><span class=\"line\">        ] = <span class=\"literal\">true</span> <span class=\"comment\">// j - i === 1的时候，表示s[i]和是[j]为相邻值，则需要是s[i]===s[j]</span></span><br><span class=\"line\">      <span class=\"comment\">// specail case 2</span></span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] === s[j] &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 所有的i+1和j-1为true,并且s[i] === s[j]</span></span><br><span class=\"line\">        <span class=\"comment\">// state transition</span></span><br><span class=\"line\">        dp[i][j] = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; res.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// update res</span></span><br><span class=\"line\">        res = s.<span class=\"title function_\">slice</span>(i, j + <span class=\"number\">1</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"LeetCode 006：N 字形变换","date":"2023-08-23T00:58:23.975Z","_content":"\n### 题目地址\n\n> https://leetcode.cn/problems/zigzag-conversion/\n\n### 题目描述\n\n```\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n\n输入：s = \"PAYPALISHIRING\", numRows = 3\n输出：\"PAHNAPLSIIGYIR\"\n\n示例 2：\n\n输入：s = \"PAYPALISHIRING\", numRows = 4\n输出：\"PINALSIGYAHRPI\"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n示例 3：\n\n输入：s = \"A\", numRows = 1\n输出：\"A\"\n```\n\n### 解答\n\n#### 思路\n\n1. 如果 numRows=1 或者 numsRows>s.length 则说明当前字符串即为结果，直接返回\n2. 否则整个字符串需要经历，向下向右，向下向右，这样的反复循环过程，设定 down 变量表示是否向下，loc 变量表示当前字符串数组的下标\n   如果 down 为 true，则 loc+=1，字符串数组下标向后移动，将当前字符加入当前字符串中\n\n#### 代码\n\n```javascript\nconst convert = function (s, numRows) {\n  // 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s\n  // 如果numRows > s.length，则s的数据正好放一列，返回的数据也是s\n  if (numRows == 1 || numRows > s.length) return s\n\n  const rows = new Array(numRows).fill('')\n  let loc = 0\n  let down = false\n\n  for (const c of s) {\n    rows[loc] = rows[loc] + c\n    if (loc == 0 || loc == numRows - 1) down = !down\n    loc = down ? loc + 1 : loc - 1\n  }\n  return rows.join('')\n}\n```\n\n利用 Array.from 创建空数组\n\n```javascript\nconst convert = function (s, numRows) {\n  // 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s\n  // 如果numRows > s.length，则s的数据正好放一列，返回的数据也是s\n  if (numRows == 1 || numRows > s.length) return s\n\n  const rows = Array.from({ length: numRows }, (v) => (v = ''))\n  let loc = 0\n  let down = false\n\n  for (const c of s) {\n    rows[loc] = rows[loc] + c\n    if (loc == 0 || loc == numRows - 1) down = !down\n    loc = down ? loc + 1 : loc - 1\n  }\n  return rows.join('')\n}\n```\n","source":"_posts/leetcode/String/LeetCode 006：N 字形变换.md","raw":"---\ntitle: LeetCode 006：N 字形变换\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 006N 字形变换]\n---\n\n### 题目地址\n\n> https://leetcode.cn/problems/zigzag-conversion/\n\n### 题目描述\n\n```\n将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列如下：\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"PAHNAPLSIIGYIR\"。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n\n输入：s = \"PAYPALISHIRING\", numRows = 3\n输出：\"PAHNAPLSIIGYIR\"\n\n示例 2：\n\n输入：s = \"PAYPALISHIRING\", numRows = 4\n输出：\"PINALSIGYAHRPI\"\n解释：\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n示例 3：\n\n输入：s = \"A\", numRows = 1\n输出：\"A\"\n```\n\n### 解答\n\n#### 思路\n\n1. 如果 numRows=1 或者 numsRows>s.length 则说明当前字符串即为结果，直接返回\n2. 否则整个字符串需要经历，向下向右，向下向右，这样的反复循环过程，设定 down 变量表示是否向下，loc 变量表示当前字符串数组的下标\n   如果 down 为 true，则 loc+=1，字符串数组下标向后移动，将当前字符加入当前字符串中\n\n#### 代码\n\n```javascript\nconst convert = function (s, numRows) {\n  // 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s\n  // 如果numRows > s.length，则s的数据正好放一列，返回的数据也是s\n  if (numRows == 1 || numRows > s.length) return s\n\n  const rows = new Array(numRows).fill('')\n  let loc = 0\n  let down = false\n\n  for (const c of s) {\n    rows[loc] = rows[loc] + c\n    if (loc == 0 || loc == numRows - 1) down = !down\n    loc = down ? loc + 1 : loc - 1\n  }\n  return rows.join('')\n}\n```\n\n利用 Array.from 创建空数组\n\n```javascript\nconst convert = function (s, numRows) {\n  // 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s\n  // 如果numRows > s.length，则s的数据正好放一列，返回的数据也是s\n  if (numRows == 1 || numRows > s.length) return s\n\n  const rows = Array.from({ length: numRows }, (v) => (v = ''))\n  let loc = 0\n  let down = false\n\n  for (const c of s) {\n    rows[loc] = rows[loc] + c\n    if (loc == 0 || loc == numRows - 1) down = !down\n    loc = down ? loc + 1 : loc - 1\n  }\n  return rows.join('')\n}\n```\n","slug":"leetcode/String/LeetCode 006：N 字形变换","published":1,"updated":"2023-08-23T00:59:28.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwws002jm32vhnudha68","content":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/zigzag-conversion/\">https://leetcode.cn/problems/zigzag-conversion/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span><br><span class=\"line\">比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span><br><span class=\"line\"></span><br><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br><span class=\"line\"></span><br><span class=\"line\">之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span><br><span class=\"line\">请你实现这个将字符串进行指定行数变换的函数：</span><br><span class=\"line\">string convert(string s, int numRows);</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class=\"line\">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class=\"line\">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">解释：</span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;A&quot;, numRows = 1</span><br><span class=\"line\">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ol>\n<li>如果 numRows&#x3D;1 或者 numsRows&gt;s.length 则说明当前字符串即为结果，直接返回</li>\n<li>否则整个字符串需要经历，向下向右，向下向右，这样的反复循环过程，设定 down 变量表示是否向下，loc 变量表示当前字符串数组的下标<br>如果 down 为 true，则 loc+&#x3D;1，字符串数组下标向后移动，将当前字符加入当前字符串中</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"keyword\">function</span> (<span class=\"params\">s, numRows</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows &gt; s.length，则s的数据正好放一列，返回的数据也是s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span> || numRows &gt; s.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rows = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(numRows).<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> loc = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> down = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> c <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    rows[loc] = rows[loc] + c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loc == <span class=\"number\">0</span> || loc == numRows - <span class=\"number\">1</span>) down = !down</span><br><span class=\"line\">    loc = down ? loc + <span class=\"number\">1</span> : loc - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用 Array.from 创建空数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"keyword\">function</span> (<span class=\"params\">s, numRows</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows &gt; s.length，则s的数据正好放一列，返回的数据也是s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span> || numRows &gt; s.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rows = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(&#123; <span class=\"attr\">length</span>: numRows &#125;, <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> (v = <span class=\"string\">&#x27;&#x27;</span>))</span><br><span class=\"line\">  <span class=\"keyword\">let</span> loc = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> down = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> c <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    rows[loc] = rows[loc] + c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loc == <span class=\"number\">0</span> || loc == numRows - <span class=\"number\">1</span>) down = !down</span><br><span class=\"line\">    loc = down ? loc + <span class=\"number\">1</span> : loc - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/zigzag-conversion/\">https://leetcode.cn/problems/zigzag-conversion/</a></p>\n</blockquote>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span><br><span class=\"line\">比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下：</span><br><span class=\"line\"></span><br><span class=\"line\">P   A   H   N</span><br><span class=\"line\">A P L S I I G</span><br><span class=\"line\">Y   I   R</span><br><span class=\"line\"></span><br><span class=\"line\">之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot;。</span><br><span class=\"line\">请你实现这个将字符串进行指定行数变换的函数：</span><br><span class=\"line\">string convert(string s, int numRows);</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class=\"line\">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class=\"line\">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class=\"line\">解释：</span><br><span class=\"line\">P     I    N</span><br><span class=\"line\">A   L S  I G</span><br><span class=\"line\">Y A   H R</span><br><span class=\"line\">P     I</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;A&quot;, numRows = 1</span><br><span class=\"line\">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ol>\n<li>如果 numRows&#x3D;1 或者 numsRows&gt;s.length 则说明当前字符串即为结果，直接返回</li>\n<li>否则整个字符串需要经历，向下向右，向下向右，这样的反复循环过程，设定 down 变量表示是否向下，loc 变量表示当前字符串数组的下标<br>如果 down 为 true，则 loc+&#x3D;1，字符串数组下标向后移动，将当前字符加入当前字符串中</li>\n</ol>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"keyword\">function</span> (<span class=\"params\">s, numRows</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows &gt; s.length，则s的数据正好放一列，返回的数据也是s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span> || numRows &gt; s.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rows = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(numRows).<span class=\"title function_\">fill</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> loc = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> down = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> c <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    rows[loc] = rows[loc] + c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loc == <span class=\"number\">0</span> || loc == numRows - <span class=\"number\">1</span>) down = !down</span><br><span class=\"line\">    loc = down ? loc + <span class=\"number\">1</span> : loc - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用 Array.from 创建空数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"keyword\">function</span> (<span class=\"params\">s, numRows</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows == 1则表示z行变换时，全在一行，返回的数据就是s</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果numRows &gt; s.length，则s的数据正好放一列，返回的数据也是s</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span> || numRows &gt; s.<span class=\"property\">length</span>) <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rows = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(&#123; <span class=\"attr\">length</span>: numRows &#125;, <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> (v = <span class=\"string\">&#x27;&#x27;</span>))</span><br><span class=\"line\">  <span class=\"keyword\">let</span> loc = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> down = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> c <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    rows[loc] = rows[loc] + c</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loc == <span class=\"number\">0</span> || loc == numRows - <span class=\"number\">1</span>) down = !down</span><br><span class=\"line\">    loc = down ? loc + <span class=\"number\">1</span> : loc - <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rows.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"寻找第k小元素","date":"2024-10-20T06:59:06.621Z","_content":"\n# 题目描述\n\n> 给定一个无序数组 S = [s1,s2,...sk,...sn],输出数组的第 k 小元素，也就是从小到大，第 k 小元素。\n\n# 分解\n\n- 如何将原数组分成两个子问题\n  - 寻找一个中间元素\n- 如何找到这个处于中间位置的元素 m\n  - 将 n 个元素分成 m 个组（通常每组 5 个元素），取每组的中间元素，再去这些中间元素的中间元素\n- 怎么找到中间元素的中间元素。\n  - 递归调用\n\n分为所有小于 m 数组 + 等于 m +大于 m 的所有数组\n","source":"_posts/leetcode/divide-and-conquer/寻找第k小元素.md","raw":"---\ntitle: 寻找第k小元素\ndate:\ntags: [算法, 分治法]\ncategories: [前端, 算法, 分治法, 寻找第k小元素]\n---\n\n# 题目描述\n\n> 给定一个无序数组 S = [s1,s2,...sk,...sn],输出数组的第 k 小元素，也就是从小到大，第 k 小元素。\n\n# 分解\n\n- 如何将原数组分成两个子问题\n  - 寻找一个中间元素\n- 如何找到这个处于中间位置的元素 m\n  - 将 n 个元素分成 m 个组（通常每组 5 个元素），取每组的中间元素，再去这些中间元素的中间元素\n- 怎么找到中间元素的中间元素。\n  - 递归调用\n\n分为所有小于 m 数组 + 等于 m +大于 m 的所有数组\n","slug":"leetcode/divide-and-conquer/寻找第k小元素","published":1,"updated":"2024-10-20T09:17:20.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwws002nm32vcz7sbb91","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个无序数组 S &#x3D; [s1,s2,…sk,…sn],输出数组的第 k 小元素，也就是从小到大，第 k 小元素。</p>\n</blockquote>\n<h1 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h1><ul>\n<li>如何将原数组分成两个子问题<ul>\n<li>寻找一个中间元素</li>\n</ul>\n</li>\n<li>如何找到这个处于中间位置的元素 m<ul>\n<li>将 n 个元素分成 m 个组（通常每组 5 个元素），取每组的中间元素，再去这些中间元素的中间元素</li>\n</ul>\n</li>\n<li>怎么找到中间元素的中间元素。<ul>\n<li>递归调用</li>\n</ul>\n</li>\n</ul>\n<p>分为所有小于 m 数组 + 等于 m +大于 m 的所有数组</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个无序数组 S &#x3D; [s1,s2,…sk,…sn],输出数组的第 k 小元素，也就是从小到大，第 k 小元素。</p>\n</blockquote>\n<h1 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h1><ul>\n<li>如何将原数组分成两个子问题<ul>\n<li>寻找一个中间元素</li>\n</ul>\n</li>\n<li>如何找到这个处于中间位置的元素 m<ul>\n<li>将 n 个元素分成 m 个组（通常每组 5 个元素），取每组的中间元素，再去这些中间元素的中间元素</li>\n</ul>\n</li>\n<li>怎么找到中间元素的中间元素。<ul>\n<li>递归调用</li>\n</ul>\n</li>\n</ul>\n<p>分为所有小于 m 数组 + 等于 m +大于 m 的所有数组</p>\n"},{"title":"LeetCode 030：串联所有单词的子串","date":"2023-08-24T01:04:37.578Z","_content":"\n# 题目地址\n\n> https://leetcode.cn/problems/substring-with-concatenation-of-all-words/\n\n# 题目描述\n\n```\n给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。\n返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n\n\n\n示例 1：\n\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n\n示例 2：\n\n输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n\n示例 3：\n\n输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。\n\n```\n","source":"_posts/leetcode/String/LeetCode 030：串联所有单词的子串.md","raw":"---\ntitle: LeetCode 030：串联所有单词的子串\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 030串联所有单词的子串]\n---\n\n# 题目地址\n\n> https://leetcode.cn/problems/substring-with-concatenation-of-all-words/\n\n# 题目描述\n\n```\n给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\n\n s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。\n\n例如，如果 words = [\"ab\",\"cd\",\"ef\"]， 那么 \"abcdef\"， \"abefcd\"，\"cdabef\"， \"cdefab\"，\"efabcd\"， 和 \"efcdab\" 都是串联子串。 \"acdbef\" 不是串联子串，因为他不是任何 words 排列的连接。\n返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n\n\n\n示例 1：\n\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n\n示例 2：\n\n输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n\n示例 3：\n\n输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。\n\n```\n","slug":"leetcode/String/LeetCode 030：串联所有单词的子串","published":1,"updated":"2023-08-24T01:06:21.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwt002rm32v6n1n4gvq","content":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/substring-with-concatenation-of-all-words/\">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></p>\n</blockquote>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</span><br><span class=\"line\"></span><br><span class=\"line\"> s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，如果 words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]， 那么 &quot;abcdef&quot;， &quot;abefcd&quot;，&quot;cdabef&quot;， &quot;cdefab&quot;，&quot;efabcd&quot;， 和 &quot;efcdab&quot; 都是串联子串。 &quot;acdbef&quot; 不是串联子串，因为他不是任何 words 排列的连接。</span><br><span class=\"line\">返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class=\"line\">输出：[0,9]</span><br><span class=\"line\">解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。</span><br><span class=\"line\">子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class=\"line\">输出顺序无关紧要。返回 [9,0] 也是可以的。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。</span><br><span class=\"line\">s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。</span><br><span class=\"line\">所以我们返回一个空数组。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span><br><span class=\"line\">输出：[6,9,12]</span><br><span class=\"line\">解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。</span><br><span class=\"line\">子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><blockquote>\n<p><a href=\"https://leetcode.cn/problems/substring-with-concatenation-of-all-words/\">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></p>\n</blockquote>\n<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</span><br><span class=\"line\"></span><br><span class=\"line\"> s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，如果 words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]， 那么 &quot;abcdef&quot;， &quot;abefcd&quot;，&quot;cdabef&quot;， &quot;cdefab&quot;，&quot;efabcd&quot;， 和 &quot;efcdab&quot; 都是串联子串。 &quot;acdbef&quot; 不是串联子串，因为他不是任何 words 排列的连接。</span><br><span class=\"line\">返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class=\"line\">输出：[0,9]</span><br><span class=\"line\">解释：因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。</span><br><span class=\"line\">子串 &quot;barfoo&quot; 开始位置是 0。它是 words 中以 [&quot;bar&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;foobar&quot; 开始位置是 9。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class=\"line\">输出顺序无关紧要。返回 [9,0] 也是可以的。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：因为 words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。</span><br><span class=\"line\">s 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。</span><br><span class=\"line\">所以我们返回一个空数组。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]</span><br><span class=\"line\">输出：[6,9,12]</span><br><span class=\"line\">解释：因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。</span><br><span class=\"line\">子串 &quot;foobarthe&quot; 开始位置是 6。它是 words 中以 [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;barthefoo&quot; 开始位置是 9。它是 words 中以 [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] 顺序排列的连接。</span><br><span class=\"line\">子串 &quot;thefoobar&quot; 开始位置是 12。它是 words 中以 [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] 顺序排列的连接。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"最大子数组问题","date":"2024-10-20T06:31:07.000Z","_content":"\n# 题目描述\n\n> 给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。\n\n# 基本步骤\n\n## 分解\n\n对原数组进行二分，也就是将数组划分为左右相等（或者相差一个元素）的两个子数组。\n\n## 合并\n\n对半分的时候需要注意，中间重合部分的。  \n原数组，左边数组+右边数组+中间 合并而成。  \n求三个值的最大解即可\n\nmax{subLMax,subRMax,subMMax}\n\n### 横跨在两个子问题上的最大子数组\n\n- 只要一次遍历左右数组的所有子数组，即可找到横跨在两个子问题上的最大子数组\n- 复杂度\n","source":"_posts/leetcode/divide-and-conquer/最大子数组问题.md","raw":"---\ntitle: 最大子数组问题\ndate:\ntags: [算法, 分治法]\ncategories: [前端, 算法, 分治法, 最大子数组问题]\n---\n\n# 题目描述\n\n> 给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。\n\n# 基本步骤\n\n## 分解\n\n对原数组进行二分，也就是将数组划分为左右相等（或者相差一个元素）的两个子数组。\n\n## 合并\n\n对半分的时候需要注意，中间重合部分的。  \n原数组，左边数组+右边数组+中间 合并而成。  \n求三个值的最大解即可\n\nmax{subLMax,subRMax,subMMax}\n\n### 横跨在两个子问题上的最大子数组\n\n- 只要一次遍历左右数组的所有子数组，即可找到横跨在两个子问题上的最大子数组\n- 复杂度\n","slug":"leetcode/divide-and-conquer/最大子数组问题","published":1,"updated":"2024-10-20T06:31:07.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwu002vm32v4vk333j9","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。</p>\n</blockquote>\n<h1 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h1><h2 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h2><p>对原数组进行二分，也就是将数组划分为左右相等（或者相差一个元素）的两个子数组。</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>对半分的时候需要注意，中间重合部分的。<br>原数组，左边数组+右边数组+中间 合并而成。<br>求三个值的最大解即可</p>\n<p>max{subLMax,subRMax,subMMax}</p>\n<h3 id=\"横跨在两个子问题上的最大子数组\"><a href=\"#横跨在两个子问题上的最大子数组\" class=\"headerlink\" title=\"横跨在两个子问题上的最大子数组\"></a>横跨在两个子问题上的最大子数组</h3><ul>\n<li>只要一次遍历左右数组的所有子数组，即可找到横跨在两个子问题上的最大子数组</li>\n<li>复杂度</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。</p>\n</blockquote>\n<h1 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h1><h2 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h2><p>对原数组进行二分，也就是将数组划分为左右相等（或者相差一个元素）的两个子数组。</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>对半分的时候需要注意，中间重合部分的。<br>原数组，左边数组+右边数组+中间 合并而成。<br>求三个值的最大解即可</p>\n<p>max{subLMax,subRMax,subMMax}</p>\n<h3 id=\"横跨在两个子问题上的最大子数组\"><a href=\"#横跨在两个子问题上的最大子数组\" class=\"headerlink\" title=\"横跨在两个子问题上的最大子数组\"></a>横跨在两个子问题上的最大子数组</h3><ul>\n<li>只要一次遍历左右数组的所有子数组，即可找到横跨在两个子问题上的最大子数组</li>\n<li>复杂度</li>\n</ul>\n"},{"title":"LeetCode 049：字母异位词分组","date":"2023-08-25T23:32:23.094Z","_content":"\n# 题目地址\n\nhttps://leetcode.cn/problems/group-anagrams/\n\n### 题目描述\n\n```\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n\n \n\n示例 1:\n\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n示例 2:\n\n输入: strs = [\"\"]\n输出: [[\"\"]]\n示例 3:\n\n输入: strs = [\"a\"]\n输出: [[\"a\"]]\n```\n\n### 解答\n\n```javascript\nconst groupAnagrams = function (strs) {\n  const map = new Map()\n  for (let str of strs) {\n    let array = Array.from(str) //字符转成数组\n    array.sort() //排序\n    let key = array.toString()\n    let list = map.get(key) ? map.get(key) : [] //从map中取到相应的数组\n    list.push(str) //加入数组\n    map.set(key, list) //重新设置该字符的数组\n  }\n  return Array.from(map.values()) //map中的value转成数组\n}\n```\n\n```javascript\nfunction xier(arr) {\n  var interval = parseInt(arr.length / 2) //分组间隔设置\n  while (interval > 0) {\n    for (var i = 0; i < arr.length; i++) {\n      var n = i\n      while (arr[n] < arr[n - interval] && n > 0) {\n        var temp = arr[n]\n        arr[n] = arr[n - interval]\n        arr[n - interval] = temp\n        n = n - interval\n      }\n    }\n    interval = parseInt(interval / 2)\n  }\n  return arr\n}\nconst groupAnagrams = function (strs) {\n  const map = {}\n  for (let str of strs) {\n    let array = Array.from(str) //字符转成数组\n    array = xier(array)\n    let key = array.toString()\n    let list = map[key] ? map[key] : [] //从map中取到相应的数组\n    list.push(str) //加入数组\n    map[key] = list //重新设置该字符的数组\n  }\n  return Object.values(map)\n}\n```\n","source":"_posts/leetcode/String/LeetCode 049：字母异位词分组.md","raw":"---\ntitle: LeetCode 049：字母异位词分组\ndate:\ntags: [leetcode, 字符串]\ncategories: [前端, leetcode, 049字母异位词分组]\n---\n\n# 题目地址\n\nhttps://leetcode.cn/problems/group-anagrams/\n\n### 题目描述\n\n```\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n\n \n\n示例 1:\n\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n示例 2:\n\n输入: strs = [\"\"]\n输出: [[\"\"]]\n示例 3:\n\n输入: strs = [\"a\"]\n输出: [[\"a\"]]\n```\n\n### 解答\n\n```javascript\nconst groupAnagrams = function (strs) {\n  const map = new Map()\n  for (let str of strs) {\n    let array = Array.from(str) //字符转成数组\n    array.sort() //排序\n    let key = array.toString()\n    let list = map.get(key) ? map.get(key) : [] //从map中取到相应的数组\n    list.push(str) //加入数组\n    map.set(key, list) //重新设置该字符的数组\n  }\n  return Array.from(map.values()) //map中的value转成数组\n}\n```\n\n```javascript\nfunction xier(arr) {\n  var interval = parseInt(arr.length / 2) //分组间隔设置\n  while (interval > 0) {\n    for (var i = 0; i < arr.length; i++) {\n      var n = i\n      while (arr[n] < arr[n - interval] && n > 0) {\n        var temp = arr[n]\n        arr[n] = arr[n - interval]\n        arr[n - interval] = temp\n        n = n - interval\n      }\n    }\n    interval = parseInt(interval / 2)\n  }\n  return arr\n}\nconst groupAnagrams = function (strs) {\n  const map = {}\n  for (let str of strs) {\n    let array = Array.from(str) //字符转成数组\n    array = xier(array)\n    let key = array.toString()\n    let list = map[key] ? map[key] : [] //从map中取到相应的数组\n    list.push(str) //加入数组\n    map[key] = list //重新设置该字符的数组\n  }\n  return Object.values(map)\n}\n```\n","slug":"leetcode/String/LeetCode 049：字母异位词分组","published":1,"updated":"2023-08-25T23:33:17.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwu002ym32v48nfcby4","content":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><p><a href=\"https://leetcode.cn/problems/group-anagrams/\">https://leetcode.cn/problems/group-anagrams/</a></p>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span><br><span class=\"line\"></span><br><span class=\"line\">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class=\"line\">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;&quot;]</span><br><span class=\"line\">输出: [[&quot;&quot;]]</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;a&quot;]</span><br><span class=\"line\">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> groupAnagrams = <span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> str <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> array = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str) <span class=\"comment\">//字符转成数组</span></span><br><span class=\"line\">    array.<span class=\"title function_\">sort</span>() <span class=\"comment\">//排序</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = array.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> list = map.<span class=\"title function_\">get</span>(key) ? map.<span class=\"title function_\">get</span>(key) : [] <span class=\"comment\">//从map中取到相应的数组</span></span><br><span class=\"line\">    list.<span class=\"title function_\">push</span>(str) <span class=\"comment\">//加入数组</span></span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(key, list) <span class=\"comment\">//重新设置该字符的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(map.<span class=\"title function_\">values</span>()) <span class=\"comment\">//map中的value转成数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">xier</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> interval = <span class=\"built_in\">parseInt</span>(arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>) <span class=\"comment\">//分组间隔设置</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (interval &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> n = i</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr[n]</span><br><span class=\"line\">        arr[n] = arr[n - interval]</span><br><span class=\"line\">        arr[n - interval] = temp</span><br><span class=\"line\">        n = n - interval</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interval = <span class=\"built_in\">parseInt</span>(interval / <span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> groupAnagrams = <span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> str <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> array = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str) <span class=\"comment\">//字符转成数组</span></span><br><span class=\"line\">    array = <span class=\"title function_\">xier</span>(array)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = array.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> list = map[key] ? map[key] : [] <span class=\"comment\">//从map中取到相应的数组</span></span><br><span class=\"line\">    list.<span class=\"title function_\">push</span>(str) <span class=\"comment\">//加入数组</span></span><br><span class=\"line\">    map[key] = list <span class=\"comment\">//重新设置该字符的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Object</span>.<span class=\"title function_\">values</span>(map)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目地址\"><a href=\"#题目地址\" class=\"headerlink\" title=\"题目地址\"></a>题目地址</h1><p><a href=\"https://leetcode.cn/problems/group-anagrams/\">https://leetcode.cn/problems/group-anagrams/</a></p>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</span><br><span class=\"line\"></span><br><span class=\"line\">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class=\"line\">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;&quot;]</span><br><span class=\"line\">输出: [[&quot;&quot;]]</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: strs = [&quot;a&quot;]</span><br><span class=\"line\">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> groupAnagrams = <span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> str <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> array = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str) <span class=\"comment\">//字符转成数组</span></span><br><span class=\"line\">    array.<span class=\"title function_\">sort</span>() <span class=\"comment\">//排序</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = array.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> list = map.<span class=\"title function_\">get</span>(key) ? map.<span class=\"title function_\">get</span>(key) : [] <span class=\"comment\">//从map中取到相应的数组</span></span><br><span class=\"line\">    list.<span class=\"title function_\">push</span>(str) <span class=\"comment\">//加入数组</span></span><br><span class=\"line\">    map.<span class=\"title function_\">set</span>(key, list) <span class=\"comment\">//重新设置该字符的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(map.<span class=\"title function_\">values</span>()) <span class=\"comment\">//map中的value转成数组</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">xier</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> interval = <span class=\"built_in\">parseInt</span>(arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>) <span class=\"comment\">//分组间隔设置</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (interval &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> n = i</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> temp = arr[n]</span><br><span class=\"line\">        arr[n] = arr[n - interval]</span><br><span class=\"line\">        arr[n - interval] = temp</span><br><span class=\"line\">        n = n - interval</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interval = <span class=\"built_in\">parseInt</span>(interval / <span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> groupAnagrams = <span class=\"keyword\">function</span> (<span class=\"params\">strs</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> str <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> array = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str) <span class=\"comment\">//字符转成数组</span></span><br><span class=\"line\">    array = <span class=\"title function_\">xier</span>(array)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> key = array.<span class=\"title function_\">toString</span>()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> list = map[key] ? map[key] : [] <span class=\"comment\">//从map中取到相应的数组</span></span><br><span class=\"line\">    list.<span class=\"title function_\">push</span>(str) <span class=\"comment\">//加入数组</span></span><br><span class=\"line\">    map[key] = list <span class=\"comment\">//重新设置该字符的数组</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Object</span>.<span class=\"title function_\">values</span>(map)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"最近点对问题","date":"2024-10-20T09:16:39.768Z","_content":"\n# 问题描述\n\n> 给定屏幕上的点对 S，|S|=n,每个点可用坐标（x，y）表示，若 p∈S，q∈S，p≠q,则 pq 称为一个点对，则 d(p,q)称为该点对的欧几里得距离。我们要求得所有点对的最小值 dmin\n","source":"_posts/leetcode/divide-and-conquer/最近点对问题.md","raw":"---\ntitle: 最近点对问题\ndate:\ntags: [算法, 分治法]\ncategories: [前端, 算法, 分治法, 最近点对问题]\n---\n\n# 问题描述\n\n> 给定屏幕上的点对 S，|S|=n,每个点可用坐标（x，y）表示，若 p∈S，q∈S，p≠q,则 pq 称为一个点对，则 d(p,q)称为该点对的欧几里得距离。我们要求得所有点对的最小值 dmin\n","slug":"leetcode/divide-and-conquer/最近点对问题","published":1,"updated":"2024-10-20T09:21:22.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwv0031m32vcobe0kk3","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><blockquote>\n<p>给定屏幕上的点对 S，|S|&#x3D;n,每个点可用坐标（x，y）表示，若 p∈S，q∈S，p≠q,则 pq 称为一个点对，则 d(p,q)称为该点对的欧几里得距离。我们要求得所有点对的最小值 dmin</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><blockquote>\n<p>给定屏幕上的点对 S，|S|&#x3D;n,每个点可用坐标（x，y）表示，若 p∈S，q∈S，p≠q,则 pq 称为一个点对，则 d(p,q)称为该点对的欧几里得距离。我们要求得所有点对的最小值 dmin</p>\n</blockquote>\n"},{"title":"分治法基本内容","date":"2024-10-20T06:31:07.002Z","_content":"\n# 基本思想\n\n> 规模较大的问题分解为规模较少的问题，较小的问题分解成更小的问题，直到容易解决为止\n\n- 对较小问题解决，是继续分解————递归方程\n- 直到容易解决为止(通常一个元素)，边界条件\n\n可以无限变小直到自己会做为止。\n\n# 分治步骤\n\n1. 分解：将原问题分解成规模较小的子问题\n\n- 原问题可以被分为多个子问题 P1,P2,...,PK\n- 子问题形式需要和原问题一致\n\n2. 解决：通过递归的方式解决子问题\n\n- P1,P2 独立解，以及 P1,P2 共同相关的解\n\n3. 合并，对子问题的解进行合并，形成原问题的解。\n\n# 快速排序\n\n## 分解\n\n选择一个主元素 k，将原数组分解为两个子数组，小于主元素的所有元素组成了一个子数组，大于主元素的所有元素组成了另外一个子数组。\n[<=k] [>k]\n\n## 解决\n\n对子数组进行递归调用解决\n\n## 合并\n\n通过上述步骤，对已完成原数组的排序，无需合并操作\n","source":"_posts/leetcode/divide-and-conquer/base.md","raw":"---\ntitle: 分治法基本内容\ndate:\ntags: [算法, 分治法]\ncategories: [前端, 算法, 分治法]\n---\n\n# 基本思想\n\n> 规模较大的问题分解为规模较少的问题，较小的问题分解成更小的问题，直到容易解决为止\n\n- 对较小问题解决，是继续分解————递归方程\n- 直到容易解决为止(通常一个元素)，边界条件\n\n可以无限变小直到自己会做为止。\n\n# 分治步骤\n\n1. 分解：将原问题分解成规模较小的子问题\n\n- 原问题可以被分为多个子问题 P1,P2,...,PK\n- 子问题形式需要和原问题一致\n\n2. 解决：通过递归的方式解决子问题\n\n- P1,P2 独立解，以及 P1,P2 共同相关的解\n\n3. 合并，对子问题的解进行合并，形成原问题的解。\n\n# 快速排序\n\n## 分解\n\n选择一个主元素 k，将原数组分解为两个子数组，小于主元素的所有元素组成了一个子数组，大于主元素的所有元素组成了另外一个子数组。\n[<=k] [>k]\n\n## 解决\n\n对子数组进行递归调用解决\n\n## 合并\n\n通过上述步骤，对已完成原数组的排序，无需合并操作\n","slug":"leetcode/divide-and-conquer/base","published":1,"updated":"2024-10-20T06:31:07.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwww0034m32v1rjufsry","content":"<h1 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h1><blockquote>\n<p>规模较大的问题分解为规模较少的问题，较小的问题分解成更小的问题，直到容易解决为止</p>\n</blockquote>\n<ul>\n<li>对较小问题解决，是继续分解————递归方程</li>\n<li>直到容易解决为止(通常一个元素)，边界条件</li>\n</ul>\n<p>可以无限变小直到自己会做为止。</p>\n<h1 id=\"分治步骤\"><a href=\"#分治步骤\" class=\"headerlink\" title=\"分治步骤\"></a>分治步骤</h1><ol>\n<li>分解：将原问题分解成规模较小的子问题</li>\n</ol>\n<ul>\n<li>原问题可以被分为多个子问题 P1,P2,…,PK</li>\n<li>子问题形式需要和原问题一致</li>\n</ul>\n<ol start=\"2\">\n<li>解决：通过递归的方式解决子问题</li>\n</ol>\n<ul>\n<li>P1,P2 独立解，以及 P1,P2 共同相关的解</li>\n</ul>\n<ol start=\"3\">\n<li>合并，对子问题的解进行合并，形成原问题的解。</li>\n</ol>\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><h2 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h2><p>选择一个主元素 k，将原数组分解为两个子数组，小于主元素的所有元素组成了一个子数组，大于主元素的所有元素组成了另外一个子数组。<br>[&lt;&#x3D;k] [&gt;k]</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>对子数组进行递归调用解决</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>通过上述步骤，对已完成原数组的排序，无需合并操作</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h1><blockquote>\n<p>规模较大的问题分解为规模较少的问题，较小的问题分解成更小的问题，直到容易解决为止</p>\n</blockquote>\n<ul>\n<li>对较小问题解决，是继续分解————递归方程</li>\n<li>直到容易解决为止(通常一个元素)，边界条件</li>\n</ul>\n<p>可以无限变小直到自己会做为止。</p>\n<h1 id=\"分治步骤\"><a href=\"#分治步骤\" class=\"headerlink\" title=\"分治步骤\"></a>分治步骤</h1><ol>\n<li>分解：将原问题分解成规模较小的子问题</li>\n</ol>\n<ul>\n<li>原问题可以被分为多个子问题 P1,P2,…,PK</li>\n<li>子问题形式需要和原问题一致</li>\n</ul>\n<ol start=\"2\">\n<li>解决：通过递归的方式解决子问题</li>\n</ol>\n<ul>\n<li>P1,P2 独立解，以及 P1,P2 共同相关的解</li>\n</ul>\n<ol start=\"3\">\n<li>合并，对子问题的解进行合并，形成原问题的解。</li>\n</ol>\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><h2 id=\"分解\"><a href=\"#分解\" class=\"headerlink\" title=\"分解\"></a>分解</h2><p>选择一个主元素 k，将原数组分解为两个子数组，小于主元素的所有元素组成了一个子数组，大于主元素的所有元素组成了另外一个子数组。<br>[&lt;&#x3D;k] [&gt;k]</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>对子数组进行递归调用解决</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>通过上述步骤，对已完成原数组的排序，无需合并操作</p>\n"},{"title":"棋盘覆盖问题","date":"2024-10-20T10:23:16.015Z","_content":"\n# 题目描述\n\n> 在一个 2^k×2^k 个方格组成的棋盘上，存在一个特殊的方格，这个特殊方格不能被覆盖，要求用四种 L 型骨牌覆盖出特殊方格外的整个棋盘。任意两个 L 型骨牌不能重叠。\n\n二维的需要在 x,y 上对半分\n\n制造特殊格子\n","source":"_posts/leetcode/divide-and-conquer/棋盘覆盖问题.md","raw":"---\ntitle: 棋盘覆盖问题\ndate:\ntags: [算法, 分治法]\ncategories: [前端, 算法, 分治法, 棋盘覆盖问题]\n---\n\n# 题目描述\n\n> 在一个 2^k×2^k 个方格组成的棋盘上，存在一个特殊的方格，这个特殊方格不能被覆盖，要求用四种 L 型骨牌覆盖出特殊方格外的整个棋盘。任意两个 L 型骨牌不能重叠。\n\n二维的需要在 x,y 上对半分\n\n制造特殊格子\n","slug":"leetcode/divide-and-conquer/棋盘覆盖问题","published":1,"updated":"2024-10-20T11:32:51.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwww0037m32vc3coar4e","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>在一个 2^k×2^k 个方格组成的棋盘上，存在一个特殊的方格，这个特殊方格不能被覆盖，要求用四种 L 型骨牌覆盖出特殊方格外的整个棋盘。任意两个 L 型骨牌不能重叠。</p>\n</blockquote>\n<p>二维的需要在 x,y 上对半分</p>\n<p>制造特殊格子</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>在一个 2^k×2^k 个方格组成的棋盘上，存在一个特殊的方格，这个特殊方格不能被覆盖，要求用四种 L 型骨牌覆盖出特殊方格外的整个棋盘。任意两个 L 型骨牌不能重叠。</p>\n</blockquote>\n<p>二维的需要在 x,y 上对半分</p>\n<p>制造特殊格子</p>\n"},{"title":"0-1背包问题","date":"2024-10-20T13:21:26.847Z","_content":"\n# 题目描述\n\n> 给定 n 种物品和一背包。物品 i 的重量是 wi，其价值为 vi，背包容量为 C（也就是背包的总承重 C）。问，应如何选择装入背包的物品，使得背包的物品的总价值 V 最大化\n\n# 分析\n\n## 分析 0-1 背包问题最优解的结构特征\n\n1. 一种情况是第 n 个物品不包含在背包中\n   设 x\\* = （x1,x2,x3,...,xn-1,xn）  \n   则（x1,x2,x3,...,xn-1）必为第 n-1 个物品（剔除第 n 个物品），且背包容易为 C 情况下的最优解\n2. 第二种情况是 n 个物品包含在背包中\n   则（x1,x2,x3,...,xn-1）必为第 n-1 个物品，在背包容量为 C-wn 情况下的最优解\n\n## 找出 0-1 背包问题最优解对应的最优值，并递归定义最优值\n\n在 n 个物品中，背包容量为 C 情况下总价值，用 m(n,C)表示最优值\n\n```\nm(n,C) = {\n  0,                              n=0或C=0\n  max{m(n-1,C), m(n-1,C-wn)+vn}   wn<C\n  m(n-1,C)                        wn>C\n}\n```\n\n## 自底向上求最优值\n\n## 根据 m 值矩阵得出最优解\n","source":"_posts/leetcode/dynamic-programming/0-1背包问题.md","raw":"---\ntitle: 0-1背包问题\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划, 0-1背包问题]\n---\n\n# 题目描述\n\n> 给定 n 种物品和一背包。物品 i 的重量是 wi，其价值为 vi，背包容量为 C（也就是背包的总承重 C）。问，应如何选择装入背包的物品，使得背包的物品的总价值 V 最大化\n\n# 分析\n\n## 分析 0-1 背包问题最优解的结构特征\n\n1. 一种情况是第 n 个物品不包含在背包中\n   设 x\\* = （x1,x2,x3,...,xn-1,xn）  \n   则（x1,x2,x3,...,xn-1）必为第 n-1 个物品（剔除第 n 个物品），且背包容易为 C 情况下的最优解\n2. 第二种情况是 n 个物品包含在背包中\n   则（x1,x2,x3,...,xn-1）必为第 n-1 个物品，在背包容量为 C-wn 情况下的最优解\n\n## 找出 0-1 背包问题最优解对应的最优值，并递归定义最优值\n\n在 n 个物品中，背包容量为 C 情况下总价值，用 m(n,C)表示最优值\n\n```\nm(n,C) = {\n  0,                              n=0或C=0\n  max{m(n-1,C), m(n-1,C-wn)+vn}   wn<C\n  m(n-1,C)                        wn>C\n}\n```\n\n## 自底向上求最优值\n\n## 根据 m 值矩阵得出最优解\n","slug":"leetcode/dynamic-programming/0-1背包问题","published":1,"updated":"2024-10-20T14:15:20.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwx003am32vby1zbpjc","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定 n 种物品和一背包。物品 i 的重量是 wi，其价值为 vi，背包容量为 C（也就是背包的总承重 C）。问，应如何选择装入背包的物品，使得背包的物品的总价值 V 最大化</p>\n</blockquote>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"分析-0-1-背包问题最优解的结构特征\"><a href=\"#分析-0-1-背包问题最优解的结构特征\" class=\"headerlink\" title=\"分析 0-1 背包问题最优解的结构特征\"></a>分析 0-1 背包问题最优解的结构特征</h2><ol>\n<li>一种情况是第 n 个物品不包含在背包中<br>设 x* &#x3D; （x1,x2,x3,…,xn-1,xn）<br>则（x1,x2,x3,…,xn-1）必为第 n-1 个物品（剔除第 n 个物品），且背包容易为 C 情况下的最优解</li>\n<li>第二种情况是 n 个物品包含在背包中<br>则（x1,x2,x3,…,xn-1）必为第 n-1 个物品，在背包容量为 C-wn 情况下的最优解</li>\n</ol>\n<h2 id=\"找出-0-1-背包问题最优解对应的最优值，并递归定义最优值\"><a href=\"#找出-0-1-背包问题最优解对应的最优值，并递归定义最优值\" class=\"headerlink\" title=\"找出 0-1 背包问题最优解对应的最优值，并递归定义最优值\"></a>找出 0-1 背包问题最优解对应的最优值，并递归定义最优值</h2><p>在 n 个物品中，背包容量为 C 情况下总价值，用 m(n,C)表示最优值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m(n,C) = &#123;</span><br><span class=\"line\">  0,                              n=0或C=0</span><br><span class=\"line\">  max&#123;m(n-1,C), m(n-1,C-wn)+vn&#125;   wn&lt;C</span><br><span class=\"line\">  m(n-1,C)                        wn&gt;C</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上求最优值\"><a href=\"#自底向上求最优值\" class=\"headerlink\" title=\"自底向上求最优值\"></a>自底向上求最优值</h2><h2 id=\"根据-m-值矩阵得出最优解\"><a href=\"#根据-m-值矩阵得出最优解\" class=\"headerlink\" title=\"根据 m 值矩阵得出最优解\"></a>根据 m 值矩阵得出最优解</h2>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定 n 种物品和一背包。物品 i 的重量是 wi，其价值为 vi，背包容量为 C（也就是背包的总承重 C）。问，应如何选择装入背包的物品，使得背包的物品的总价值 V 最大化</p>\n</blockquote>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><h2 id=\"分析-0-1-背包问题最优解的结构特征\"><a href=\"#分析-0-1-背包问题最优解的结构特征\" class=\"headerlink\" title=\"分析 0-1 背包问题最优解的结构特征\"></a>分析 0-1 背包问题最优解的结构特征</h2><ol>\n<li>一种情况是第 n 个物品不包含在背包中<br>设 x* &#x3D; （x1,x2,x3,…,xn-1,xn）<br>则（x1,x2,x3,…,xn-1）必为第 n-1 个物品（剔除第 n 个物品），且背包容易为 C 情况下的最优解</li>\n<li>第二种情况是 n 个物品包含在背包中<br>则（x1,x2,x3,…,xn-1）必为第 n-1 个物品，在背包容量为 C-wn 情况下的最优解</li>\n</ol>\n<h2 id=\"找出-0-1-背包问题最优解对应的最优值，并递归定义最优值\"><a href=\"#找出-0-1-背包问题最优解对应的最优值，并递归定义最优值\" class=\"headerlink\" title=\"找出 0-1 背包问题最优解对应的最优值，并递归定义最优值\"></a>找出 0-1 背包问题最优解对应的最优值，并递归定义最优值</h2><p>在 n 个物品中，背包容量为 C 情况下总价值，用 m(n,C)表示最优值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m(n,C) = &#123;</span><br><span class=\"line\">  0,                              n=0或C=0</span><br><span class=\"line\">  max&#123;m(n-1,C), m(n-1,C-wn)+vn&#125;   wn&lt;C</span><br><span class=\"line\">  m(n-1,C)                        wn&gt;C</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上求最优值\"><a href=\"#自底向上求最优值\" class=\"headerlink\" title=\"自底向上求最优值\"></a>自底向上求最优值</h2><h2 id=\"根据-m-值矩阵得出最优解\"><a href=\"#根据-m-值矩阵得出最优解\" class=\"headerlink\" title=\"根据 m 值矩阵得出最优解\"></a>根据 m 值矩阵得出最优解</h2>"},{"title":"动态规划的基础","date":"2024-10-20T12:14:45.275Z","_content":"\n# 基本性质\n\n- 和分治相似\n  - 动态规划也是将原问题分解成子问题求解\n- 和分治不同\n  - 不是通过分治的递归方式，而是自底向上的求解问题\n\n# 机器人问题\n\n## 分治\n\n```\npath(i,j) = {\n  0,                              i=0,j=0;\n  1,                              i=0,j不等于0 或者i不等于0，j=0;\n  path(i-1,j)+path(i,j-1),        其他\n}\n```\n\n# 动态规划适应场景\n\n1. 子问题并不独立，即子问题是可能重复的\n2. 主要用于优化问题（求最优解），且问题具有最优子结构性质\n\n## 最优子结构性质\n\n> 最优子结构性质指原问题的最优解一定包含了子问题的最优解\n\n最短路径问题，具有最优子结构性质\n\n# 基本步骤\n\n1. 定义子问题，并分析最优解的结构特征\n\n- 分治通常是将原问题对半分，而动态规划是将 n 规模问题分解成 n-1 规模问题\n\n2. 找出最优解对应的最优值，并递归定义最优值\n3. 以自底而上的方式计算出最优值\n4. 根据计算最优值时得到的信息，构造最优解\n","source":"_posts/leetcode/dynamic-programming/base.md","raw":"---\ntitle: 动态规划的基础\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划]\n---\n\n# 基本性质\n\n- 和分治相似\n  - 动态规划也是将原问题分解成子问题求解\n- 和分治不同\n  - 不是通过分治的递归方式，而是自底向上的求解问题\n\n# 机器人问题\n\n## 分治\n\n```\npath(i,j) = {\n  0,                              i=0,j=0;\n  1,                              i=0,j不等于0 或者i不等于0，j=0;\n  path(i-1,j)+path(i,j-1),        其他\n}\n```\n\n# 动态规划适应场景\n\n1. 子问题并不独立，即子问题是可能重复的\n2. 主要用于优化问题（求最优解），且问题具有最优子结构性质\n\n## 最优子结构性质\n\n> 最优子结构性质指原问题的最优解一定包含了子问题的最优解\n\n最短路径问题，具有最优子结构性质\n\n# 基本步骤\n\n1. 定义子问题，并分析最优解的结构特征\n\n- 分治通常是将原问题对半分，而动态规划是将 n 规模问题分解成 n-1 规模问题\n\n2. 找出最优解对应的最优值，并递归定义最优值\n3. 以自底而上的方式计算出最优值\n4. 根据计算最优值时得到的信息，构造最优解\n","slug":"leetcode/dynamic-programming/base","published":1,"updated":"2024-10-20T12:44:00.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwx003dm32vgit07oot","content":"<h1 id=\"基本性质\"><a href=\"#基本性质\" class=\"headerlink\" title=\"基本性质\"></a>基本性质</h1><ul>\n<li>和分治相似<ul>\n<li>动态规划也是将原问题分解成子问题求解</li>\n</ul>\n</li>\n<li>和分治不同<ul>\n<li>不是通过分治的递归方式，而是自底向上的求解问题</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"机器人问题\"><a href=\"#机器人问题\" class=\"headerlink\" title=\"机器人问题\"></a>机器人问题</h1><h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path(i,j) = &#123;</span><br><span class=\"line\">  0,                              i=0,j=0;</span><br><span class=\"line\">  1,                              i=0,j不等于0 或者i不等于0，j=0;</span><br><span class=\"line\">  path(i-1,j)+path(i,j-1),        其他</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"动态规划适应场景\"><a href=\"#动态规划适应场景\" class=\"headerlink\" title=\"动态规划适应场景\"></a>动态规划适应场景</h1><ol>\n<li>子问题并不独立，即子问题是可能重复的</li>\n<li>主要用于优化问题（求最优解），且问题具有最优子结构性质</li>\n</ol>\n<h2 id=\"最优子结构性质\"><a href=\"#最优子结构性质\" class=\"headerlink\" title=\"最优子结构性质\"></a>最优子结构性质</h2><blockquote>\n<p>最优子结构性质指原问题的最优解一定包含了子问题的最优解</p>\n</blockquote>\n<p>最短路径问题，具有最优子结构性质</p>\n<h1 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h1><ol>\n<li>定义子问题，并分析最优解的结构特征</li>\n</ol>\n<ul>\n<li>分治通常是将原问题对半分，而动态规划是将 n 规模问题分解成 n-1 规模问题</li>\n</ul>\n<ol start=\"2\">\n<li>找出最优解对应的最优值，并递归定义最优值</li>\n<li>以自底而上的方式计算出最优值</li>\n<li>根据计算最优值时得到的信息，构造最优解</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"基本性质\"><a href=\"#基本性质\" class=\"headerlink\" title=\"基本性质\"></a>基本性质</h1><ul>\n<li>和分治相似<ul>\n<li>动态规划也是将原问题分解成子问题求解</li>\n</ul>\n</li>\n<li>和分治不同<ul>\n<li>不是通过分治的递归方式，而是自底向上的求解问题</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"机器人问题\"><a href=\"#机器人问题\" class=\"headerlink\" title=\"机器人问题\"></a>机器人问题</h1><h2 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">path(i,j) = &#123;</span><br><span class=\"line\">  0,                              i=0,j=0;</span><br><span class=\"line\">  1,                              i=0,j不等于0 或者i不等于0，j=0;</span><br><span class=\"line\">  path(i-1,j)+path(i,j-1),        其他</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"动态规划适应场景\"><a href=\"#动态规划适应场景\" class=\"headerlink\" title=\"动态规划适应场景\"></a>动态规划适应场景</h1><ol>\n<li>子问题并不独立，即子问题是可能重复的</li>\n<li>主要用于优化问题（求最优解），且问题具有最优子结构性质</li>\n</ol>\n<h2 id=\"最优子结构性质\"><a href=\"#最优子结构性质\" class=\"headerlink\" title=\"最优子结构性质\"></a>最优子结构性质</h2><blockquote>\n<p>最优子结构性质指原问题的最优解一定包含了子问题的最优解</p>\n</blockquote>\n<p>最短路径问题，具有最优子结构性质</p>\n<h1 id=\"基本步骤\"><a href=\"#基本步骤\" class=\"headerlink\" title=\"基本步骤\"></a>基本步骤</h1><ol>\n<li>定义子问题，并分析最优解的结构特征</li>\n</ol>\n<ul>\n<li>分治通常是将原问题对半分，而动态规划是将 n 规模问题分解成 n-1 规模问题</li>\n</ul>\n<ol start=\"2\">\n<li>找出最优解对应的最优值，并递归定义最优值</li>\n<li>以自底而上的方式计算出最优值</li>\n<li>根据计算最优值时得到的信息，构造最优解</li>\n</ol>\n"},{"title":"最大子数组问题","date":"2024-10-20T12:46:26.548Z","_content":"\n# 题目描述\n\n> 给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。\n\n# 动态规划逻辑\n\n- n-1 为原问题 n 的子问题\n- 求解改为：包含数组最后一个元素的最大子数组\n- 最大子数组问题的最优解的结构特征\n  B[n] = B[n-a]Uxn\n- 找出最优解对应的最优值，并递归的定义最优值\n\n```\n    b[n] = {\n      b[n-1] + xn           b[n-1]>0;\n      xn                    b[n-1]<=0;\n    }\n```\n\n- 自底向上求解最优值\n","source":"_posts/leetcode/dynamic-programming/最大子数组问题.md","raw":"---\ntitle: 最大子数组问题\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划, 最大子数组问题]\n---\n\n# 题目描述\n\n> 给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。\n\n# 动态规划逻辑\n\n- n-1 为原问题 n 的子问题\n- 求解改为：包含数组最后一个元素的最大子数组\n- 最大子数组问题的最优解的结构特征\n  B[n] = B[n-a]Uxn\n- 找出最优解对应的最优值，并递归的定义最优值\n\n```\n    b[n] = {\n      b[n-1] + xn           b[n-1]>0;\n      xn                    b[n-1]<=0;\n    }\n```\n\n- 自底向上求解最优值\n","slug":"leetcode/dynamic-programming/最大子数组问题","published":1,"updated":"2024-10-20T13:12:25.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwy003hm32v17zp14xs","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。</p>\n</blockquote>\n<h1 id=\"动态规划逻辑\"><a href=\"#动态规划逻辑\" class=\"headerlink\" title=\"动态规划逻辑\"></a>动态规划逻辑</h1><ul>\n<li>n-1 为原问题 n 的子问题</li>\n<li>求解改为：包含数组最后一个元素的最大子数组</li>\n<li>最大子数组问题的最优解的结构特征<br>B[n] &#x3D; B[n-a]Uxn</li>\n<li>找出最优解对应的最优值，并递归的定义最优值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b[n] = &#123;</span><br><span class=\"line\">  b[n-1] + xn           b[n-1]&gt;0;</span><br><span class=\"line\">  xn                    b[n-1]&lt;=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自底向上求解最优值</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定一个数组 A，找出此数组中，所有子数组中和最大的子数组，即为最大子数组问题。</p>\n</blockquote>\n<h1 id=\"动态规划逻辑\"><a href=\"#动态规划逻辑\" class=\"headerlink\" title=\"动态规划逻辑\"></a>动态规划逻辑</h1><ul>\n<li>n-1 为原问题 n 的子问题</li>\n<li>求解改为：包含数组最后一个元素的最大子数组</li>\n<li>最大子数组问题的最优解的结构特征<br>B[n] &#x3D; B[n-a]Uxn</li>\n<li>找出最优解对应的最优值，并递归的定义最优值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b[n] = &#123;</span><br><span class=\"line\">  b[n-1] + xn           b[n-1]&gt;0;</span><br><span class=\"line\">  xn                    b[n-1]&lt;=0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自底向上求解最优值</li>\n</ul>\n"},{"title":"旅行商问题","date":"2024-10-26T02:05:37.929Z","_content":"\n# 题目描述\n\n> G = (V,E) 是一个带权重的完全图，顶点个数|v| = n(顶点代表城市 c)，每条边 eij∈E 赋予权重 dij 代表从顶点 ci 到顶点 cj 的距离或者费用。令 π 对对所有顶点的任一排列（排列代表访问城市序列），f（π）为排列的总长度（或）费用，则旅行商问题求\n\n从第一个城市到第 n 个城市，再从第 n 个城市回来\n\n# 旅行商问题的最优解结构特征\n\n- 最优解子结构性质\n\n- 子问题重叠\n  如以下路径 c1c2c3c4....cn 和 c1c3c2c4....cn 都有子问题 c4....cn\n\n# 旅行商问题最优解对应的最优值，并递归定义最优值\n\nmin TSP(c1，C/ci,cj)+dji\n\n得出递归方程\n\n```\nTSP(c1，C/ci,cj)= {\n  d(c1,cj)                   |c|=1,i≠1\n\n  min TSP(c1，C/ci,cj)+dji   其他\n}\n\nTSP* = TSP(c1，C/ci,cj) +dj1\n```\n\n# 自底向上求最优解\n","source":"_posts/leetcode/dynamic-programming/旅行商问题.md","raw":"---\ntitle: 旅行商问题\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划, 旅行商问题]\n---\n\n# 题目描述\n\n> G = (V,E) 是一个带权重的完全图，顶点个数|v| = n(顶点代表城市 c)，每条边 eij∈E 赋予权重 dij 代表从顶点 ci 到顶点 cj 的距离或者费用。令 π 对对所有顶点的任一排列（排列代表访问城市序列），f（π）为排列的总长度（或）费用，则旅行商问题求\n\n从第一个城市到第 n 个城市，再从第 n 个城市回来\n\n# 旅行商问题的最优解结构特征\n\n- 最优解子结构性质\n\n- 子问题重叠\n  如以下路径 c1c2c3c4....cn 和 c1c3c2c4....cn 都有子问题 c4....cn\n\n# 旅行商问题最优解对应的最优值，并递归定义最优值\n\nmin TSP(c1，C/ci,cj)+dji\n\n得出递归方程\n\n```\nTSP(c1，C/ci,cj)= {\n  d(c1,cj)                   |c|=1,i≠1\n\n  min TSP(c1，C/ci,cj)+dji   其他\n}\n\nTSP* = TSP(c1，C/ci,cj) +dj1\n```\n\n# 自底向上求最优解\n","slug":"leetcode/dynamic-programming/旅行商问题","published":1,"updated":"2024-10-26T02:44:45.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwy003jm32v7tti87s1","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>G &#x3D; (V,E) 是一个带权重的完全图，顶点个数|v| &#x3D; n(顶点代表城市 c)，每条边 eij∈E 赋予权重 dij 代表从顶点 ci 到顶点 cj 的距离或者费用。令 π 对对所有顶点的任一排列（排列代表访问城市序列），f（π）为排列的总长度（或）费用，则旅行商问题求</p>\n</blockquote>\n<p>从第一个城市到第 n 个城市，再从第 n 个城市回来</p>\n<h1 id=\"旅行商问题的最优解结构特征\"><a href=\"#旅行商问题的最优解结构特征\" class=\"headerlink\" title=\"旅行商问题的最优解结构特征\"></a>旅行商问题的最优解结构特征</h1><ul>\n<li><p>最优解子结构性质</p>\n</li>\n<li><p>子问题重叠<br>如以下路径 c1c2c3c4….cn 和 c1c3c2c4….cn 都有子问题 c4….cn</p>\n</li>\n</ul>\n<h1 id=\"旅行商问题最优解对应的最优值，并递归定义最优值\"><a href=\"#旅行商问题最优解对应的最优值，并递归定义最优值\" class=\"headerlink\" title=\"旅行商问题最优解对应的最优值，并递归定义最优值\"></a>旅行商问题最优解对应的最优值，并递归定义最优值</h1><p>min TSP(c1，C&#x2F;ci,cj)+dji</p>\n<p>得出递归方程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TSP(c1，C/ci,cj)= &#123;</span><br><span class=\"line\">  d(c1,cj)                   |c|=1,i≠1</span><br><span class=\"line\"></span><br><span class=\"line\">  min TSP(c1，C/ci,cj)+dji   其他</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TSP* = TSP(c1，C/ci,cj) +dj1</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自底向上求最优解\"><a href=\"#自底向上求最优解\" class=\"headerlink\" title=\"自底向上求最优解\"></a>自底向上求最优解</h1>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>G &#x3D; (V,E) 是一个带权重的完全图，顶点个数|v| &#x3D; n(顶点代表城市 c)，每条边 eij∈E 赋予权重 dij 代表从顶点 ci 到顶点 cj 的距离或者费用。令 π 对对所有顶点的任一排列（排列代表访问城市序列），f（π）为排列的总长度（或）费用，则旅行商问题求</p>\n</blockquote>\n<p>从第一个城市到第 n 个城市，再从第 n 个城市回来</p>\n<h1 id=\"旅行商问题的最优解结构特征\"><a href=\"#旅行商问题的最优解结构特征\" class=\"headerlink\" title=\"旅行商问题的最优解结构特征\"></a>旅行商问题的最优解结构特征</h1><ul>\n<li><p>最优解子结构性质</p>\n</li>\n<li><p>子问题重叠<br>如以下路径 c1c2c3c4….cn 和 c1c3c2c4….cn 都有子问题 c4….cn</p>\n</li>\n</ul>\n<h1 id=\"旅行商问题最优解对应的最优值，并递归定义最优值\"><a href=\"#旅行商问题最优解对应的最优值，并递归定义最优值\" class=\"headerlink\" title=\"旅行商问题最优解对应的最优值，并递归定义最优值\"></a>旅行商问题最优解对应的最优值，并递归定义最优值</h1><p>min TSP(c1，C&#x2F;ci,cj)+dji</p>\n<p>得出递归方程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TSP(c1，C/ci,cj)= &#123;</span><br><span class=\"line\">  d(c1,cj)                   |c|=1,i≠1</span><br><span class=\"line\"></span><br><span class=\"line\">  min TSP(c1，C/ci,cj)+dji   其他</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TSP* = TSP(c1，C/ci,cj) +dj1</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自底向上求最优解\"><a href=\"#自底向上求最优解\" class=\"headerlink\" title=\"自底向上求最优解\"></a>自底向上求最优解</h1>"},{"title":"状态压缩动态规划","date":"2024-10-26T04:35:55.778Z","_content":"\n# 状态压缩动态规划\n\n- 集合状态压缩\n  - 用二进制表示集合，之后使用整型表示二进制，如旅行商问题的 TP 数组\n- 空间状态压缩\n  - 自底向上的方法求解最优值过程中，压缩最优值的存储空间\n","source":"_posts/leetcode/dynamic-programming/状态压缩动态规划.md","raw":"---\ntitle: 状态压缩动态规划\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划, 状态压缩动态规划]\n---\n\n# 状态压缩动态规划\n\n- 集合状态压缩\n  - 用二进制表示集合，之后使用整型表示二进制，如旅行商问题的 TP 数组\n- 空间状态压缩\n  - 自底向上的方法求解最优值过程中，压缩最优值的存储空间\n","slug":"leetcode/dynamic-programming/状态压缩动态规划","published":1,"updated":"2024-10-26T04:38:48.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwz003om32vhgds1o2r","content":"<h1 id=\"状态压缩动态规划\"><a href=\"#状态压缩动态规划\" class=\"headerlink\" title=\"状态压缩动态规划\"></a>状态压缩动态规划</h1><ul>\n<li>集合状态压缩<ul>\n<li>用二进制表示集合，之后使用整型表示二进制，如旅行商问题的 TP 数组</li>\n</ul>\n</li>\n<li>空间状态压缩<ul>\n<li>自底向上的方法求解最优值过程中，压缩最优值的存储空间</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"状态压缩动态规划\"><a href=\"#状态压缩动态规划\" class=\"headerlink\" title=\"状态压缩动态规划\"></a>状态压缩动态规划</h1><ul>\n<li>集合状态压缩<ul>\n<li>用二进制表示集合，之后使用整型表示二进制，如旅行商问题的 TP 数组</li>\n</ul>\n</li>\n<li>空间状态压缩<ul>\n<li>自底向上的方法求解最优值过程中，压缩最优值的存储空间</li>\n</ul>\n</li>\n</ul>\n"},{"title":"【tinymce】之图片上传","date":"2024-08-03T10:15:11.768Z","_content":"\n###\n","source":"_posts/tools/tinymce/image.md","raw":"---\ntitle: 【tinymce】之图片上传\ndate:\ntags: [前端, tinymce]\ncategories: [前端, tinymce, tools]\n---\n\n###\n","slug":"tools/tinymce/image","published":1,"updated":"2024-08-03T10:50:51.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwwz003qm32v5qx782sj","content":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>"},{"title":"最长公共子序列","date":"2024-10-26T02:46:36.001Z","_content":"\n# 题目描述\n\n> 给定序列 X={x1,xn},序列 Z{z1,zn},是 X 的子序列是指存在一个严格递增下标序列{i1,ik}使得对于所有 j=1,..k 有 zj = xij\n\n例如 Z={B,C,D,B}是序列 X={A,B,C,D,B,A}的子序列，想要的递增下标序列为{2,3,5,7}\n\n# 穷举法\n\n- 找出 X 字符所有可能的子序列 2^n\n- 对于 x 的每一个子序列，判断其是否是 Y 的一个子序列，需要的时间为 m\n- 求的总时长 (2^n) \\* m\n\n# 动态规划\n\n## 最优值\n\n当 X 有 i 个元素，Y 有 j 个元素，最长公共子序列的长度 lij\n\n```\nlij = {\n  0                       i=0 或者j=0 （边界条件）\n  l(i-1,j-1)+1              i>0，j>0,  and Xi = Yj\n  max{l[i-1,j],l[i,j-1]}  i>0,j>0,and Xi≠Yj\n}\n```\n\n## 自底向上计算最优值\n","source":"_posts/leetcode/dynamic-programming/最长公共子序列.md","raw":"---\ntitle: 最长公共子序列\ndate:\ntags: [算法, 动态规划]\ncategories: [前端, 算法, 动态规划, 最长公共子序列]\n---\n\n# 题目描述\n\n> 给定序列 X={x1,xn},序列 Z{z1,zn},是 X 的子序列是指存在一个严格递增下标序列{i1,ik}使得对于所有 j=1,..k 有 zj = xij\n\n例如 Z={B,C,D,B}是序列 X={A,B,C,D,B,A}的子序列，想要的递增下标序列为{2,3,5,7}\n\n# 穷举法\n\n- 找出 X 字符所有可能的子序列 2^n\n- 对于 x 的每一个子序列，判断其是否是 Y 的一个子序列，需要的时间为 m\n- 求的总时长 (2^n) \\* m\n\n# 动态规划\n\n## 最优值\n\n当 X 有 i 个元素，Y 有 j 个元素，最长公共子序列的长度 lij\n\n```\nlij = {\n  0                       i=0 或者j=0 （边界条件）\n  l(i-1,j-1)+1              i>0，j>0,  and Xi = Yj\n  max{l[i-1,j],l[i,j-1]}  i>0,j>0,and Xi≠Yj\n}\n```\n\n## 自底向上计算最优值\n","slug":"leetcode/dynamic-programming/最长公共子序列","published":1,"updated":"2024-10-26T04:26:25.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx0003um32v1g74ev3o","content":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定序列 X&#x3D;{x1,xn},序列 Z{z1,zn},是 X 的子序列是指存在一个严格递增下标序列{i1,ik}使得对于所有 j&#x3D;1,..k 有 zj &#x3D; xij</p>\n</blockquote>\n<p>例如 Z&#x3D;{B,C,D,B}是序列 X&#x3D;{A,B,C,D,B,A}的子序列，想要的递增下标序列为{2,3,5,7}</p>\n<h1 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h1><ul>\n<li>找出 X 字符所有可能的子序列 2^n</li>\n<li>对于 x 的每一个子序列，判断其是否是 Y 的一个子序列，需要的时间为 m</li>\n<li>求的总时长 (2^n) * m</li>\n</ul>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"最优值\"><a href=\"#最优值\" class=\"headerlink\" title=\"最优值\"></a>最优值</h2><p>当 X 有 i 个元素，Y 有 j 个元素，最长公共子序列的长度 lij</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lij = &#123;</span><br><span class=\"line\">  0                       i=0 或者j=0 （边界条件）</span><br><span class=\"line\">  l(i-1,j-1)+1              i&gt;0，j&gt;0,  and Xi = Yj</span><br><span class=\"line\">  max&#123;l[i-1,j],l[i,j-1]&#125;  i&gt;0,j&gt;0,and Xi≠Yj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上计算最优值\"><a href=\"#自底向上计算最优值\" class=\"headerlink\" title=\"自底向上计算最优值\"></a>自底向上计算最优值</h2>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h1><blockquote>\n<p>给定序列 X&#x3D;{x1,xn},序列 Z{z1,zn},是 X 的子序列是指存在一个严格递增下标序列{i1,ik}使得对于所有 j&#x3D;1,..k 有 zj &#x3D; xij</p>\n</blockquote>\n<p>例如 Z&#x3D;{B,C,D,B}是序列 X&#x3D;{A,B,C,D,B,A}的子序列，想要的递增下标序列为{2,3,5,7}</p>\n<h1 id=\"穷举法\"><a href=\"#穷举法\" class=\"headerlink\" title=\"穷举法\"></a>穷举法</h1><ul>\n<li>找出 X 字符所有可能的子序列 2^n</li>\n<li>对于 x 的每一个子序列，判断其是否是 Y 的一个子序列，需要的时间为 m</li>\n<li>求的总时长 (2^n) * m</li>\n</ul>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"最优值\"><a href=\"#最优值\" class=\"headerlink\" title=\"最优值\"></a>最优值</h2><p>当 X 有 i 个元素，Y 有 j 个元素，最长公共子序列的长度 lij</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lij = &#123;</span><br><span class=\"line\">  0                       i=0 或者j=0 （边界条件）</span><br><span class=\"line\">  l(i-1,j-1)+1              i&gt;0，j&gt;0,  and Xi = Yj</span><br><span class=\"line\">  max&#123;l[i-1,j],l[i,j-1]&#125;  i&gt;0,j&gt;0,and Xi≠Yj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自底向上计算最优值\"><a href=\"#自底向上计算最优值\" class=\"headerlink\" title=\"自底向上计算最优值\"></a>自底向上计算最优值</h2>"},{"title":"【tinymce】tinymce的media设置，解决视频不能选中删除bug","date":"2024-08-03T10:50:30.125Z","_content":"\n# 概览\n\n> 媒体插件为用户增加了将 HTML5 视频和音频元素添加到可编辑区域的能力。它还在“插入”菜单下添加了“插入/编辑视频”项目以及工具栏按钮。\n\n由于，是之前老项目的 tinymce，对其进行相关的优化，并且不影响老项目其他引用模块，只对相应的 media 上传进行设置。\n\n本文主要针对【media 的基本配置】、【视频不能正常显示 bug】、【视频不能选中删除的 bug】、以及【自定义上传】进行描述和解决。\n\n需要注意的是本文针对的 tinymce 版本是 v4，其他高版本不一定适用。\n\n# 基本设置\n\n这里的基本设置，是配置 tinymce 需要配置的工具。初始化时，必须的属性\n\n- selector :tinymce 需要配置的相应 html，如'#tinydemo4'\n- plugins: 必须的插件\n- toolbar：必须的工具栏\n\n```javascript\ntinymce.init({\n  selector: 'textarea', // change this value according to your HTML\n  plugins: 'media',\n  menubar: 'insert',\n  toolbar: 'media',\n})\n```\n\n# 额外设置\n\n## media_live_embeds 媒体实时预览开关\n\n开启此选项后，用户可看到编辑区内嵌入视频的实时预览，而不是占位图。\n**取值： true / false**\n**默认： true**\n此设置对 video 无效\n\n## audio_template_callback 自定义插入音频代码\n\n```javascript\ntinymce.init({\n  selector: '#tinydemo',\n  plugins: 'media',\n  toolbar: 'media',\n  audio_template_callback: function (data) {\n    return (\n      '<audio controls>' +\n      '\\n<source src=\"' +\n      data.source1 +\n      '\"' +\n      (data.source1mime ? ' type=\"' + data.source1mime + '\"' : '') +\n      ' />\\n' +\n      '</audio>'\n    )\n  },\n})\n```\n\n## video_template_callback 自定义插入视频代码\n\n很多文章都是如此配置，但是会出现下面的问题：\n\n- 视频不展示，无法在 tinymce 编辑器播放\n- 视频不能像图片一样进行删除\n\n# 解决视频选中，删除问题的方法\n\n利用 media_url_resolver 进行返回\n\n```javascript\nmedia_live_embeds: true, // 媒体实时预览开关\n// 自定义插入视频代码\nmedia_url_resolver: (data, resolve) => {\n  try {\n    let videoUri = encodeURI(data.url);\n    console.log('media_url_resolverdata===========', data);\n    let embedHtml = `<p\n                    class=\"mce-preview-object mce-object-video\"\n                    contenteditable=\"false\"\n                    data-mce-object=\"video\"\n                    data-mce-p-allowfullscreen=\"allowfullscreen\"\n                    data-mce-p-frameborder=\"no\"\n                    data-mce-p-scrolling=\"no\"\n                    data-mce-p-src=${videoUri} >\n                    <video src=${data.url} width=\"100%\" height=\"auto\" controls=\"controls\">\n                      <source src=\"${data.url}\"/>\n                    </video>\n                    <br data-mce-bogus=\"1\">\n                </p>`;\n    resolve({ html: embedHtml });\n    //  controlslist=\"nodownload\"\n  } catch (e) {\n    resolve({ html: '' });\n  }\n},\n```\n\n# 自定义文件上传\n\n```javascript\ntinymce.init({\n  selector: '#tinydemo4',\n  language: 'zh_CN',\n  plugins: 'link',\n  toolbar: 'link',\n  file_picker_callback: function (callback, value, meta) {\n    //文件分类\n    var filetype =\n      '.pdf, .txt, .zip, .rar, .7z, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .mp3, .mp4'\n    //后端接收上传文件的地址\n    var upurl = '/demo/upfile.php'\n    //为不同插件指定文件类型及后端地址\n    switch (meta.filetype) {\n      case 'image':\n        filetype = '.jpg, .jpeg, .png, .gif'\n        upurl = 'upimg.php'\n        break\n      case 'media':\n        filetype = '.mp3, .mp4'\n        upurl = 'upfile.php'\n        break\n      case 'file':\n      default:\n    }\n    //模拟出一个input用于添加本地文件\n    var input = document.createElement('input')\n    input.setAttribute('type', 'file')\n    input.setAttribute('accept', filetype)\n    input.click()\n    input.onchange = function () {\n      var file = this.files[0]\n\n      var xhr, formData\n      console.log(file.name)\n      xhr = new XMLHttpRequest()\n      xhr.withCredentials = false\n      xhr.open('POST', upurl)\n      xhr.onload = function () {\n        var json\n        if (xhr.status != 200) {\n          failure('HTTP Error: ' + xhr.status)\n          return\n        }\n        json = JSON.parse(xhr.responseText)\n        if (!json || typeof json.location != 'string') {\n          failure('Invalid JSON: ' + xhr.responseText)\n          return\n        }\n        callback(json.location)\n      }\n      formData = new FormData()\n      formData.append('file', file, file.name)\n      xhr.send(formData)\n\n      //下方被注释掉的是官方的一个例子\n      //放到下面给大家参考\n\n      /*var reader = new FileReader();\n            reader.onload = function () {\n                // Note: Now we need to register the blob in TinyMCEs image blob\n                // registry. In the next release this part hopefully won't be\n                // necessary, as we are looking to handle it internally.\n                var id = 'blobid' + (new Date()).getTime();\n                var blobCache =  tinymce.activeEditor.editorUpload.blobCache;\n                var base64 = reader.result.split(',')[1];\n                var blobInfo = blobCache.create(id, file, base64);\n                blobCache.add(blobInfo);\n\n                // call the callback and populate the Title field with the file name\n                callback(blobInfo.blobUri(), { title: file.name });\n            };\n            reader.readAsDataURL(file);*/\n    }\n  },\n})\n```\n\n# 参考链接\n\n- [tinymce 中文文档](http://tinymce.ax-z.cn/general/upload-images.php)\n- [tinymce 官方文档](https://www.tiny.cloud/docs/tinymce/latest/upload-images/)\n- [视频处理](https://www.bilibili.com/read/cv22042918/)\n","source":"_posts/tools/tinymce/tinymce media.md","raw":"---\ntitle: 【tinymce】tinymce的media设置，解决视频不能选中删除bug\ndate:\ntags: [前端, tinymce]\ncategories: [前端, tinymce, tools]\n---\n\n# 概览\n\n> 媒体插件为用户增加了将 HTML5 视频和音频元素添加到可编辑区域的能力。它还在“插入”菜单下添加了“插入/编辑视频”项目以及工具栏按钮。\n\n由于，是之前老项目的 tinymce，对其进行相关的优化，并且不影响老项目其他引用模块，只对相应的 media 上传进行设置。\n\n本文主要针对【media 的基本配置】、【视频不能正常显示 bug】、【视频不能选中删除的 bug】、以及【自定义上传】进行描述和解决。\n\n需要注意的是本文针对的 tinymce 版本是 v4，其他高版本不一定适用。\n\n# 基本设置\n\n这里的基本设置，是配置 tinymce 需要配置的工具。初始化时，必须的属性\n\n- selector :tinymce 需要配置的相应 html，如'#tinydemo4'\n- plugins: 必须的插件\n- toolbar：必须的工具栏\n\n```javascript\ntinymce.init({\n  selector: 'textarea', // change this value according to your HTML\n  plugins: 'media',\n  menubar: 'insert',\n  toolbar: 'media',\n})\n```\n\n# 额外设置\n\n## media_live_embeds 媒体实时预览开关\n\n开启此选项后，用户可看到编辑区内嵌入视频的实时预览，而不是占位图。\n**取值： true / false**\n**默认： true**\n此设置对 video 无效\n\n## audio_template_callback 自定义插入音频代码\n\n```javascript\ntinymce.init({\n  selector: '#tinydemo',\n  plugins: 'media',\n  toolbar: 'media',\n  audio_template_callback: function (data) {\n    return (\n      '<audio controls>' +\n      '\\n<source src=\"' +\n      data.source1 +\n      '\"' +\n      (data.source1mime ? ' type=\"' + data.source1mime + '\"' : '') +\n      ' />\\n' +\n      '</audio>'\n    )\n  },\n})\n```\n\n## video_template_callback 自定义插入视频代码\n\n很多文章都是如此配置，但是会出现下面的问题：\n\n- 视频不展示，无法在 tinymce 编辑器播放\n- 视频不能像图片一样进行删除\n\n# 解决视频选中，删除问题的方法\n\n利用 media_url_resolver 进行返回\n\n```javascript\nmedia_live_embeds: true, // 媒体实时预览开关\n// 自定义插入视频代码\nmedia_url_resolver: (data, resolve) => {\n  try {\n    let videoUri = encodeURI(data.url);\n    console.log('media_url_resolverdata===========', data);\n    let embedHtml = `<p\n                    class=\"mce-preview-object mce-object-video\"\n                    contenteditable=\"false\"\n                    data-mce-object=\"video\"\n                    data-mce-p-allowfullscreen=\"allowfullscreen\"\n                    data-mce-p-frameborder=\"no\"\n                    data-mce-p-scrolling=\"no\"\n                    data-mce-p-src=${videoUri} >\n                    <video src=${data.url} width=\"100%\" height=\"auto\" controls=\"controls\">\n                      <source src=\"${data.url}\"/>\n                    </video>\n                    <br data-mce-bogus=\"1\">\n                </p>`;\n    resolve({ html: embedHtml });\n    //  controlslist=\"nodownload\"\n  } catch (e) {\n    resolve({ html: '' });\n  }\n},\n```\n\n# 自定义文件上传\n\n```javascript\ntinymce.init({\n  selector: '#tinydemo4',\n  language: 'zh_CN',\n  plugins: 'link',\n  toolbar: 'link',\n  file_picker_callback: function (callback, value, meta) {\n    //文件分类\n    var filetype =\n      '.pdf, .txt, .zip, .rar, .7z, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .mp3, .mp4'\n    //后端接收上传文件的地址\n    var upurl = '/demo/upfile.php'\n    //为不同插件指定文件类型及后端地址\n    switch (meta.filetype) {\n      case 'image':\n        filetype = '.jpg, .jpeg, .png, .gif'\n        upurl = 'upimg.php'\n        break\n      case 'media':\n        filetype = '.mp3, .mp4'\n        upurl = 'upfile.php'\n        break\n      case 'file':\n      default:\n    }\n    //模拟出一个input用于添加本地文件\n    var input = document.createElement('input')\n    input.setAttribute('type', 'file')\n    input.setAttribute('accept', filetype)\n    input.click()\n    input.onchange = function () {\n      var file = this.files[0]\n\n      var xhr, formData\n      console.log(file.name)\n      xhr = new XMLHttpRequest()\n      xhr.withCredentials = false\n      xhr.open('POST', upurl)\n      xhr.onload = function () {\n        var json\n        if (xhr.status != 200) {\n          failure('HTTP Error: ' + xhr.status)\n          return\n        }\n        json = JSON.parse(xhr.responseText)\n        if (!json || typeof json.location != 'string') {\n          failure('Invalid JSON: ' + xhr.responseText)\n          return\n        }\n        callback(json.location)\n      }\n      formData = new FormData()\n      formData.append('file', file, file.name)\n      xhr.send(formData)\n\n      //下方被注释掉的是官方的一个例子\n      //放到下面给大家参考\n\n      /*var reader = new FileReader();\n            reader.onload = function () {\n                // Note: Now we need to register the blob in TinyMCEs image blob\n                // registry. In the next release this part hopefully won't be\n                // necessary, as we are looking to handle it internally.\n                var id = 'blobid' + (new Date()).getTime();\n                var blobCache =  tinymce.activeEditor.editorUpload.blobCache;\n                var base64 = reader.result.split(',')[1];\n                var blobInfo = blobCache.create(id, file, base64);\n                blobCache.add(blobInfo);\n\n                // call the callback and populate the Title field with the file name\n                callback(blobInfo.blobUri(), { title: file.name });\n            };\n            reader.readAsDataURL(file);*/\n    }\n  },\n})\n```\n\n# 参考链接\n\n- [tinymce 中文文档](http://tinymce.ax-z.cn/general/upload-images.php)\n- [tinymce 官方文档](https://www.tiny.cloud/docs/tinymce/latest/upload-images/)\n- [视频处理](https://www.bilibili.com/read/cv22042918/)\n","slug":"tools/tinymce/tinymce media","published":1,"updated":"2024-08-03T11:11:27.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx1003vm32v0l8m5e29","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>媒体插件为用户增加了将 HTML5 视频和音频元素添加到可编辑区域的能力。它还在“插入”菜单下添加了“插入&#x2F;编辑视频”项目以及工具栏按钮。</p>\n</blockquote>\n<p>由于，是之前老项目的 tinymce，对其进行相关的优化，并且不影响老项目其他引用模块，只对相应的 media 上传进行设置。</p>\n<p>本文主要针对【media 的基本配置】、【视频不能正常显示 bug】、【视频不能选中删除的 bug】、以及【自定义上传】进行描述和解决。</p>\n<p>需要注意的是本文针对的 tinymce 版本是 v4，其他高版本不一定适用。</p>\n<h1 id=\"基本设置\"><a href=\"#基本设置\" class=\"headerlink\" title=\"基本设置\"></a>基本设置</h1><p>这里的基本设置，是配置 tinymce 需要配置的工具。初始化时，必须的属性</p>\n<ul>\n<li>selector :tinymce 需要配置的相应 html，如’#tinydemo4’</li>\n<li>plugins: 必须的插件</li>\n<li>toolbar：必须的工具栏</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;textarea&#x27;</span>, <span class=\"comment\">// change this value according to your HTML</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">menubar</span>: <span class=\"string\">&#x27;insert&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"额外设置\"><a href=\"#额外设置\" class=\"headerlink\" title=\"额外设置\"></a>额外设置</h1><h2 id=\"media-live-embeds-媒体实时预览开关\"><a href=\"#media-live-embeds-媒体实时预览开关\" class=\"headerlink\" title=\"media_live_embeds 媒体实时预览开关\"></a>media_live_embeds 媒体实时预览开关</h2><p>开启此选项后，用户可看到编辑区内嵌入视频的实时预览，而不是占位图。<br><strong>取值： true &#x2F; false</strong><br><strong>默认： true</strong><br>此设置对 video 无效</p>\n<h2 id=\"audio-template-callback-自定义插入音频代码\"><a href=\"#audio-template-callback-自定义插入音频代码\" class=\"headerlink\" title=\"audio_template_callback 自定义插入音频代码\"></a>audio_template_callback 自定义插入音频代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;#tinydemo&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">audio_template_callback</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"string\">&#x27;&lt;audio controls&gt;&#x27;</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n&lt;source src=&quot;&#x27;</span> +</span><br><span class=\"line\">      data.<span class=\"property\">source1</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;&quot;&#x27;</span> +</span><br><span class=\"line\">      (data.<span class=\"property\">source1mime</span> ? <span class=\"string\">&#x27; type=&quot;&#x27;</span> + data.<span class=\"property\">source1mime</span> + <span class=\"string\">&#x27;&quot;&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span>) +</span><br><span class=\"line\">      <span class=\"string\">&#x27; /&gt;\\n&#x27;</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;&lt;/audio&gt;&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"video-template-callback-自定义插入视频代码\"><a href=\"#video-template-callback-自定义插入视频代码\" class=\"headerlink\" title=\"video_template_callback 自定义插入视频代码\"></a>video_template_callback 自定义插入视频代码</h2><p>很多文章都是如此配置，但是会出现下面的问题：</p>\n<ul>\n<li>视频不展示，无法在 tinymce 编辑器播放</li>\n<li>视频不能像图片一样进行删除</li>\n</ul>\n<h1 id=\"解决视频选中，删除问题的方法\"><a href=\"#解决视频选中，删除问题的方法\" class=\"headerlink\" title=\"解决视频选中，删除问题的方法\"></a>解决视频选中，删除问题的方法</h1><p>利用 media_url_resolver 进行返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">media_live_embeds</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 媒体实时预览开关</span></span><br><span class=\"line\"><span class=\"comment\">// 自定义插入视频代码</span></span><br><span class=\"line\"><span class=\"attr\">media_url_resolver</span>: <span class=\"function\">(<span class=\"params\">data, resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> videoUri = <span class=\"built_in\">encodeURI</span>(data.<span class=\"property\">url</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;media_url_resolverdata===========&#x27;</span>, data);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> embedHtml = <span class=\"string\">`&lt;p</span></span><br><span class=\"line\"><span class=\"string\">                    class=&quot;mce-preview-object mce-object-video&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    contenteditable=&quot;false&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-object=&quot;video&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-allowfullscreen=&quot;allowfullscreen&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-frameborder=&quot;no&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-scrolling=&quot;no&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-src=<span class=\"subst\">$&#123;videoUri&#125;</span> &gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;video src=<span class=\"subst\">$&#123;data.url&#125;</span> width=&quot;100%&quot; height=&quot;auto&quot; controls=&quot;controls&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">                      &lt;source src=&quot;<span class=\"subst\">$&#123;data.url&#125;</span>&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;/video&gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;br data-mce-bogus=&quot;1&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;/p&gt;`</span>;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">html</span>: embedHtml &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//  controlslist=&quot;nodownload&quot;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">html</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自定义文件上传\"><a href=\"#自定义文件上传\" class=\"headerlink\" title=\"自定义文件上传\"></a>自定义文件上传</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;#tinydemo4&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">language</span>: <span class=\"string\">&#x27;zh_CN&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;link&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;link&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">file_picker_callback</span>: <span class=\"keyword\">function</span> (<span class=\"params\">callback, value, meta</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件分类</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> filetype =</span><br><span class=\"line\">      <span class=\"string\">&#x27;.pdf, .txt, .zip, .rar, .7z, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .mp3, .mp4&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//后端接收上传文件的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> upurl = <span class=\"string\">&#x27;/demo/upfile.php&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//为不同插件指定文件类型及后端地址</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (meta.<span class=\"property\">filetype</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;image&#x27;</span>:</span><br><span class=\"line\">        filetype = <span class=\"string\">&#x27;.jpg, .jpeg, .png, .gif&#x27;</span></span><br><span class=\"line\">        upurl = <span class=\"string\">&#x27;upimg.php&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;media&#x27;</span>:</span><br><span class=\"line\">        filetype = <span class=\"string\">&#x27;.mp3, .mp4&#x27;</span></span><br><span class=\"line\">        upurl = <span class=\"string\">&#x27;upfile.php&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;file&#x27;</span>:</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//模拟出一个input用于添加本地文件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;input&#x27;</span>)</span><br><span class=\"line\">    input.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">&#x27;type&#x27;</span>, <span class=\"string\">&#x27;file&#x27;</span>)</span><br><span class=\"line\">    input.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">&#x27;accept&#x27;</span>, filetype)</span><br><span class=\"line\">    input.<span class=\"title function_\">click</span>()</span><br><span class=\"line\">    input.<span class=\"property\">onchange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> file = <span class=\"variable language_\">this</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> xhr, formData</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file.<span class=\"property\">name</span>)</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">      xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">      xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;POST&#x27;</span>, upurl)</span><br><span class=\"line\">      xhr.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> json</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xhr.<span class=\"property\">status</span> != <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">failure</span>(<span class=\"string\">&#x27;HTTP Error: &#x27;</span> + xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!json || <span class=\"keyword\">typeof</span> json.<span class=\"property\">location</span> != <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">failure</span>(<span class=\"string\">&#x27;Invalid JSON: &#x27;</span> + xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"title function_\">callback</span>(json.<span class=\"property\">location</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      formData = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>()</span><br><span class=\"line\">      formData.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;file&#x27;</span>, file, file.<span class=\"property\">name</span>)</span><br><span class=\"line\">      xhr.<span class=\"title function_\">send</span>(formData)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//下方被注释掉的是官方的一个例子</span></span><br><span class=\"line\">      <span class=\"comment\">//放到下面给大家参考</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*var reader = new FileReader();</span></span><br><span class=\"line\"><span class=\"comment\">            reader.onload = function () &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                // Note: Now we need to register the blob in TinyMCEs image blob</span></span><br><span class=\"line\"><span class=\"comment\">                // registry. In the next release this part hopefully won&#x27;t be</span></span><br><span class=\"line\"><span class=\"comment\">                // necessary, as we are looking to handle it internally.</span></span><br><span class=\"line\"><span class=\"comment\">                var id = &#x27;blobid&#x27; + (new Date()).getTime();</span></span><br><span class=\"line\"><span class=\"comment\">                var blobCache =  tinymce.activeEditor.editorUpload.blobCache;</span></span><br><span class=\"line\"><span class=\"comment\">                var base64 = reader.result.split(&#x27;,&#x27;)[1];</span></span><br><span class=\"line\"><span class=\"comment\">                var blobInfo = blobCache.create(id, file, base64);</span></span><br><span class=\"line\"><span class=\"comment\">                blobCache.add(blobInfo);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                // call the callback and populate the Title field with the file name</span></span><br><span class=\"line\"><span class=\"comment\">                callback(blobInfo.blobUri(), &#123; title: file.name &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">            reader.readAsDataURL(file);*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://tinymce.ax-z.cn/general/upload-images.php\">tinymce 中文文档</a></li>\n<li><a href=\"https://www.tiny.cloud/docs/tinymce/latest/upload-images/\">tinymce 官方文档</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv22042918/\">视频处理</a></li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>媒体插件为用户增加了将 HTML5 视频和音频元素添加到可编辑区域的能力。它还在“插入”菜单下添加了“插入&#x2F;编辑视频”项目以及工具栏按钮。</p>\n</blockquote>\n<p>由于，是之前老项目的 tinymce，对其进行相关的优化，并且不影响老项目其他引用模块，只对相应的 media 上传进行设置。</p>\n<p>本文主要针对【media 的基本配置】、【视频不能正常显示 bug】、【视频不能选中删除的 bug】、以及【自定义上传】进行描述和解决。</p>\n<p>需要注意的是本文针对的 tinymce 版本是 v4，其他高版本不一定适用。</p>\n<h1 id=\"基本设置\"><a href=\"#基本设置\" class=\"headerlink\" title=\"基本设置\"></a>基本设置</h1><p>这里的基本设置，是配置 tinymce 需要配置的工具。初始化时，必须的属性</p>\n<ul>\n<li>selector :tinymce 需要配置的相应 html，如’#tinydemo4’</li>\n<li>plugins: 必须的插件</li>\n<li>toolbar：必须的工具栏</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;textarea&#x27;</span>, <span class=\"comment\">// change this value according to your HTML</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">menubar</span>: <span class=\"string\">&#x27;insert&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"额外设置\"><a href=\"#额外设置\" class=\"headerlink\" title=\"额外设置\"></a>额外设置</h1><h2 id=\"media-live-embeds-媒体实时预览开关\"><a href=\"#media-live-embeds-媒体实时预览开关\" class=\"headerlink\" title=\"media_live_embeds 媒体实时预览开关\"></a>media_live_embeds 媒体实时预览开关</h2><p>开启此选项后，用户可看到编辑区内嵌入视频的实时预览，而不是占位图。<br><strong>取值： true &#x2F; false</strong><br><strong>默认： true</strong><br>此设置对 video 无效</p>\n<h2 id=\"audio-template-callback-自定义插入音频代码\"><a href=\"#audio-template-callback-自定义插入音频代码\" class=\"headerlink\" title=\"audio_template_callback 自定义插入音频代码\"></a>audio_template_callback 自定义插入音频代码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;#tinydemo&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;media&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">audio_template_callback</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"string\">&#x27;&lt;audio controls&gt;&#x27;</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n&lt;source src=&quot;&#x27;</span> +</span><br><span class=\"line\">      data.<span class=\"property\">source1</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;&quot;&#x27;</span> +</span><br><span class=\"line\">      (data.<span class=\"property\">source1mime</span> ? <span class=\"string\">&#x27; type=&quot;&#x27;</span> + data.<span class=\"property\">source1mime</span> + <span class=\"string\">&#x27;&quot;&#x27;</span> : <span class=\"string\">&#x27;&#x27;</span>) +</span><br><span class=\"line\">      <span class=\"string\">&#x27; /&gt;\\n&#x27;</span> +</span><br><span class=\"line\">      <span class=\"string\">&#x27;&lt;/audio&gt;&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"video-template-callback-自定义插入视频代码\"><a href=\"#video-template-callback-自定义插入视频代码\" class=\"headerlink\" title=\"video_template_callback 自定义插入视频代码\"></a>video_template_callback 自定义插入视频代码</h2><p>很多文章都是如此配置，但是会出现下面的问题：</p>\n<ul>\n<li>视频不展示，无法在 tinymce 编辑器播放</li>\n<li>视频不能像图片一样进行删除</li>\n</ul>\n<h1 id=\"解决视频选中，删除问题的方法\"><a href=\"#解决视频选中，删除问题的方法\" class=\"headerlink\" title=\"解决视频选中，删除问题的方法\"></a>解决视频选中，删除问题的方法</h1><p>利用 media_url_resolver 进行返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">media_live_embeds</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 媒体实时预览开关</span></span><br><span class=\"line\"><span class=\"comment\">// 自定义插入视频代码</span></span><br><span class=\"line\"><span class=\"attr\">media_url_resolver</span>: <span class=\"function\">(<span class=\"params\">data, resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> videoUri = <span class=\"built_in\">encodeURI</span>(data.<span class=\"property\">url</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;media_url_resolverdata===========&#x27;</span>, data);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> embedHtml = <span class=\"string\">`&lt;p</span></span><br><span class=\"line\"><span class=\"string\">                    class=&quot;mce-preview-object mce-object-video&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    contenteditable=&quot;false&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-object=&quot;video&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-allowfullscreen=&quot;allowfullscreen&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-frameborder=&quot;no&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-scrolling=&quot;no&quot;</span></span><br><span class=\"line\"><span class=\"string\">                    data-mce-p-src=<span class=\"subst\">$&#123;videoUri&#125;</span> &gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;video src=<span class=\"subst\">$&#123;data.url&#125;</span> width=&quot;100%&quot; height=&quot;auto&quot; controls=&quot;controls&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">                      &lt;source src=&quot;<span class=\"subst\">$&#123;data.url&#125;</span>&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;/video&gt;</span></span><br><span class=\"line\"><span class=\"string\">                    &lt;br data-mce-bogus=&quot;1&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;/p&gt;`</span>;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">html</span>: embedHtml &#125;);</span><br><span class=\"line\">    <span class=\"comment\">//  controlslist=&quot;nodownload&quot;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">html</span>: <span class=\"string\">&#x27;&#x27;</span> &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自定义文件上传\"><a href=\"#自定义文件上传\" class=\"headerlink\" title=\"自定义文件上传\"></a>自定义文件上传</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tinymce.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;#tinydemo4&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">language</span>: <span class=\"string\">&#x27;zh_CN&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"string\">&#x27;link&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">toolbar</span>: <span class=\"string\">&#x27;link&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">file_picker_callback</span>: <span class=\"keyword\">function</span> (<span class=\"params\">callback, value, meta</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//文件分类</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> filetype =</span><br><span class=\"line\">      <span class=\"string\">&#x27;.pdf, .txt, .zip, .rar, .7z, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .mp3, .mp4&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//后端接收上传文件的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> upurl = <span class=\"string\">&#x27;/demo/upfile.php&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//为不同插件指定文件类型及后端地址</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (meta.<span class=\"property\">filetype</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;image&#x27;</span>:</span><br><span class=\"line\">        filetype = <span class=\"string\">&#x27;.jpg, .jpeg, .png, .gif&#x27;</span></span><br><span class=\"line\">        upurl = <span class=\"string\">&#x27;upimg.php&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;media&#x27;</span>:</span><br><span class=\"line\">        filetype = <span class=\"string\">&#x27;.mp3, .mp4&#x27;</span></span><br><span class=\"line\">        upurl = <span class=\"string\">&#x27;upfile.php&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&#x27;file&#x27;</span>:</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//模拟出一个input用于添加本地文件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;input&#x27;</span>)</span><br><span class=\"line\">    input.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">&#x27;type&#x27;</span>, <span class=\"string\">&#x27;file&#x27;</span>)</span><br><span class=\"line\">    input.<span class=\"title function_\">setAttribute</span>(<span class=\"string\">&#x27;accept&#x27;</span>, filetype)</span><br><span class=\"line\">    input.<span class=\"title function_\">click</span>()</span><br><span class=\"line\">    input.<span class=\"property\">onchange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> file = <span class=\"variable language_\">this</span>.<span class=\"property\">files</span>[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">var</span> xhr, formData</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file.<span class=\"property\">name</span>)</span><br><span class=\"line\">      xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\">      xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">      xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;POST&#x27;</span>, upurl)</span><br><span class=\"line\">      xhr.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> json</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xhr.<span class=\"property\">status</span> != <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">failure</span>(<span class=\"string\">&#x27;HTTP Error: &#x27;</span> + xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!json || <span class=\"keyword\">typeof</span> json.<span class=\"property\">location</span> != <span class=\"string\">&#x27;string&#x27;</span>) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">failure</span>(<span class=\"string\">&#x27;Invalid JSON: &#x27;</span> + xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"title function_\">callback</span>(json.<span class=\"property\">location</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      formData = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>()</span><br><span class=\"line\">      formData.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;file&#x27;</span>, file, file.<span class=\"property\">name</span>)</span><br><span class=\"line\">      xhr.<span class=\"title function_\">send</span>(formData)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//下方被注释掉的是官方的一个例子</span></span><br><span class=\"line\">      <span class=\"comment\">//放到下面给大家参考</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*var reader = new FileReader();</span></span><br><span class=\"line\"><span class=\"comment\">            reader.onload = function () &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                // Note: Now we need to register the blob in TinyMCEs image blob</span></span><br><span class=\"line\"><span class=\"comment\">                // registry. In the next release this part hopefully won&#x27;t be</span></span><br><span class=\"line\"><span class=\"comment\">                // necessary, as we are looking to handle it internally.</span></span><br><span class=\"line\"><span class=\"comment\">                var id = &#x27;blobid&#x27; + (new Date()).getTime();</span></span><br><span class=\"line\"><span class=\"comment\">                var blobCache =  tinymce.activeEditor.editorUpload.blobCache;</span></span><br><span class=\"line\"><span class=\"comment\">                var base64 = reader.result.split(&#x27;,&#x27;)[1];</span></span><br><span class=\"line\"><span class=\"comment\">                var blobInfo = blobCache.create(id, file, base64);</span></span><br><span class=\"line\"><span class=\"comment\">                blobCache.add(blobInfo);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                // call the callback and populate the Title field with the file name</span></span><br><span class=\"line\"><span class=\"comment\">                callback(blobInfo.blobUri(), &#123; title: file.name &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">            reader.readAsDataURL(file);*/</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"http://tinymce.ax-z.cn/general/upload-images.php\">tinymce 中文文档</a></li>\n<li><a href=\"https://www.tiny.cloud/docs/tinymce/latest/upload-images/\">tinymce 官方文档</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv22042918/\">视频处理</a></li>\n</ul>\n"},{"title":"选择排序","date":"2023-08-31T07:43:15.444Z","_content":"\n### 逻辑\n\n- 1、在序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的起始位置。\n- 2、再从剩下的原序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的末尾。\n- 3、重复步骤 2 的操作。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction selectionMaxSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    let MaxIndex = i\n    for (let j = i + 1, max = len; j < max; j++) {\n      if (arr[MaxIndex] < arr[j]) {\n        MaxIndex = j\n      }\n    }\n    let temp = arr[i]\n    arr[i] = arr[MaxIndex]\n    arr[MaxIndex] = temp\n  }\n  return arr\n}\nfunction selectionMinSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    let MinIndex = i\n    for (let j = i + 1, max = len; j < max; j++) {\n      if (arr[MinIndex] > arr[j]) {\n        MinIndex = j\n      }\n    }\n    let temp = arr[i]\n    arr[i] = arr[MinIndex]\n    arr[MinIndex] = temp\n  }\n  return arr\n}\nconsole.log(selectionMaxSort(arr)) // [34, 19, 16, 13, 11, 9, 7, 6, 3, 2, 1, 0]\nconsole.log(selectionMinSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","source":"_posts/leetcode/Sort/selectionSort/selectionSort.md","raw":"---\ntitle: 选择排序\ndate:\ntags: [leetcode, 选择排序]\ncategories: [前端, leetcode, 选择排序]\n---\n\n### 逻辑\n\n- 1、在序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的起始位置。\n- 2、再从剩下的原序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的末尾。\n- 3、重复步骤 2 的操作。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction selectionMaxSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    let MaxIndex = i\n    for (let j = i + 1, max = len; j < max; j++) {\n      if (arr[MaxIndex] < arr[j]) {\n        MaxIndex = j\n      }\n    }\n    let temp = arr[i]\n    arr[i] = arr[MaxIndex]\n    arr[MaxIndex] = temp\n  }\n  return arr\n}\nfunction selectionMinSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    let MinIndex = i\n    for (let j = i + 1, max = len; j < max; j++) {\n      if (arr[MinIndex] > arr[j]) {\n        MinIndex = j\n      }\n    }\n    let temp = arr[i]\n    arr[i] = arr[MinIndex]\n    arr[MinIndex] = temp\n  }\n  return arr\n}\nconsole.log(selectionMaxSort(arr)) // [34, 19, 16, 13, 11, 9, 7, 6, 3, 2, 1, 0]\nconsole.log(selectionMinSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","slug":"leetcode/Sort/selectionSort/selectionSort","published":1,"updated":"2023-08-31T07:43:49.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx1003zm32vcqv0ejvh","content":"<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、在序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的起始位置。</li>\n<li>2、再从剩下的原序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的末尾。</li>\n<li>3、重复步骤 2 的操作。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">selectionMaxSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title class_\">MaxIndex</span> = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>, max = len; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[<span class=\"title class_\">MaxIndex</span>] &lt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">MaxIndex</span> = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    arr[i] = arr[<span class=\"title class_\">MaxIndex</span>]</span><br><span class=\"line\">    arr[<span class=\"title class_\">MaxIndex</span>] = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">selectionMinSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title class_\">MinIndex</span> = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>, max = len; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[<span class=\"title class_\">MinIndex</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">MinIndex</span> = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    arr[i] = arr[<span class=\"title class_\">MinIndex</span>]</span><br><span class=\"line\">    arr[<span class=\"title class_\">MinIndex</span>] = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">selectionMaxSort</span>(arr)) <span class=\"comment\">// [34, 19, 16, 13, 11, 9, 7, 6, 3, 2, 1, 0]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">selectionMinSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、在序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的起始位置。</li>\n<li>2、再从剩下的原序列 arr 中找到最大（Max）或者最小（Min）的值，并将该值存在排序序列的末尾。</li>\n<li>3、重复步骤 2 的操作。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">selectionMaxSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title class_\">MaxIndex</span> = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>, max = len; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[<span class=\"title class_\">MaxIndex</span>] &lt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">MaxIndex</span> = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    arr[i] = arr[<span class=\"title class_\">MaxIndex</span>]</span><br><span class=\"line\">    arr[<span class=\"title class_\">MaxIndex</span>] = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">selectionMinSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"title class_\">MinIndex</span> = i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>, max = len; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[<span class=\"title class_\">MinIndex</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">MinIndex</span> = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    arr[i] = arr[<span class=\"title class_\">MinIndex</span>]</span><br><span class=\"line\">    arr[<span class=\"title class_\">MinIndex</span>] = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">selectionMaxSort</span>(arr)) <span class=\"comment\">// [34, 19, 16, 13, 11, 9, 7, 6, 3, 2, 1, 0]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">selectionMinSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"冒泡排序","date":"2023-08-28T04:02:01.530Z","_content":"\n# 冒泡排序\n\n### 逻辑\n\n- 1、比较两个相邻的元素 a、b，如果 a>b，则把 a、b 调换位置；反之，不调换位置。\n- 2、从头到尾比较每一对相邻的元素，并且重复第一步的操作。操作完这步骤后，最后一位元素就是最大的元素。\n- 3、针对所有元素重复以上的步骤（最后一位元素除外）。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction bubbleSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    for (let j = 0, max = len - 1; j < max; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let arrMax = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = arrMax\n      }\n    }\n  }\n  return arr\n}\nconsole.log(bubbleSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","source":"_posts/leetcode/Sort/bubbleSort/bubbleSort.md","raw":"---\ntitle: 冒泡排序\ndate:\ntags: [leetcode, 冒泡排序]\ncategories: [前端, leetcode, 冒泡排序]\n---\n\n# 冒泡排序\n\n### 逻辑\n\n- 1、比较两个相邻的元素 a、b，如果 a>b，则把 a、b 调换位置；反之，不调换位置。\n- 2、从头到尾比较每一对相邻的元素，并且重复第一步的操作。操作完这步骤后，最后一位元素就是最大的元素。\n- 3、针对所有元素重复以上的步骤（最后一位元素除外）。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction bubbleSort(arr) {\n  let len = arr.length\n  for (let i = 0, max = len - 1; i < max; i++) {\n    for (let j = 0, max = len - 1; j < max; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let arrMax = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = arrMax\n      }\n    }\n  }\n  return arr\n}\nconsole.log(bubbleSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","slug":"leetcode/Sort/bubbleSort/bubbleSort","published":1,"updated":"2023-08-28T04:03:40.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx20042m32v2x8h3ote","content":"<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、比较两个相邻的元素 a、b，如果 a&gt;b，则把 a、b 调换位置；反之，不调换位置。</li>\n<li>2、从头到尾比较每一对相邻的元素，并且重复第一步的操作。操作完这步骤后，最后一位元素就是最大的元素。</li>\n<li>3、针对所有元素重复以上的步骤（最后一位元素除外）。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bubbleSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> arrMax = arr[j]</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>]</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = arrMax</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">bubbleSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h1><h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、比较两个相邻的元素 a、b，如果 a&gt;b，则把 a、b 调换位置；反之，不调换位置。</li>\n<li>2、从头到尾比较每一对相邻的元素，并且重复第一步的操作。操作完这步骤后，最后一位元素就是最大的元素。</li>\n<li>3、针对所有元素重复以上的步骤（最后一位元素除外）。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bubbleSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, max = len - <span class=\"number\">1</span>; j &lt; max; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> arrMax = arr[j]</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>]</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = arrMax</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">bubbleSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"插入排序","date":"2023-08-29T01:00:46.268Z","_content":"\n### 逻辑\n\n- 1、序列的第一个元素看成一个有序序列，第二个元素到序列末尾看成未排序序列；\n- 2、取未排序序列的第一个元素与有序序列进行比较，并插到有序序列合适的位置；\n- 3、重复步骤 2，直至未排序序列末尾为止。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction insertionSort(arr) {\n  let len = arr.length\n  for (let i = 1, max = len; i < max; i++) {\n    let currentI = arr[i]\n    let j = i - 1\n    // 把当前的元素与已排序列进行比较（从最后一位开始），如果已排序列元素大于当前元素，就把已排序列的元素向后移动一位，依次类推。\n    while (j >= 0 && arr[j] > currentI) {\n      arr[j + 1] = arr[j]\n      j--\n    }\n    arr[j + 1] = currentI\n  }\n  return arr\n}\nconsole.log(insertionSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","source":"_posts/leetcode/Sort/insertionSort/insertionSort.md","raw":"---\ntitle: 插入排序\ndate:\ntags: [leetcode, 插入排序]\ncategories: [前端, leetcode, 插入排序]\n---\n\n### 逻辑\n\n- 1、序列的第一个元素看成一个有序序列，第二个元素到序列末尾看成未排序序列；\n- 2、取未排序序列的第一个元素与有序序列进行比较，并插到有序序列合适的位置；\n- 3、重复步骤 2，直至未排序序列末尾为止。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 2, 6, 34, 7, 9, 11, 16, 13, 19, 0, 3]\nfunction insertionSort(arr) {\n  let len = arr.length\n  for (let i = 1, max = len; i < max; i++) {\n    let currentI = arr[i]\n    let j = i - 1\n    // 把当前的元素与已排序列进行比较（从最后一位开始），如果已排序列元素大于当前元素，就把已排序列的元素向后移动一位，依次类推。\n    while (j >= 0 && arr[j] > currentI) {\n      arr[j + 1] = arr[j]\n      j--\n    }\n    arr[j + 1] = currentI\n  }\n  return arr\n}\nconsole.log(insertionSort(arr)) // [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]\n```\n","slug":"leetcode/Sort/insertionSort/insertionSort","published":1,"updated":"2023-08-29T01:01:17.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx20047m32v8sor1sha","content":"<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、序列的第一个元素看成一个有序序列，第二个元素到序列末尾看成未排序序列；</li>\n<li>2、取未排序序列的第一个元素与有序序列进行比较，并插到有序序列合适的位置；</li>\n<li>3、重复步骤 2，直至未排序序列末尾为止。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertionSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, max = len; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentI = arr[i]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 把当前的元素与已排序列进行比较（从最后一位开始），如果已排序列元素大于当前元素，就把已排序列的元素向后移动一位，依次类推。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; currentI) &#123;</span><br><span class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j + <span class=\"number\">1</span>] = currentI</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">insertionSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、序列的第一个元素看成一个有序序列，第二个元素到序列末尾看成未排序序列；</li>\n<li>2、取未排序序列的第一个元素与有序序列进行比较，并插到有序序列合适的位置；</li>\n<li>3、重复步骤 2，直至未排序序列末尾为止。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">34</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">13</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">insertionSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, max = len; i &lt; max; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentI = arr[i]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 把当前的元素与已排序列进行比较（从最后一位开始），如果已排序列元素大于当前元素，就把已排序列的元素向后移动一位，依次类推。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; currentI) &#123;</span><br><span class=\"line\">      arr[j + <span class=\"number\">1</span>] = arr[j]</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j + <span class=\"number\">1</span>] = currentI</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">insertionSort</span>(arr)) <span class=\"comment\">// [0, 1, 2, 3, 6, 7, 9, 11, 13, 16, 19, 34]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"希尔排序","date":"2023-08-30T07:21:19.731Z","_content":"\n### 基本思想\n\n> 将整个待排序序列进行的记录分割成若干个子序列，进行直接插入排序；待整个序列基本有序时，再对整个序列进行直接插入排序。\n\n### 逻辑\n\n- 1、选择一个增量序列 t1,t2....tk,其中 ti>tj，tk=1；\n- 2、按增量序列个数 k,对序列进行 K 趟排序；\n- 3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 9, 7, 10, 5, 8, 11, 14, 66, 0]\nfunction shellSort(arr) {\n  let len = arr.length\n  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < len; i++) {\n      let j = i\n      let current = arr[i]\n      while (j - gap >= 0 && current < arr[j - gap]) {\n        arr[j] = arr[j - gap]\n        j = j - gap\n      }\n      arr[j] = current\n    }\n  }\n  return arr\n}\nfunction shellSort2(arr) {\n  let len = arr.length,\n    temp,\n    gap = 1\n  while (gap < len / 3) {\n    gap = gap * 3 + 1\n  }\n  for (gap; gap > 0; gap = Math.floor(gap / 3)) {\n    for (let i = gap; i < len; i++) {\n      temp = arr[i]\n      let j = i - gap\n      for (j; j >= 0 && arr[j] > temp; j -= gap) {\n        arr[j + gap] = arr[j]\n      }\n      arr[j + gap] = temp\n    }\n  }\n  return arr\n}\nconsole.log(shellSort(arr)) // [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]\nconsole.log(shellSort2(arr)) // [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]\n```\n","source":"_posts/leetcode/Sort/shellSort/shellSort.md","raw":"---\ntitle: 希尔排序\ndate:\ntags: [leetcode, 希尔排序]\ncategories: [前端, leetcode, 希尔排序]\n---\n\n### 基本思想\n\n> 将整个待排序序列进行的记录分割成若干个子序列，进行直接插入排序；待整个序列基本有序时，再对整个序列进行直接插入排序。\n\n### 逻辑\n\n- 1、选择一个增量序列 t1,t2....tk,其中 ti>tj，tk=1；\n- 2、按增量序列个数 k,对序列进行 K 趟排序；\n- 3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n### JavaScript 代码实现\n\n```javascript\nconst arr = [1, 9, 7, 10, 5, 8, 11, 14, 66, 0]\nfunction shellSort(arr) {\n  let len = arr.length\n  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < len; i++) {\n      let j = i\n      let current = arr[i]\n      while (j - gap >= 0 && current < arr[j - gap]) {\n        arr[j] = arr[j - gap]\n        j = j - gap\n      }\n      arr[j] = current\n    }\n  }\n  return arr\n}\nfunction shellSort2(arr) {\n  let len = arr.length,\n    temp,\n    gap = 1\n  while (gap < len / 3) {\n    gap = gap * 3 + 1\n  }\n  for (gap; gap > 0; gap = Math.floor(gap / 3)) {\n    for (let i = gap; i < len; i++) {\n      temp = arr[i]\n      let j = i - gap\n      for (j; j >= 0 && arr[j] > temp; j -= gap) {\n        arr[j + gap] = arr[j]\n      }\n      arr[j + gap] = temp\n    }\n  }\n  return arr\n}\nconsole.log(shellSort(arr)) // [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]\nconsole.log(shellSort2(arr)) // [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]\n```\n","slug":"leetcode/Sort/shellSort/shellSort","published":1,"updated":"2023-08-30T07:21:57.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwx30048m32v6a2o4sns","content":"<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><blockquote>\n<p>将整个待排序序列进行的记录分割成若干个子序列，进行直接插入排序；待整个序列基本有序时，再对整个序列进行直接插入排序。</p>\n</blockquote>\n<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、选择一个增量序列 t1,t2….tk,其中 ti&gt;tj，tk&#x3D;1；</li>\n<li>2、按增量序列个数 k,对序列进行 K 趟排序；</li>\n<li>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">14</span>, <span class=\"number\">66</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">shellSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(len / <span class=\"number\">2</span>); gap &gt; <span class=\"number\">0</span>; gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(gap / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = i</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (j - gap &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class=\"line\">        arr[j] = arr[j - gap]</span><br><span class=\"line\">        j = j - gap</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      arr[j] = current</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">shellSort2</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span>,</span><br><span class=\"line\">    temp,</span><br><span class=\"line\">    gap = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (gap &lt; len / <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    gap = gap * <span class=\"number\">3</span> + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (gap; gap &gt; <span class=\"number\">0</span>; gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(gap / <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">      temp = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = i - gap</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (j; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class=\"line\">        arr[j + gap] = arr[j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      arr[j + gap] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">shellSort</span>(arr)) <span class=\"comment\">// [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">shellSort2</span>(arr)) <span class=\"comment\">// [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><blockquote>\n<p>将整个待排序序列进行的记录分割成若干个子序列，进行直接插入排序；待整个序列基本有序时，再对整个序列进行直接插入排序。</p>\n</blockquote>\n<h3 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h3><ul>\n<li>1、选择一个增量序列 t1,t2….tk,其中 ti&gt;tj，tk&#x3D;1；</li>\n<li>2、按增量序列个数 k,对序列进行 K 趟排序；</li>\n<li>3、每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<h3 id=\"JavaScript-代码实现\"><a href=\"#JavaScript-代码实现\" class=\"headerlink\" title=\"JavaScript 代码实现\"></a>JavaScript 代码实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">14</span>, <span class=\"number\">66</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">shellSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(len / <span class=\"number\">2</span>); gap &gt; <span class=\"number\">0</span>; gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(gap / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = i</span><br><span class=\"line\">      <span class=\"keyword\">let</span> current = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (j - gap &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class=\"line\">        arr[j] = arr[j - gap]</span><br><span class=\"line\">        j = j - gap</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      arr[j] = current</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">shellSort2</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.<span class=\"property\">length</span>,</span><br><span class=\"line\">    temp,</span><br><span class=\"line\">    gap = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (gap &lt; len / <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    gap = gap * <span class=\"number\">3</span> + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (gap; gap &gt; <span class=\"number\">0</span>; gap = <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(gap / <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">      temp = arr[i]</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = i - gap</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (j; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class=\"line\">        arr[j + gap] = arr[j]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      arr[j + gap] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">shellSort</span>(arr)) <span class=\"comment\">// [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">shellSort2</span>(arr)) <span class=\"comment\">// [0, 1, 5, 7, 8, 9, 10, 11, 14, 66]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"【浏览器】之缓存","date":"2023-09-05T01:28:26.690Z","_content":"\n# 概览\n\n> 浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。\n\n**缓存，是优化网络请求。（js,css,img 可以被缓存）**\n\n它分为**强缓存**和**协商缓存**：\n\n- 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；\n\n- 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；\n\n- 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。\n\n- 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n\n#### 常见的 HTTP 缓存首部字段有：\n\n- Expires：响应头，代表该资源的过期时间\n\n- Cache-Control：请求/响应头，缓存控制字段，精确控制缓存策略\n\n- If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器\n\n- Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器\n\n- Etag：响应头，资源标识，由服务器告诉浏览器\n\n- If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器\n\n其中， 强缓存 ：\n\n- Expires（HTTP/1.0）\n- Cache-Control（HTTP/1.1）\n\n协商缓存：\n\n- Last-Modified 和 If-Modified-Since（HTTP/1.0）\n- ETag 和 If-None-Match（HTTP/1.1）\n\n# 强缓存\n\n关键字： 强制缓存 disk cache max-age\n\n> 当浏览器初次想服务器请求资源，有服务端判断资源是否需要加缓存。服务器返回资源，并且返回 Cache-Control（response Header 中）。  \n> 当浏览器再次请求的话，就会在浏览器的本地资源中去找缓存。\n\n> Expires（**HTTP/1.0**）  \n> Cache-Control（**HTTP/1.1**）  \n> 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。  \n> 通常有 2 种方式来设置是否启用强缓存：  \n> 1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；  \n> 2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n**注意：当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。**\n\n**注意：可以通过 Expires / Cache-Control 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。**\n\n### 原理\n\n当浏览器对某个资源的请求命中了强缓存时，返回的**http 状态为 200**，在 chrome 的开发者工具的 network 里面 size 会显示为**from disk cache**，比如京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/f79ca7cf-42ef-407b-b9b7-d3ce890c8210)\n\n### Expires\n\n> 如果在 Cache-Control 响应头设置了 \"max-age\" 或者 \"s-max-age\" 指令，那么 Expires 头会被忽略。\n\n#### 语法:\n\n```\nExpires: <http-date>\n```\n\n#### 示例：\n\n```\nExpires: Wed, 21 Oct 2023 07:00:00 GMT\n```\n\n#### 原理：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/517c35d2-aadd-496b-b326-a155c4a6646a)\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。\n\n### Cache-Control\n\n> Expires 是较老的强缓存管理 header，由于它是服务器返回的一个**绝对时间**，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。  \n> 所以在 http1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000.\n> Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。\n\n#### 指令\n\n请求指令\n\n```\nCache-Control: max-age=<seconds>\nCache-Control: max-stale[=<seconds>]\nCache-Control: min-fresh=<seconds>\nCache-control: no-cache\nCache-control: no-store\nCache-control: no-transform\nCache-control: only-if-cached\n```\n\n响应指令\n\n```\nCache-control: must-revalidate\nCache-control: no-cache // 不强制缓存\nCache-control: no-store //  不缓存，有服务器去处理\nCache-control: no-transform\nCache-control: public\nCache-control: private\nCache-control: proxy-revalidate\nCache-Control: max-age=<seconds>\nCache-control: s-maxage=<seconds>\n```\n\n#### 示例\n\n禁止缓存\n\n> 发送如下响应头可以关闭缓存。此外，可以参考 Expires 和 Pragma 消息头。\n\n```\nCache-Control: no-store\n```\n\n缓存静态资源\n\n> 对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。另请参阅 Expires 标题。\n\n```\nCache-Control:public, max-age=31536000\n```\n\n需要重新验证\n\n> 指定 no-cache 或 max-age=0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n\n```\nCache-Control: no-cache\n```\n\n```\nCache-Control: max-age=0, must-revalidate\n```\n\n**注意: 如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。**\n\n```\nCache-Control: max-age=0\n```\n\n#### 原理：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/8b3323b4-3b56-431e-aa61-ad74f7c3b1e5)\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。\n\nCache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。\n\n这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/50340a39-eedd-428a-90d9-92a2307906e4)\n\n### 强缓存的管理\n\n启用强缓存：\n\n1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；\n\n2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n比如在 javaweb 里面，我们可以使用类似下面的代码设置强缓存：\n\n```java\njava.util.Date date = new java.util.Date();\nresponse.setDateHeader(\"Expires\",date.getTime()+20000); //Expires:过时期限值\nresponse.setHeader(\"Cache-Control\", \"public\"); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；\nresponse.setHeader(\"Pragma\", \"Pragma\"); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存\n```\n\n还可以通过类似下面的 java 代码设置不启用强缓存：\n\n```java\nresponse.setHeader( \"Pragma\", \"no-cache\" );\nresponse.setDateHeader(\"Expires\", 0);\nresponse.addHeader( \"Cache-Control\", \"no-cache\" );//浏览器和缓存服务器都不应该缓存页面信息\n```\n\n由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css 和 js 等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：\n\n1）直接 ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；\n\n2）使用浏览器的隐私模式开发；\n\n3）如果用的是 chrome，可以 f12 在 network 那里把缓存给禁掉（这是个非常有效的方法）：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/69cb5982-660e-405e-8ec4-d844b6160d8e)\n\n4）在开发阶段，给资源加上一个动态的参数，如 css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如 jsp 里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；\n\n5）如果资源引用的页面，被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键单击重新加载该页面，以 chrome 为例：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/b1edcf61-f97c-4af4-a92b-833adf52055e)\n\n6）如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数；\n\n7）还有一种情况就是动态设置 iframe 的 src 时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的 src 后面添加随机数也能解决问题；\n\n8）如果你用的是 grunt 和 gulp 这种前端工具开发，通过它们的插件比如 grunt-contrib-connect 来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的 respone header 中，cache-control 始终被设置为不缓存：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/123d1fb2-0b04-4c65-a44e-e1025a9428d5)\n\n# 协商缓存\n\n- 服务端缓存策略。\n- 浏览器初次请求，服务器会返回资源和资源标识。\n- 当浏览器再次请求，带着资源标识。服务器会判断资源客户端资源，是否和服务端资源一致。\n- 一致则返回 304 not Modified.否则返回 200 和最新的资源。\n\n**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。**\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为**304**并且会显示一个**Not Modified**的字符串，比如你打开京东的首页，按 f12 打开开发者工具，再按 f5 刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/ba8614f2-65bd-46bc-8953-7abd9ba01508)\n\n### 【Last-Modified，If-Modified-Since]\n\n> Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比 ETag 要低，所以这是一个备用机制。包含有 If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。  \n> If-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。不同于 If-Unmodified-Since, If-Modified-Since 只可以用在 GET 或 HEAD 请求中。\n\n#### 原理：\n\n1）**浏览器初次请求，服务器返回资源+Last-Modified**：浏览器初次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/97d2dbd9-3d4d-47d5-a7f2-5dd71a44750b)\n\n2）**浏览器再次请求+If-Modified-Since(上次 Last-Modified 的值)**：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/6e22c453-8b72-4ef2-9b9b-72899d370adb)\n\n3）**服务器返回 304（一致）或者资源+新的 Last-Modified(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/88eebce5-2bbb-4e60-a325-aa4283215588)\n\n4）**浏览器收到 304 的响应后，就会从缓存中加载资源。**\n\n5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n\n【Last-Modified，If-Modified-Since】都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是【ETag、If-None-Match】。\n\n### 【ETag、If-None-Match】\n\n#### 原理：\n\n1）**浏览器初次请求，服务器返回资源+Etag**浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/22fd09c9-12dc-44a0-9046-47186c0a4fa4)\n\n2）**浏览器再次请求+If-None-Match**浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/d6954c1c-aa40-4619-951a-728762e2b7da)\n\n3）**服务器返回 304（一致）或者资源+新的 Etag(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/18a3f0c3-fd12-4569-9feb-032d4048d822)\n\n4）浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n#### 应用\n\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache:\n\n![image](https://github.com/yihan12/Blog/assets/44987698/565afaac-8825-4409-9c1c-00e68ca81cb4)\n\n如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。\n\n【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）；\n\n京东页面的资源请求，返回的 repsones header 就只有 Last-Modified，没有 ETag：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/50f7ebb8-5bcf-44e8-8ae9-00d3b2d6a13c)\n\n协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n\n### 浏览器的刷新影响\n\n- 1）当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n\n- 2）当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n- 3）正常操作：地址栏输入 url，跳转链接，前进后退等。\n\n### Last-Modified 和 Etag\n\n- 会优先使用 Etag\n- Last-Modified 只能精确到秒级。\n- 如果资源被重复生成，而内容不变，则 Etag（根据内容） 更精确。\n","source":"_posts/浏览器/【浏览器】之缓存.md","raw":"---\ntitle: 【浏览器】之缓存\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 缓存]\n---\n\n# 概览\n\n> 浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。\n\n**缓存，是优化网络请求。（js,css,img 可以被缓存）**\n\n它分为**强缓存**和**协商缓存**：\n\n- 1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；\n\n- 2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；\n\n- 3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。\n\n- 4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。\n\n#### 常见的 HTTP 缓存首部字段有：\n\n- Expires：响应头，代表该资源的过期时间\n\n- Cache-Control：请求/响应头，缓存控制字段，精确控制缓存策略\n\n- If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器\n\n- Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器\n\n- Etag：响应头，资源标识，由服务器告诉浏览器\n\n- If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器\n\n其中， 强缓存 ：\n\n- Expires（HTTP/1.0）\n- Cache-Control（HTTP/1.1）\n\n协商缓存：\n\n- Last-Modified 和 If-Modified-Since（HTTP/1.0）\n- ETag 和 If-None-Match（HTTP/1.1）\n\n# 强缓存\n\n关键字： 强制缓存 disk cache max-age\n\n> 当浏览器初次想服务器请求资源，有服务端判断资源是否需要加缓存。服务器返回资源，并且返回 Cache-Control（response Header 中）。  \n> 当浏览器再次请求的话，就会在浏览器的本地资源中去找缓存。\n\n> Expires（**HTTP/1.0**）  \n> Cache-Control（**HTTP/1.1**）  \n> 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。  \n> 通常有 2 种方式来设置是否启用强缓存：  \n> 1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；  \n> 2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n**注意：当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。**\n\n**注意：可以通过 Expires / Cache-Control 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。**\n\n### 原理\n\n当浏览器对某个资源的请求命中了强缓存时，返回的**http 状态为 200**，在 chrome 的开发者工具的 network 里面 size 会显示为**from disk cache**，比如京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/f79ca7cf-42ef-407b-b9b7-d3ce890c8210)\n\n### Expires\n\n> 如果在 Cache-Control 响应头设置了 \"max-age\" 或者 \"s-max-age\" 指令，那么 Expires 头会被忽略。\n\n#### 语法:\n\n```\nExpires: <http-date>\n```\n\n#### 示例：\n\n```\nExpires: Wed, 21 Oct 2023 07:00:00 GMT\n```\n\n#### 原理：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/517c35d2-aadd-496b-b326-a155c4a6646a)\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。\n\n### Cache-Control\n\n> Expires 是较老的强缓存管理 header，由于它是服务器返回的一个**绝对时间**，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。  \n> 所以在 http1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000.\n> Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。\n\n#### 指令\n\n请求指令\n\n```\nCache-Control: max-age=<seconds>\nCache-Control: max-stale[=<seconds>]\nCache-Control: min-fresh=<seconds>\nCache-control: no-cache\nCache-control: no-store\nCache-control: no-transform\nCache-control: only-if-cached\n```\n\n响应指令\n\n```\nCache-control: must-revalidate\nCache-control: no-cache // 不强制缓存\nCache-control: no-store //  不缓存，有服务器去处理\nCache-control: no-transform\nCache-control: public\nCache-control: private\nCache-control: proxy-revalidate\nCache-Control: max-age=<seconds>\nCache-control: s-maxage=<seconds>\n```\n\n#### 示例\n\n禁止缓存\n\n> 发送如下响应头可以关闭缓存。此外，可以参考 Expires 和 Pragma 消息头。\n\n```\nCache-Control: no-store\n```\n\n缓存静态资源\n\n> 对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。另请参阅 Expires 标题。\n\n```\nCache-Control:public, max-age=31536000\n```\n\n需要重新验证\n\n> 指定 no-cache 或 max-age=0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。\n\n```\nCache-Control: no-cache\n```\n\n```\nCache-Control: max-age=0, must-revalidate\n```\n\n**注意: 如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。**\n\n```\nCache-Control: max-age=0\n```\n\n#### 原理：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/8b3323b4-3b56-431e-aa61-ad74f7c3b1e5)\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。\n\nCache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。\n\n这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/50340a39-eedd-428a-90d9-92a2307906e4)\n\n### 强缓存的管理\n\n启用强缓存：\n\n1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；\n\n2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。\n\n比如在 javaweb 里面，我们可以使用类似下面的代码设置强缓存：\n\n```java\njava.util.Date date = new java.util.Date();\nresponse.setDateHeader(\"Expires\",date.getTime()+20000); //Expires:过时期限值\nresponse.setHeader(\"Cache-Control\", \"public\"); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；\nresponse.setHeader(\"Pragma\", \"Pragma\"); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存\n```\n\n还可以通过类似下面的 java 代码设置不启用强缓存：\n\n```java\nresponse.setHeader( \"Pragma\", \"no-cache\" );\nresponse.setDateHeader(\"Expires\", 0);\nresponse.addHeader( \"Cache-Control\", \"no-cache\" );//浏览器和缓存服务器都不应该缓存页面信息\n```\n\n由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css 和 js 等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：\n\n1）直接 ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；\n\n2）使用浏览器的隐私模式开发；\n\n3）如果用的是 chrome，可以 f12 在 network 那里把缓存给禁掉（这是个非常有效的方法）：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/69cb5982-660e-405e-8ec4-d844b6160d8e)\n\n4）在开发阶段，给资源加上一个动态的参数，如 css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如 jsp 里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；\n\n5）如果资源引用的页面，被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键单击重新加载该页面，以 chrome 为例：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/b1edcf61-f97c-4af4-a92b-833adf52055e)\n\n6）如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数；\n\n7）还有一种情况就是动态设置 iframe 的 src 时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的 src 后面添加随机数也能解决问题；\n\n8）如果你用的是 grunt 和 gulp 这种前端工具开发，通过它们的插件比如 grunt-contrib-connect 来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的 respone header 中，cache-control 始终被设置为不缓存：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/123d1fb2-0b04-4c65-a44e-e1025a9428d5)\n\n# 协商缓存\n\n- 服务端缓存策略。\n- 浏览器初次请求，服务器会返回资源和资源标识。\n- 当浏览器再次请求，带着资源标识。服务器会判断资源客户端资源，是否和服务端资源一致。\n- 一致则返回 304 not Modified.否则返回 200 和最新的资源。\n\n**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。**\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为**304**并且会显示一个**Not Modified**的字符串，比如你打开京东的首页，按 f12 打开开发者工具，再按 f5 刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/ba8614f2-65bd-46bc-8953-7abd9ba01508)\n\n### 【Last-Modified，If-Modified-Since]\n\n> Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比 ETag 要低，所以这是一个备用机制。包含有 If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。  \n> If-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。不同于 If-Unmodified-Since, If-Modified-Since 只可以用在 GET 或 HEAD 请求中。\n\n#### 原理：\n\n1）**浏览器初次请求，服务器返回资源+Last-Modified**：浏览器初次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/97d2dbd9-3d4d-47d5-a7f2-5dd71a44750b)\n\n2）**浏览器再次请求+If-Modified-Since(上次 Last-Modified 的值)**：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/6e22c453-8b72-4ef2-9b9b-72899d370adb)\n\n3）**服务器返回 304（一致）或者资源+新的 Last-Modified(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/88eebce5-2bbb-4e60-a325-aa4283215588)\n\n4）**浏览器收到 304 的响应后，就会从缓存中加载资源。**\n\n5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。\n\n【Last-Modified，If-Modified-Since】都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是【ETag、If-None-Match】。\n\n### 【ETag、If-None-Match】\n\n#### 原理：\n\n1）**浏览器初次请求，服务器返回资源+Etag**浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/22fd09c9-12dc-44a0-9046-47186c0a4fa4)\n\n2）**浏览器再次请求+If-None-Match**浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/d6954c1c-aa40-4619-951a-728762e2b7da)\n\n3）**服务器返回 304（一致）或者资源+新的 Etag(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/18a3f0c3-fd12-4569-9feb-032d4048d822)\n\n4）浏览器收到 304 的响应后，就会从缓存中加载资源。\n\n#### 应用\n\n协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache:\n\n![image](https://github.com/yihan12/Blog/assets/44987698/565afaac-8825-4409-9c1c-00e68ca81cb4)\n\n如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。\n\n【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）；\n\n京东页面的资源请求，返回的 repsones header 就只有 Last-Modified，没有 ETag：\n\n![image](https://github.com/yihan12/Blog/assets/44987698/50f7ebb8-5bcf-44e8-8ae9-00d3b2d6a13c)\n\n协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。\n\n### 浏览器的刷新影响\n\n- 1）当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n\n- 2）当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n- 3）正常操作：地址栏输入 url，跳转链接，前进后退等。\n\n### Last-Modified 和 Etag\n\n- 会优先使用 Etag\n- Last-Modified 只能精确到秒级。\n- 如果资源被重复生成，而内容不变，则 Etag（根据内容） 更精确。\n","slug":"浏览器/【浏览器】之缓存","published":1,"updated":"2023-09-05T01:29:08.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwya00eem32vgrxe47tj","content":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。</p>\n</blockquote>\n<p><strong>缓存，是优化网络请求。（js,css,img 可以被缓存）</strong></p>\n<p>它分为<strong>强缓存</strong>和<strong>协商缓存</strong>：</p>\n<ul>\n<li><p>1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；</p>\n</li>\n<li><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>\n</li>\n<li><p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>\n</li>\n<li><p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>\n</li>\n</ul>\n<h4 id=\"常见的-HTTP-缓存首部字段有：\"><a href=\"#常见的-HTTP-缓存首部字段有：\" class=\"headerlink\" title=\"常见的 HTTP 缓存首部字段有：\"></a>常见的 HTTP 缓存首部字段有：</h4><ul>\n<li><p>Expires：响应头，代表该资源的过期时间</p>\n</li>\n<li><p>Cache-Control：请求&#x2F;响应头，缓存控制字段，精确控制缓存策略</p>\n</li>\n<li><p>If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器</p>\n</li>\n<li><p>Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器</p>\n</li>\n<li><p>Etag：响应头，资源标识，由服务器告诉浏览器</p>\n</li>\n<li><p>If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器</p>\n</li>\n</ul>\n<p>其中， 强缓存 ：</p>\n<ul>\n<li>Expires（HTTP&#x2F;1.0）</li>\n<li>Cache-Control（HTTP&#x2F;1.1）</li>\n</ul>\n<p>协商缓存：</p>\n<ul>\n<li>Last-Modified 和 If-Modified-Since（HTTP&#x2F;1.0）</li>\n<li>ETag 和 If-None-Match（HTTP&#x2F;1.1）</li>\n</ul>\n<h1 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h1><p>关键字： 强制缓存 disk cache max-age</p>\n<blockquote>\n<p>当浏览器初次想服务器请求资源，有服务端判断资源是否需要加缓存。服务器返回资源，并且返回 Cache-Control（response Header 中）。<br>当浏览器再次请求的话，就会在浏览器的本地资源中去找缓存。</p>\n</blockquote>\n<blockquote>\n<p>Expires（<strong>HTTP&#x2F;1.0</strong>）<br>Cache-Control（<strong>HTTP&#x2F;1.1</strong>）<br>强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。<br>通常有 2 种方式来设置是否启用强缓存：<br>1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；<br>2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n</blockquote>\n<p><strong>注意：当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。</strong></p>\n<p><strong>注意：可以通过 Expires &#x2F; Cache-Control 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。</strong></p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>当浏览器对某个资源的请求命中了强缓存时，返回的<strong>http 状态为 200</strong>，在 chrome 的开发者工具的 network 里面 size 会显示为<strong>from disk cache</strong>，比如京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/f79ca7cf-42ef-407b-b9b7-d3ce890c8210\" alt=\"image\"></p>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><blockquote>\n<p>如果在 Cache-Control 响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p>\n</blockquote>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法:\"></a>语法:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: &lt;http-date&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed, 21 Oct 2023 07:00:00 GMT</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/517c35d2-aadd-496b-b326-a155c4a6646a\" alt=\"image\"></p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><blockquote>\n<p>Expires 是较老的强缓存管理 header，由于它是服务器返回的一个<strong>绝对时间</strong>，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。<br>所以在 http1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age&#x3D;315360000.<br>Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。</p>\n</blockquote>\n<h4 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h4><p>请求指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class=\"line\">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class=\"line\">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class=\"line\">Cache-control: no-cache</span><br><span class=\"line\">Cache-control: no-store</span><br><span class=\"line\">Cache-control: no-transform</span><br><span class=\"line\">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure>\n\n<p>响应指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-control: must-revalidate</span><br><span class=\"line\">Cache-control: no-cache // 不强制缓存</span><br><span class=\"line\">Cache-control: no-store //  不缓存，有服务器去处理</span><br><span class=\"line\">Cache-control: no-transform</span><br><span class=\"line\">Cache-control: public</span><br><span class=\"line\">Cache-control: private</span><br><span class=\"line\">Cache-control: proxy-revalidate</span><br><span class=\"line\">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class=\"line\">Cache-control: s-maxage=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>禁止缓存</p>\n<blockquote>\n<p>发送如下响应头可以关闭缓存。此外，可以参考 Expires 和 Pragma 消息头。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-store</span><br></pre></td></tr></table></figure>\n\n<p>缓存静态资源</p>\n<blockquote>\n<p>对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。另请参阅 Expires 标题。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:public, max-age=31536000</span><br></pre></td></tr></table></figure>\n\n<p>需要重新验证</p>\n<blockquote>\n<p>指定 no-cache 或 max-age&#x3D;0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0, must-revalidate</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意: 如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原理：-1\"><a href=\"#原理：-1\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/8b3323b4-3b56-431e-aa61-ad74f7c3b1e5\" alt=\"image\"></p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p>\n<p>Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。</p>\n<p>这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/50340a39-eedd-428a-90d9-92a2307906e4\" alt=\"image\"></p>\n<h3 id=\"强缓存的管理\"><a href=\"#强缓存的管理\" class=\"headerlink\" title=\"强缓存的管理\"></a>强缓存的管理</h3><p>启用强缓存：</p>\n<p>1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；</p>\n<p>2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n<p>比如在 javaweb 里面，我们可以使用类似下面的代码设置强缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.<span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.Date();</span><br><span class=\"line\">response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>,date.getTime()+<span class=\"number\">20000</span>); <span class=\"comment\">//Expires:过时期限值</span></span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;public&quot;</span>); <span class=\"comment\">//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span></span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;Pragma&quot;</span>); <span class=\"comment\">//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以通过类似下面的 java 代码设置不启用强缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader( <span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span> );</span><br><span class=\"line\">response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">response.addHeader( <span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span> );<span class=\"comment\">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br></pre></td></tr></table></figure>\n\n<p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css 和 js 等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>\n<p>1）直接 ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>\n<p>2）使用浏览器的隐私模式开发；</p>\n<p>3）如果用的是 chrome，可以 f12 在 network 那里把缓存给禁掉（这是个非常有效的方法）：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/69cb5982-660e-405e-8ec4-d844b6160d8e\" alt=\"image\"></p>\n<p>4）在开发阶段，给资源加上一个动态的参数，如 css&#x2F;index.css?v&#x3D;0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如 jsp 里开发就可以用服务器变量来解决（v&#x3D;${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>\n<p>5）如果资源引用的页面，被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键单击重新加载该页面，以 chrome 为例：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/b1edcf61-f97c-4af4-a92b-833adf52055e\" alt=\"image\"></p>\n<p>6）如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数；</p>\n<p>7）还有一种情况就是动态设置 iframe 的 src 时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的 src 后面添加随机数也能解决问题；</p>\n<p>8）如果你用的是 grunt 和 gulp 这种前端工具开发，通过它们的插件比如 grunt-contrib-connect 来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的 respone header 中，cache-control 始终被设置为不缓存：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/123d1fb2-0b04-4c65-a44e-e1025a9428d5\" alt=\"image\"></p>\n<h1 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h1><ul>\n<li>服务端缓存策略。</li>\n<li>浏览器初次请求，服务器会返回资源和资源标识。</li>\n<li>当浏览器再次请求，带着资源标识。服务器会判断资源客户端资源，是否和服务端资源一致。</li>\n<li>一致则返回 304 not Modified.否则返回 200 和最新的资源。</li>\n</ul>\n<p><strong>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。</strong></p>\n<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为<strong>304</strong>并且会显示一个<strong>Not Modified</strong>的字符串，比如你打开京东的首页，按 f12 打开开发者工具，再按 f5 刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/ba8614f2-65bd-46bc-8953-7abd9ba01508\" alt=\"image\"></p>\n<h3 id=\"【Last-Modified，If-Modified-Since\"><a href=\"#【Last-Modified，If-Modified-Since\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since]\"></a>【Last-Modified，If-Modified-Since]</h3><blockquote>\n<p>Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比 ETag 要低，所以这是一个备用机制。包含有 If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。<br>If-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。不同于 If-Unmodified-Since, If-Modified-Since 只可以用在 GET 或 HEAD 请求中。</p>\n</blockquote>\n<h4 id=\"原理：-2\"><a href=\"#原理：-2\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）<strong>浏览器初次请求，服务器返回资源+Last-Modified</strong>：浏览器初次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/97d2dbd9-3d4d-47d5-a7f2-5dd71a44750b\" alt=\"image\"></p>\n<p>2）**浏览器再次请求+If-Modified-Since(上次 Last-Modified 的值)**：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/6e22c453-8b72-4ef2-9b9b-72899d370adb\" alt=\"image\"></p>\n<p>3）**服务器返回 304（一致）或者资源+新的 Last-Modified(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/88eebce5-2bbb-4e60-a325-aa4283215588\" alt=\"image\"></p>\n<p>4）<strong>浏览器收到 304 的响应后，就会从缓存中加载资源。</strong></p>\n<p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p>\n<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是【ETag、If-None-Match】。</p>\n<h3 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h3><h4 id=\"原理：-3\"><a href=\"#原理：-3\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）<strong>浏览器初次请求，服务器返回资源+Etag</strong>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/22fd09c9-12dc-44a0-9046-47186c0a4fa4\" alt=\"image\"></p>\n<p>2）<strong>浏览器再次请求+If-None-Match</strong>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/d6954c1c-aa40-4619-951a-728762e2b7da\" alt=\"image\"></p>\n<p>3）**服务器返回 304（一致）或者资源+新的 Etag(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/18a3f0c3-fd12-4569-9feb-032d4048d822\" alt=\"image\"></p>\n<p>4）浏览器收到 304 的响应后，就会从缓存中加载资源。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache:</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/565afaac-8825-4409-9c1c-00e68ca81cb4\" alt=\"image\"></p>\n<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>\n<p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）；</p>\n<p>京东页面的资源请求，返回的 repsones header 就只有 Last-Modified，没有 ETag：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/50f7ebb8-5bcf-44e8-8ae9-00d3b2d6a13c\" alt=\"image\"></p>\n<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>\n<h3 id=\"浏览器的刷新影响\"><a href=\"#浏览器的刷新影响\" class=\"headerlink\" title=\"浏览器的刷新影响\"></a>浏览器的刷新影响</h3><ul>\n<li><p>1）当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>\n</li>\n<li><p>2）当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>\n</li>\n<li><p>3）正常操作：地址栏输入 url，跳转链接，前进后退等。</p>\n</li>\n</ul>\n<h3 id=\"Last-Modified-和-Etag\"><a href=\"#Last-Modified-和-Etag\" class=\"headerlink\" title=\"Last-Modified 和 Etag\"></a>Last-Modified 和 Etag</h3><ul>\n<li>会优先使用 Etag</li>\n<li>Last-Modified 只能精确到秒级。</li>\n<li>如果资源被重复生成，而内容不变，则 Etag（根据内容） 更精确。</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h1><blockquote>\n<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数 web 开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。</p>\n</blockquote>\n<p><strong>缓存，是优化网络请求。（js,css,img 可以被缓存）</strong></p>\n<p>它分为<strong>强缓存</strong>和<strong>协商缓存</strong>：</p>\n<ul>\n<li><p>1）浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；</p>\n</li>\n<li><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>\n</li>\n<li><p>3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>\n</li>\n<li><p>4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>\n</li>\n</ul>\n<h4 id=\"常见的-HTTP-缓存首部字段有：\"><a href=\"#常见的-HTTP-缓存首部字段有：\" class=\"headerlink\" title=\"常见的 HTTP 缓存首部字段有：\"></a>常见的 HTTP 缓存首部字段有：</h4><ul>\n<li><p>Expires：响应头，代表该资源的过期时间</p>\n</li>\n<li><p>Cache-Control：请求&#x2F;响应头，缓存控制字段，精确控制缓存策略</p>\n</li>\n<li><p>If-Modified-Since：请求头，资源最近修改时间，由浏览器告诉服务器</p>\n</li>\n<li><p>Last-Modified：响应头，资源最近修改时间，由服务器告诉浏览器</p>\n</li>\n<li><p>Etag：响应头，资源标识，由服务器告诉浏览器</p>\n</li>\n<li><p>If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器</p>\n</li>\n</ul>\n<p>其中， 强缓存 ：</p>\n<ul>\n<li>Expires（HTTP&#x2F;1.0）</li>\n<li>Cache-Control（HTTP&#x2F;1.1）</li>\n</ul>\n<p>协商缓存：</p>\n<ul>\n<li>Last-Modified 和 If-Modified-Since（HTTP&#x2F;1.0）</li>\n<li>ETag 和 If-None-Match（HTTP&#x2F;1.1）</li>\n</ul>\n<h1 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h1><p>关键字： 强制缓存 disk cache max-age</p>\n<blockquote>\n<p>当浏览器初次想服务器请求资源，有服务端判断资源是否需要加缓存。服务器返回资源，并且返回 Cache-Control（response Header 中）。<br>当浏览器再次请求的话，就会在浏览器的本地资源中去找缓存。</p>\n</blockquote>\n<blockquote>\n<p>Expires（<strong>HTTP&#x2F;1.0</strong>）<br>Cache-Control（<strong>HTTP&#x2F;1.1</strong>）<br>强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。<br>通常有 2 种方式来设置是否启用强缓存：<br>1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；<br>2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n</blockquote>\n<p><strong>注意：当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。</strong></p>\n<p><strong>注意：可以通过 Expires &#x2F; Cache-Control 控制，命中强缓存时不会发起网络请求，资源直接从本地获取，浏览器显示状态码 200 from cache。</strong></p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>当浏览器对某个资源的请求命中了强缓存时，返回的<strong>http 状态为 200</strong>，在 chrome 的开发者工具的 network 里面 size 会显示为<strong>from disk cache</strong>，比如京东的首页里就有很多静态资源配置了强缓存，用 chrome 打开几次，再用 f12 查看 network，可以看到有不少请求就是从缓存中加载的：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/f79ca7cf-42ef-407b-b9b7-d3ce890c8210\" alt=\"image\"></p>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><blockquote>\n<p>如果在 Cache-Control 响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。</p>\n</blockquote>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法:\"></a>语法:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: &lt;http-date&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expires: Wed, 21 Oct 2023 07:00:00 GMT</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header，如：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/517c35d2-aadd-496b-b326-a155c4a6646a\" alt=\"image\"></p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header）；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header 在重新加载的时候会被更新。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><blockquote>\n<p>Expires 是较老的强缓存管理 header，由于它是服务器返回的一个<strong>绝对时间</strong>，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。<br>所以在 http1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age&#x3D;315360000.<br>Cache-Control 通用消息头字段，被用于在 http 请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。</p>\n</blockquote>\n<h4 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h4><p>请求指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class=\"line\">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class=\"line\">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class=\"line\">Cache-control: no-cache</span><br><span class=\"line\">Cache-control: no-store</span><br><span class=\"line\">Cache-control: no-transform</span><br><span class=\"line\">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure>\n\n<p>响应指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-control: must-revalidate</span><br><span class=\"line\">Cache-control: no-cache // 不强制缓存</span><br><span class=\"line\">Cache-control: no-store //  不缓存，有服务器去处理</span><br><span class=\"line\">Cache-control: no-transform</span><br><span class=\"line\">Cache-control: public</span><br><span class=\"line\">Cache-control: private</span><br><span class=\"line\">Cache-control: proxy-revalidate</span><br><span class=\"line\">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class=\"line\">Cache-control: s-maxage=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>禁止缓存</p>\n<blockquote>\n<p>发送如下响应头可以关闭缓存。此外，可以参考 Expires 和 Pragma 消息头。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-store</span><br></pre></td></tr></table></figure>\n\n<p>缓存静态资源</p>\n<blockquote>\n<p>对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。另请参阅 Expires 标题。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:public, max-age=31536000</span><br></pre></td></tr></table></figure>\n\n<p>需要重新验证</p>\n<blockquote>\n<p>指定 no-cache 或 max-age&#x3D;0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0, must-revalidate</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意: 如果服务器关闭或失去连接，下面的指令可能会造成使用缓存。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原理：-1\"><a href=\"#原理：-1\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/8b3323b4-3b56-431e-aa61-ad74f7c3b1e5\" alt=\"image\"></p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p>\n<p>Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。</p>\n<p>这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/50340a39-eedd-428a-90d9-92a2307906e4\" alt=\"image\"></p>\n<h3 id=\"强缓存的管理\"><a href=\"#强缓存的管理\" class=\"headerlink\" title=\"强缓存的管理\"></a>强缓存的管理</h3><p>启用强缓存：</p>\n<p>1）通过代码的方式，在 web 服务器返回的响应中添加 Expires 和 Cache-Control Header；</p>\n<p>2）通过配置 web 服务器的方式，让 web 服务器在响应资源的时候统一添加 Expires 和 Cache-Control Header。</p>\n<p>比如在 javaweb 里面，我们可以使用类似下面的代码设置强缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.util.<span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.util.Date();</span><br><span class=\"line\">response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>,date.getTime()+<span class=\"number\">20000</span>); <span class=\"comment\">//Expires:过时期限值</span></span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;public&quot;</span>); <span class=\"comment\">//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span></span><br><span class=\"line\">response.setHeader(<span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;Pragma&quot;</span>); <span class=\"comment\">//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以通过类似下面的 java 代码设置不启用强缓存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader( <span class=\"string\">&quot;Pragma&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span> );</span><br><span class=\"line\">response.setDateHeader(<span class=\"string\">&quot;Expires&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">response.addHeader( <span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span> );<span class=\"comment\">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br></pre></td></tr></table></figure>\n\n<p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css 和 js 等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>\n<p>1）直接 ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>\n<p>2）使用浏览器的隐私模式开发；</p>\n<p>3）如果用的是 chrome，可以 f12 在 network 那里把缓存给禁掉（这是个非常有效的方法）：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/69cb5982-660e-405e-8ec4-d844b6160d8e\" alt=\"image\"></p>\n<p>4）在开发阶段，给资源加上一个动态的参数，如 css&#x2F;index.css?v&#x3D;0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如 jsp 里开发就可以用服务器变量来解决（v&#x3D;${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>\n<p>5）如果资源引用的页面，被嵌入到了一个 iframe 里面，可以在 iframe 的区域右键单击重新加载该页面，以 chrome 为例：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/b1edcf61-f97c-4af4-a92b-833adf52055e\" alt=\"image\"></p>\n<p>6）如果缓存问题出现在 ajax 请求中，最有效的解决办法就是 ajax 的请求地址追加随机数；</p>\n<p>7）还有一种情况就是动态设置 iframe 的 src 时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的 src 后面添加随机数也能解决问题；</p>\n<p>8）如果你用的是 grunt 和 gulp 这种前端工具开发，通过它们的插件比如 grunt-contrib-connect 来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的 respone header 中，cache-control 始终被设置为不缓存：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/123d1fb2-0b04-4c65-a44e-e1025a9428d5\" alt=\"image\"></p>\n<h1 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h1><ul>\n<li>服务端缓存策略。</li>\n<li>浏览器初次请求，服务器会返回资源和资源标识。</li>\n<li>当浏览器再次请求，带着资源标识。服务器会判断资源客户端资源，是否和服务端资源一致。</li>\n<li>一致则返回 304 not Modified.否则返回 200 和最新的资源。</li>\n</ul>\n<p><strong>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对 Header 来管理的。</strong></p>\n<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为<strong>304</strong>并且会显示一个<strong>Not Modified</strong>的字符串，比如你打开京东的首页，按 f12 打开开发者工具，再按 f5 刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/ba8614f2-65bd-46bc-8953-7abd9ba01508\" alt=\"image\"></p>\n<h3 id=\"【Last-Modified，If-Modified-Since\"><a href=\"#【Last-Modified，If-Modified-Since\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since]\"></a>【Last-Modified，If-Modified-Since]</h3><blockquote>\n<p>Last-Modified 是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比 ETag 要低，所以这是一个备用机制。包含有 If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段。<br>If-Modified-Since 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，而在 Last-Modified 首部中会带有上次修改时间。不同于 If-Unmodified-Since, If-Modified-Since 只可以用在 GET 或 HEAD 请求中。</p>\n</blockquote>\n<h4 id=\"原理：-2\"><a href=\"#原理：-2\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）<strong>浏览器初次请求，服务器返回资源+Last-Modified</strong>：浏览器初次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/97d2dbd9-3d4d-47d5-a7f2-5dd71a44750b\" alt=\"image\"></p>\n<p>2）**浏览器再次请求+If-Modified-Since(上次 Last-Modified 的值)**：浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/6e22c453-8b72-4ef2-9b9b-72899d370adb\" alt=\"image\"></p>\n<p>3）**服务器返回 304（一致）或者资源+新的 Last-Modified(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/88eebce5-2bbb-4e60-a325-aa4283215588\" alt=\"image\"></p>\n<p>4）<strong>浏览器收到 304 的响应后，就会从缓存中加载资源。</strong></p>\n<p>5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p>\n<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是【ETag、If-None-Match】。</p>\n<h3 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h3><h4 id=\"原理：-3\"><a href=\"#原理：-3\" class=\"headerlink\" title=\"原理：\"></a>原理：</h4><p>1）<strong>浏览器初次请求，服务器返回资源+Etag</strong>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/22fd09c9-12dc-44a0-9046-47186c0a4fa4\" alt=\"image\"></p>\n<p>2）<strong>浏览器再次请求+If-None-Match</strong>浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header，这个 header 的值就是上一次请求时返回的 ETag 的值：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/d6954c1c-aa40-4619-951a-728762e2b7da\" alt=\"image\"></p>\n<p>3）**服务器返回 304（一致）或者资源+新的 Etag(不一致)**：服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/18a3f0c3-fd12-4569-9feb-032d4048d822\" alt=\"image\"></p>\n<p>4）浏览器收到 304 的响应后，就会从缓存中加载资源。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分 web 服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如 apache:</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/565afaac-8825-4409-9c1c-00e68ca81cb4\" alt=\"image\"></p>\n<p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>\n<p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理 Last-Modified 不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的 Last-Modified 必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉 ETag(每台机器生成的 ETag 都会不一样）；</p>\n<p>京东页面的资源请求，返回的 repsones header 就只有 Last-Modified，没有 ETag：</p>\n<p><img src=\"https://github.com/yihan12/Blog/assets/44987698/50f7ebb8-5bcf-44e8-8ae9-00d3b2d6a13c\" alt=\"image\"></p>\n<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了 Last-Modified 这个 header，还有强缓存的相关 header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>\n<h3 id=\"浏览器的刷新影响\"><a href=\"#浏览器的刷新影响\" class=\"headerlink\" title=\"浏览器的刷新影响\"></a>浏览器的刷新影响</h3><ul>\n<li><p>1）当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>\n</li>\n<li><p>2）当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存；</p>\n</li>\n<li><p>3）正常操作：地址栏输入 url，跳转链接，前进后退等。</p>\n</li>\n</ul>\n<h3 id=\"Last-Modified-和-Etag\"><a href=\"#Last-Modified-和-Etag\" class=\"headerlink\" title=\"Last-Modified 和 Etag\"></a>Last-Modified 和 Etag</h3><ul>\n<li>会优先使用 Etag</li>\n<li>Last-Modified 只能精确到秒级。</li>\n<li>如果资源被重复生成，而内容不变，则 Etag（根据内容） 更精确。</li>\n</ul>\n"},{"title":"【浏览器】之跨域","date":"2023-09-06T01:49:33.170Z","_content":"\n# 什么是跨域？（CORS、同源策略）\n\n> **同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。**（来自 MDN 官方的解释）\n>\n> **受浏览器同源策略的限制，非同源的两个 URL 间不能通信，非同源的脚本不能操作其他源下面的对象**，但在实际开发场景中， 这种情况经常出现， 此时需要通过跨域进行非同源通信\n\n跨域问题的来源是浏览器为了请求安全而引入的基于**同源策略的安全特性**。当页面和请求的协议、主机名或端口不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是浏览器的限制，服务端并不受此影响。\n\n出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。\n\n当产生跨域时，我们可以通过 JSONP、CORS、postMessage 等方式解决。\n\n# 同源策略有什么限制\n\n- 源包括三个部分：**协议、域名、端口（http 协议的默认端口是 80）**。如果有任何一个部分不同，则源不同，那就是跨域了。\n- 限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）\n  - **Cookie、LocalStorage 和 IndexDB 无法获取。**\n  - **无法获取和操作 DOM。**\n  - **不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。**\n\n但是有三个标签是允许跨域加载资源：\n\n- `<img src=XXX>`\n- `<link href=XXX>`\n- `<script src=XXX>`\n\n特别说明两点：\n\n第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。\n\n第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。\n\n这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？\n\n跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。\n\n# 常见通信方式\n\n- **ajax:不支持跨域。**\n- **WebSocket:不受同源策略的限制，支持跨域**\n- **跨域资源共享(CORS):不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的 Ajax。**\n\n# 常见的跨域方式\n\n### 1.jsonp\n\n> **利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。**\n\n原理：  \n**利用<script>标签进行跨域 只能实现 GET 请求**\n\n优缺点：  \nJSONP 优点是**简单兼容性好**，可用于解决主流浏览器的跨域数据访问的问题。缺点是**仅支持 get 方法**具有局限性,不安全可能会遭受 XSS 攻击。\n\nJSONP 的实现流程:\n\n- 声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。\n- 创建一个<script>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show('我不爱你')。\n- 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n\n示例：\n\n```javascript\n// index.html\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement('script')\n    window[callback] = function (data) {\n      resolve(data)\n      document.body.removeChild(script)\n    }\n    params = { ...params, callback } // wd=b&callback=show\n    let arrs = []\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`)\n    }\n    script.src = `${url}?${arrs.join('&')}`\n    document.body.appendChild(script)\n  })\n}\njsonp({\n  url: 'http://localhost:3000/say',\n  params: { wd: 'Iloveyou' },\n  callback: 'show',\n}).then((data) => {\n  console.log(data)\n})\n```\n\n### 2. CORS（Cross-Origin Resource Sharing）跨域资源共享\n\n> **CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。**\n>\n> CORS 为什么支持跨域：**跨域时，浏览器会拦截 Ajax 请求，并在 http 头中加 Origin**。跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了**。\n\n**跨域实际上是浏览器拦截了响应，实际的请求已经发送成功。**\n\n浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。后端允许 CORS 跨域，前端设置代理链接和允许带上 cookie。\n\n> 后端 header 设置\n> Access-Control-Allow-Origin 不可以为 *，因为 *会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址。如：\n\n```javascript\naccess-control-allow-credentials: true\naccess-control-allow-origin: http://localhost:9123\n```\n\n> 前端设置，以 vue+axios 举个例子\n\n```javascript\n// 此处是允许带上cookie\naxios.defaults.withCredentials = true\n```\n\n**我们在开发环境，不需要代理，是因为现在前后端分离的潮流，都是 node 服务器起的代理 proxyTable**\n\n```javascript\nproxy: {\n  \"/fd\": {\n    target:\n      process.env.NODE_ENV === \"production\"\n        ? \"http://m.domian1.com\"\n        : \"http://test.domain.com\",\n    ws: true,\n    changeOrigin: true,\n    pathRewrite: {\n      \"/fd\": \"/\"\n    }\n  }\n},\n```\n\n**服务端设置 Access-Control-Allow-Origin 就可以开启 CORS**。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。只要服务器返回的相应中包含头部信息**Access-Control-Allow-Origin: domain-name，domain-name 为允许跨域的域名，也可以设置成\\***，浏览器就会允许本次跨域请求。\n\n跨源资源共享标准新增了一组 HTTP 标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 **OPTIONS 方法发起一个预检请求（preflight request）**，从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 Cookie 和 HTTP 认证相关数据）。\n\n**简单请求**  \n不会触发预检请求的称为简单请求（**某些请求不会触发 CORS 预检请求**）。当请求满足以下条件时就是一个简单请求：\n\n- 请求方法：GET、HEAD、POST。\n- 请求头：Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、Range（只允许简单的范围标头值 如 bytes=256- 或 bytes=127-255）。\n- Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain\n- 如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。\n- 请求中没有使用 ReadableStream 对象。\n\n**需预检请求**\n\n> 当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个**OPTIONS 请求**，通过**服务端返回的 Access-Control-Allow-\\* 判定请求是否被允许**。\n>\n> 与简单请求不同，“需预检的请求”要求**必须首先使用 OPTIONS 方法发起一个预检请求到服务器**，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\nCORS 引入了以下几个 Access-Control-Allow-\\* ：开头：\n\n- Access-Control-Allow-Origin 表示允许的来源（\\* 该资源可以被任意外源访问。）\n- Access-Control-Allow-Methods 表示允许的请求方法\n- Access-Control-Allow-Headers 表示允许的请求头\n- Access-Control-Allow-Credentials 表示允许携带认证信息\n\n当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。\n\n**预检请求与重定向**\n并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误：\n\n> The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight. Request requires preflight, which is disallowed to follow cross-origin redirects.\n\n### 3. nginx 反向代理\n\n> 原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。  \n> 反向代理解决跨域问题的方案**依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求**。  \n> 实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录\n\n涉及到的端反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可。具体实现方式反向代理的实现方式为在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。\n\n#### 1、 nginx 配置解决 iconfont 跨域\n\n浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。\n\n```\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\n#### 2、 nginx 反向代理接口跨域\n\n原理： **同源策略是浏览器的安全策略**，不是 HTTP 协议的一部分，**服务器端调用 HTTP 接口只是使用 HTTP 协议**，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。\n\n实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录\n\nnginx 配置：\n\n```\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n前端配置:`xhr.withCredentials = true`.\n\n```javascript\nvar xhr = new XMLHttpRequest()\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true\n\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true)\nxhr.send()\n```\n\n### 4. nodejs 中间件代理跨域\n\n> node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。\n\nvue 和 react 框架开发环境，就是用的该方式。\n\n### 5. postMessage\n\n> H5 中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。\n\nwindow.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)。传递给 window.postMessage() 的参数（比如 message）将**通过消息事件对象暴露给接收消息的窗口**。\n\n任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。因此，用于接收消息的任何事件监听器必须首先使用 origin 和 source 属性来检查消息的发送者的身份。无法检查 origin 和 source 属性会导致跨站点脚本攻击。\n\n### 6. WebSocket\n\n> WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。\n\n原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。\n\n# 跨域时 cookie 处理\n\n### 客户端处理\n\n- JSONP 默认能带上 cookie，利用这个特性可以用做跨站请求伪造（CSRF）\n- ajax 默认不带 cookie，需要设置相应属性：withCredentials\n- axios 设置：axios.defaults.withCredentials=true\n\n### 服务端处理\n\nnginx 配置：\n\n- Access-Control-Allow-Credentials：可选字段。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。\n- 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为 _。这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 _，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 a.b.com，则请求将成功执行。也就是说 Access-Control-Allow-Credentials 设置为 true 的情况下\n  Access-Control-Allow-Origin 不能设置为 \\*。\n\n# 扩展\n\n### 1. LocalStorage / SessionStorage\n\n跨域 LocalStorage 和 SessionStorage 同样受到同源策略的限制。而跨域读写的方式也可以使用前文提到的 postMessage。\n\n### 2. 跨域与监控\n\n前端项目在统计前端报错监控时会遇到上报的内容只有 Script Error 的问题。这个问题也是由同源策略引起。在 <script> 标签上添加 crossorigin=\"anonymous\" 并且返回的 JS 文件响应头加上 Access-Control-Allow-Origin: \\* 即可捕捉到完整的错误堆栈。\n\n### 3. 跨域与图片\n\n前端项目在图片处理时可能会遇到图片绘制到 Canvas 上之后却不能读取像素或导出 base64 的问题。这个问题也是由同源策略引起。解决方式和上文相同，给图片添加 crossorigin=\"anonymous\" 并在返回的图片文件响应头加上 Access-Control-Allow-Origin: \\* 即可解决。\n","source":"_posts/浏览器/【浏览器】之跨域.md","raw":"---\ntitle: 【浏览器】之跨域\ndate:\ntags: [浏览器]\ncategories: [前端, 浏览器, 跨域]\n---\n\n# 什么是跨域？（CORS、同源策略）\n\n> **同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。**（来自 MDN 官方的解释）\n>\n> **受浏览器同源策略的限制，非同源的两个 URL 间不能通信，非同源的脚本不能操作其他源下面的对象**，但在实际开发场景中， 这种情况经常出现， 此时需要通过跨域进行非同源通信\n\n跨域问题的来源是浏览器为了请求安全而引入的基于**同源策略的安全特性**。当页面和请求的协议、主机名或端口不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是浏览器的限制，服务端并不受此影响。\n\n出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。\n\n当产生跨域时，我们可以通过 JSONP、CORS、postMessage 等方式解决。\n\n# 同源策略有什么限制\n\n- 源包括三个部分：**协议、域名、端口（http 协议的默认端口是 80）**。如果有任何一个部分不同，则源不同，那就是跨域了。\n- 限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）\n  - **Cookie、LocalStorage 和 IndexDB 无法获取。**\n  - **无法获取和操作 DOM。**\n  - **不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。**\n\n但是有三个标签是允许跨域加载资源：\n\n- `<img src=XXX>`\n- `<link href=XXX>`\n- `<script src=XXX>`\n\n特别说明两点：\n\n第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。\n\n第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。\n\n这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？\n\n跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。\n\n# 常见通信方式\n\n- **ajax:不支持跨域。**\n- **WebSocket:不受同源策略的限制，支持跨域**\n- **跨域资源共享(CORS):不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的 Ajax。**\n\n# 常见的跨域方式\n\n### 1.jsonp\n\n> **利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。**\n\n原理：  \n**利用<script>标签进行跨域 只能实现 GET 请求**\n\n优缺点：  \nJSONP 优点是**简单兼容性好**，可用于解决主流浏览器的跨域数据访问的问题。缺点是**仅支持 get 方法**具有局限性,不安全可能会遭受 XSS 攻击。\n\nJSONP 的实现流程:\n\n- 声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。\n- 创建一个<script>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。\n- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show('我不爱你')。\n- 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。\n\n示例：\n\n```javascript\n// index.html\nfunction jsonp({ url, params, callback }) {\n  return new Promise((resolve, reject) => {\n    let script = document.createElement('script')\n    window[callback] = function (data) {\n      resolve(data)\n      document.body.removeChild(script)\n    }\n    params = { ...params, callback } // wd=b&callback=show\n    let arrs = []\n    for (let key in params) {\n      arrs.push(`${key}=${params[key]}`)\n    }\n    script.src = `${url}?${arrs.join('&')}`\n    document.body.appendChild(script)\n  })\n}\njsonp({\n  url: 'http://localhost:3000/say',\n  params: { wd: 'Iloveyou' },\n  callback: 'show',\n}).then((data) => {\n  console.log(data)\n})\n```\n\n### 2. CORS（Cross-Origin Resource Sharing）跨域资源共享\n\n> **CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。**\n>\n> CORS 为什么支持跨域：**跨域时，浏览器会拦截 Ajax 请求，并在 http 头中加 Origin**。跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了**。\n\n**跨域实际上是浏览器拦截了响应，实际的请求已经发送成功。**\n\n浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。后端允许 CORS 跨域，前端设置代理链接和允许带上 cookie。\n\n> 后端 header 设置\n> Access-Control-Allow-Origin 不可以为 *，因为 *会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址。如：\n\n```javascript\naccess-control-allow-credentials: true\naccess-control-allow-origin: http://localhost:9123\n```\n\n> 前端设置，以 vue+axios 举个例子\n\n```javascript\n// 此处是允许带上cookie\naxios.defaults.withCredentials = true\n```\n\n**我们在开发环境，不需要代理，是因为现在前后端分离的潮流，都是 node 服务器起的代理 proxyTable**\n\n```javascript\nproxy: {\n  \"/fd\": {\n    target:\n      process.env.NODE_ENV === \"production\"\n        ? \"http://m.domian1.com\"\n        : \"http://test.domain.com\",\n    ws: true,\n    changeOrigin: true,\n    pathRewrite: {\n      \"/fd\": \"/\"\n    }\n  }\n},\n```\n\n**服务端设置 Access-Control-Allow-Origin 就可以开启 CORS**。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。只要服务器返回的相应中包含头部信息**Access-Control-Allow-Origin: domain-name，domain-name 为允许跨域的域名，也可以设置成\\***，浏览器就会允许本次跨域请求。\n\n跨源资源共享标准新增了一组 HTTP 标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 **OPTIONS 方法发起一个预检请求（preflight request）**，从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 Cookie 和 HTTP 认证相关数据）。\n\n**简单请求**  \n不会触发预检请求的称为简单请求（**某些请求不会触发 CORS 预检请求**）。当请求满足以下条件时就是一个简单请求：\n\n- 请求方法：GET、HEAD、POST。\n- 请求头：Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、Range（只允许简单的范围标头值 如 bytes=256- 或 bytes=127-255）。\n- Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain\n- 如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。\n- 请求中没有使用 ReadableStream 对象。\n\n**需预检请求**\n\n> 当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个**OPTIONS 请求**，通过**服务端返回的 Access-Control-Allow-\\* 判定请求是否被允许**。\n>\n> 与简单请求不同，“需预检的请求”要求**必须首先使用 OPTIONS 方法发起一个预检请求到服务器**，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\n\nCORS 引入了以下几个 Access-Control-Allow-\\* ：开头：\n\n- Access-Control-Allow-Origin 表示允许的来源（\\* 该资源可以被任意外源访问。）\n- Access-Control-Allow-Methods 表示允许的请求方法\n- Access-Control-Allow-Headers 表示允许的请求头\n- Access-Control-Allow-Credentials 表示允许携带认证信息\n\n当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。\n\n**预检请求与重定向**\n并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误：\n\n> The request was redirected to 'https://example.com/foo', which is disallowed for cross-origin requests that require preflight. Request requires preflight, which is disallowed to follow cross-origin redirects.\n\n### 3. nginx 反向代理\n\n> 原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。  \n> 反向代理解决跨域问题的方案**依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求**。  \n> 实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录\n\n涉及到的端反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可。具体实现方式反向代理的实现方式为在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。\n\n#### 1、 nginx 配置解决 iconfont 跨域\n\n浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。\n\n```\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\n#### 2、 nginx 反向代理接口跨域\n\n原理： **同源策略是浏览器的安全策略**，不是 HTTP 协议的一部分，**服务器端调用 HTTP 接口只是使用 HTTP 协议**，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。\n\n实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录\n\nnginx 配置：\n\n```\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n```\n\n前端配置:`xhr.withCredentials = true`.\n\n```javascript\nvar xhr = new XMLHttpRequest()\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true\n\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true)\nxhr.send()\n```\n\n### 4. nodejs 中间件代理跨域\n\n> node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。\n\nvue 和 react 框架开发环境，就是用的该方式。\n\n### 5. postMessage\n\n> H5 中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。\n\nwindow.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。\n\n从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)。传递给 window.postMessage() 的参数（比如 message）将**通过消息事件对象暴露给接收消息的窗口**。\n\n任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。因此，用于接收消息的任何事件监听器必须首先使用 origin 和 source 属性来检查消息的发送者的身份。无法检查 origin 和 source 属性会导致跨站点脚本攻击。\n\n### 6. WebSocket\n\n> WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。\n\n原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。\n\n# 跨域时 cookie 处理\n\n### 客户端处理\n\n- JSONP 默认能带上 cookie，利用这个特性可以用做跨站请求伪造（CSRF）\n- ajax 默认不带 cookie，需要设置相应属性：withCredentials\n- axios 设置：axios.defaults.withCredentials=true\n\n### 服务端处理\n\nnginx 配置：\n\n- Access-Control-Allow-Credentials：可选字段。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。\n- 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为 _。这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 _，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 a.b.com，则请求将成功执行。也就是说 Access-Control-Allow-Credentials 设置为 true 的情况下\n  Access-Control-Allow-Origin 不能设置为 \\*。\n\n# 扩展\n\n### 1. LocalStorage / SessionStorage\n\n跨域 LocalStorage 和 SessionStorage 同样受到同源策略的限制。而跨域读写的方式也可以使用前文提到的 postMessage。\n\n### 2. 跨域与监控\n\n前端项目在统计前端报错监控时会遇到上报的内容只有 Script Error 的问题。这个问题也是由同源策略引起。在 <script> 标签上添加 crossorigin=\"anonymous\" 并且返回的 JS 文件响应头加上 Access-Control-Allow-Origin: \\* 即可捕捉到完整的错误堆栈。\n\n### 3. 跨域与图片\n\n前端项目在图片处理时可能会遇到图片绘制到 Canvas 上之后却不能读取像素或导出 base64 的问题。这个问题也是由同源策略引起。解决方式和上文相同，给图片添加 crossorigin=\"anonymous\" 并在返回的图片文件响应头加上 Access-Control-Allow-Origin: \\* 即可解决。\n","slug":"浏览器/【浏览器】之跨域","published":1,"updated":"2023-09-06T01:49:58.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwyb00efm32v6cmf7qv3","content":"<h1 id=\"什么是跨域？（CORS、同源策略）\"><a href=\"#什么是跨域？（CORS、同源策略）\" class=\"headerlink\" title=\"什么是跨域？（CORS、同源策略）\"></a>什么是跨域？（CORS、同源策略）</h1><blockquote>\n<p><strong>同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</strong>（来自 MDN 官方的解释）</p>\n<p><strong>受浏览器同源策略的限制，非同源的两个 URL 间不能通信，非同源的脚本不能操作其他源下面的对象</strong>，但在实际开发场景中， 这种情况经常出现， 此时需要通过跨域进行非同源通信</p>\n</blockquote>\n<p>跨域问题的来源是浏览器为了请求安全而引入的基于<strong>同源策略的安全特性</strong>。当页面和请求的协议、主机名或端口不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是浏览器的限制，服务端并不受此影响。</p>\n<p>出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p>\n<p>当产生跨域时，我们可以通过 JSONP、CORS、postMessage 等方式解决。</p>\n<h1 id=\"同源策略有什么限制\"><a href=\"#同源策略有什么限制\" class=\"headerlink\" title=\"同源策略有什么限制\"></a>同源策略有什么限制</h1><ul>\n<li>源包括三个部分：<strong>协议、域名、端口（http 协议的默认端口是 80）</strong>。如果有任何一个部分不同，则源不同，那就是跨域了。</li>\n<li>限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）<ul>\n<li><strong>Cookie、LocalStorage 和 IndexDB 无法获取。</strong></li>\n<li><strong>无法获取和操作 DOM。</strong></li>\n<li><strong>不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。</strong></li>\n</ul>\n</li>\n</ul>\n<p>但是有三个标签是允许跨域加载资源：</p>\n<ul>\n<li><code>&lt;img src=XXX&gt;</code></li>\n<li><code>&lt;link href=XXX&gt;</code></li>\n<li><code>&lt;script src=XXX&gt;</code></li>\n</ul>\n<p>特别说明两点：</p>\n<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>\n<p>第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。</p>\n<p>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</p>\n<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>\n<h1 id=\"常见通信方式\"><a href=\"#常见通信方式\" class=\"headerlink\" title=\"常见通信方式\"></a>常见通信方式</h1><ul>\n<li><strong>ajax:不支持跨域。</strong></li>\n<li><strong>WebSocket:不受同源策略的限制，支持跨域</strong></li>\n<li><strong>跨域资源共享(CORS):不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的 Ajax。</strong></li>\n</ul>\n<h1 id=\"常见的跨域方式\"><a href=\"#常见的跨域方式\" class=\"headerlink\" title=\"常见的跨域方式\"></a>常见的跨域方式</h1><h3 id=\"1-jsonp\"><a href=\"#1-jsonp\" class=\"headerlink\" title=\"1.jsonp\"></a>1.jsonp</h3><blockquote>\n<p><strong>利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。</strong></p>\n</blockquote>\n<p>原理：<br><strong>利用<script>标签进行跨域 只能实现 GET 请求</strong></p>\n<p>优缺点：<br>JSONP 优点是<strong>简单兼容性好</strong>，可用于解决主流浏览器的跨域数据访问的问题。缺点是<strong>仅支持 get 方法</strong>具有局限性,不安全可能会遭受 XSS 攻击。</p>\n<p>JSONP 的实现流程:</p>\n<ul>\n<li>声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。</li>\n<li>创建一个<script>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li>\n<li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show('我不爱你')。</li>\n<li>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.html</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jsonp</span>(<span class=\"params\">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> script = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>[callback] = <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data)</span><br><span class=\"line\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(script)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    params = &#123; ...params, callback &#125; <span class=\"comment\">// wd=b&amp;callback=show</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">      arrs.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;params[key]&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.<span class=\"property\">src</span> = <span class=\"string\">`<span class=\"subst\">$&#123;url&#125;</span>?<span class=\"subst\">$&#123;arrs.join(<span class=\"string\">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(script)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">jsonp</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://localhost:3000/say&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">params</span>: &#123; <span class=\"attr\">wd</span>: <span class=\"string\">&#x27;Iloveyou&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">callback</span>: <span class=\"string\">&#x27;show&#x27;</span>,</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-CORS（Cross-Origin-Resource-Sharing）跨域资源共享\"><a href=\"#2-CORS（Cross-Origin-Resource-Sharing）跨域资源共享\" class=\"headerlink\" title=\"2. CORS（Cross-Origin Resource Sharing）跨域资源共享\"></a>2. CORS（Cross-Origin Resource Sharing）跨域资源共享</h3><blockquote>\n<p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</strong></p>\n<p>CORS 为什么支持跨域：<strong>跨域时，浏览器会拦截 Ajax 请求，并在 http 头中加 Origin</strong>。跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。<strong>跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了</strong>。</p>\n</blockquote>\n<p><strong>跨域实际上是浏览器拦截了响应，实际的请求已经发送成功。</strong></p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。后端允许 CORS 跨域，前端设置代理链接和允许带上 cookie。</p>\n<blockquote>\n<p>后端 header 设置<br>Access-Control-Allow-Origin 不可以为 *，因为 *会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址。如：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">access-control-allow-<span class=\"attr\">credentials</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">access-control-allow-<span class=\"attr\">origin</span>: <span class=\"attr\">http</span>:<span class=\"comment\">//localhost:9123</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>前端设置，以 vue+axios 举个例子</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处是允许带上cookie</span></span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>我们在开发环境，不需要代理，是因为现在前后端分离的潮流，都是 node 服务器起的代理 proxyTable</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;/fd&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>:</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> === <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\">        ? <span class=\"string\">&quot;http://m.domian1.com&quot;</span></span><br><span class=\"line\">        : <span class=\"string\">&quot;http://test.domain.com&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">ws</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">pathRewrite</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;/fd&quot;</span>: <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS</strong>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。只要服务器返回的相应中包含头部信息**Access-Control-Allow-Origin: domain-name，domain-name 为允许跨域的域名，也可以设置成***，浏览器就会允许本次跨域请求。</p>\n<p>跨源资源共享标准新增了一组 HTTP 标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 <strong>OPTIONS 方法发起一个预检请求（preflight request）</strong>，从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 Cookie 和 HTTP 认证相关数据）。</p>\n<p><strong>简单请求</strong><br>不会触发预检请求的称为简单请求（<strong>某些请求不会触发 CORS 预检请求</strong>）。当请求满足以下条件时就是一个简单请求：</p>\n<ul>\n<li>请求方法：GET、HEAD、POST。</li>\n<li>请求头：Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、Range（只允许简单的范围标头值 如 bytes=256- 或 bytes=127-255）。</li>\n<li>Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n<li>如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。</li>\n<li>请求中没有使用 ReadableStream 对象。</li>\n</ul>\n<p><strong>需预检请求</strong></p>\n<blockquote>\n<p>当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个<strong>OPTIONS 请求</strong>，通过<strong>服务端返回的 Access-Control-Allow-* 判定请求是否被允许</strong>。</p>\n<p>与简单请求不同，“需预检的请求”要求<strong>必须首先使用 OPTIONS 方法发起一个预检请求到服务器</strong>，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n</blockquote>\n<p>CORS 引入了以下几个 Access-Control-Allow-* ：开头：</p>\n<ul>\n<li>Access-Control-Allow-Origin 表示允许的来源（* 该资源可以被任意外源访问。）</li>\n<li>Access-Control-Allow-Methods 表示允许的请求方法</li>\n<li>Access-Control-Allow-Headers 表示允许的请求头</li>\n<li>Access-Control-Allow-Credentials 表示允许携带认证信息</li>\n</ul>\n<p>当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。</p>\n<p><strong>预检请求与重定向</strong><br>并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误：</p>\n<blockquote>\n<p>The request was redirected to '<a href=\"https://example.com/foo\">https://example.com/foo</a>', which is disallowed for cross-origin requests that require preflight. Request requires preflight, which is disallowed to follow cross-origin redirects.</p>\n</blockquote>\n<h3 id=\"3-nginx-反向代理\"><a href=\"#3-nginx-反向代理\" class=\"headerlink\" title=\"3. nginx 反向代理\"></a>3. nginx 反向代理</h3><blockquote>\n<p>原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。<br>反向代理解决跨域问题的方案<strong>依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求</strong>。<br>实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录</p>\n</blockquote>\n<p>涉及到的端反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可。具体实现方式反向代理的实现方式为在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。</p>\n<h4 id=\"1、-nginx-配置解决-iconfont-跨域\"><a href=\"#1、-nginx-配置解决-iconfont-跨域\" class=\"headerlink\" title=\"1、 nginx 配置解决 iconfont 跨域\"></a>1、 nginx 配置解决 iconfont 跨域</h4><p>浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、-nginx-反向代理接口跨域\"><a href=\"#2、-nginx-反向代理接口跨域\" class=\"headerlink\" title=\"2、 nginx 反向代理接口跨域\"></a>2、 nginx 反向代理接口跨域</h4><p>原理： <strong>同源策略是浏览器的安全策略</strong>，不是 HTTP 协议的一部分，<strong>服务器端调用 HTTP 接口只是使用 HTTP 协议</strong>，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。</p>\n<p>实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录</p>\n<p>nginx 配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#proxy服务器</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       81;</span><br><span class=\"line\">    server_name  www.domain1.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class=\"line\">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端配置:<code>xhr.withCredentials = true</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前端开关：浏览器是否读写cookie</span></span><br><span class=\"line\">xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问nginx中的代理服务器</span></span><br><span class=\"line\">xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.<span class=\"title function_\">send</span>()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-nodejs-中间件代理跨域\"><a href=\"#4-nodejs-中间件代理跨域\" class=\"headerlink\" title=\"4. nodejs 中间件代理跨域\"></a>4. nodejs 中间件代理跨域</h3><blockquote>\n<p>node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。</p>\n</blockquote>\n<p>vue 和 react 框架开发环境，就是用的该方式。</p>\n<h3 id=\"5-postMessage\"><a href=\"#5-postMessage\" class=\"headerlink\" title=\"5. postMessage\"></a>5. postMessage</h3><blockquote>\n<p>H5 中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。</p>\n</blockquote>\n<p>window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p>\n<p>从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)。传递给 window.postMessage() 的参数（比如 message）将<strong>通过消息事件对象暴露给接收消息的窗口</strong>。</p>\n<p>任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。因此，用于接收消息的任何事件监听器必须首先使用 origin 和 source 属性来检查消息的发送者的身份。无法检查 origin 和 source 属性会导致跨站点脚本攻击。</p>\n<h3 id=\"6-WebSocket\"><a href=\"#6-WebSocket\" class=\"headerlink\" title=\"6. WebSocket\"></a>6. WebSocket</h3><blockquote>\n<p>WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。</p>\n</blockquote>\n<p>原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。</p>\n<h1 id=\"跨域时-cookie-处理\"><a href=\"#跨域时-cookie-处理\" class=\"headerlink\" title=\"跨域时 cookie 处理\"></a>跨域时 cookie 处理</h1><h3 id=\"客户端处理\"><a href=\"#客户端处理\" class=\"headerlink\" title=\"客户端处理\"></a>客户端处理</h3><ul>\n<li>JSONP 默认能带上 cookie，利用这个特性可以用做跨站请求伪造（CSRF）</li>\n<li>ajax 默认不带 cookie，需要设置相应属性：withCredentials</li>\n<li>axios 设置：axios.defaults.withCredentials=true</li>\n</ul>\n<h3 id=\"服务端处理\"><a href=\"#服务端处理\" class=\"headerlink\" title=\"服务端处理\"></a>服务端处理</h3><p>nginx 配置：</p>\n<ul>\n<li>Access-Control-Allow-Credentials：可选字段。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</li>\n<li>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为 _。这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 _，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 a.b.com，则请求将成功执行。也就是说 Access-Control-Allow-Credentials 设置为 true 的情况下<br>Access-Control-Allow-Origin 不能设置为 *。</li>\n</ul>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h3 id=\"1-LocalStorage-SessionStorage\"><a href=\"#1-LocalStorage-SessionStorage\" class=\"headerlink\" title=\"1. LocalStorage / SessionStorage\"></a>1. LocalStorage / SessionStorage</h3><p>跨域 LocalStorage 和 SessionStorage 同样受到同源策略的限制。而跨域读写的方式也可以使用前文提到的 postMessage。</p>\n<h3 id=\"2-跨域与监控\"><a href=\"#2-跨域与监控\" class=\"headerlink\" title=\"2. 跨域与监控\"></a>2. 跨域与监控</h3><p>前端项目在统计前端报错监控时会遇到上报的内容只有 Script Error 的问题。这个问题也是由同源策略引起。在 <script> 标签上添加 crossorigin=\"anonymous\" 并且返回的 JS 文件响应头加上 Access-Control-Allow-Origin: * 即可捕捉到完整的错误堆栈。</p>\n<h3 id=\"3-跨域与图片\"><a href=\"#3-跨域与图片\" class=\"headerlink\" title=\"3. 跨域与图片\"></a>3. 跨域与图片</h3><p>前端项目在图片处理时可能会遇到图片绘制到 Canvas 上之后却不能读取像素或导出 base64 的问题。这个问题也是由同源策略引起。解决方式和上文相同，给图片添加 crossorigin=\"anonymous\" 并在返回的图片文件响应头加上 Access-Control-Allow-Origin: * 即可解决。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"什么是跨域？（CORS、同源策略）\"><a href=\"#什么是跨域？（CORS、同源策略）\" class=\"headerlink\" title=\"什么是跨域？（CORS、同源策略）\"></a>什么是跨域？（CORS、同源策略）</h1><blockquote>\n<p><strong>同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。</strong>（来自 MDN 官方的解释）</p>\n<p><strong>受浏览器同源策略的限制，非同源的两个 URL 间不能通信，非同源的脚本不能操作其他源下面的对象</strong>，但在实际开发场景中， 这种情况经常出现， 此时需要通过跨域进行非同源通信</p>\n</blockquote>\n<p>跨域问题的来源是浏览器为了请求安全而引入的基于<strong>同源策略的安全特性</strong>。当页面和请求的协议、主机名或端口不同时，浏览器判定两者不同源，即为跨域请求。需要注意的是跨域是浏览器的限制，服务端并不受此影响。</p>\n<p>出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p>\n<p>当产生跨域时，我们可以通过 JSONP、CORS、postMessage 等方式解决。</p>\n<h1 id=\"同源策略有什么限制\"><a href=\"#同源策略有什么限制\" class=\"headerlink\" title=\"同源策略有什么限制\"></a>同源策略有什么限制</h1><ul>\n<li>源包括三个部分：<strong>协议、域名、端口（http 协议的默认端口是 80）</strong>。如果有任何一个部分不同，则源不同，那就是跨域了。</li>\n<li>限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）<ul>\n<li><strong>Cookie、LocalStorage 和 IndexDB 无法获取。</strong></li>\n<li><strong>无法获取和操作 DOM。</strong></li>\n<li><strong>不能发送 Ajax 请求。我们要注意，Ajax 只适合同源的通信。</strong></li>\n</ul>\n</li>\n</ul>\n<p>但是有三个标签是允许跨域加载资源：</p>\n<ul>\n<li><code>&lt;img src=XXX&gt;</code></li>\n<li><code>&lt;link href=XXX&gt;</code></li>\n<li><code>&lt;script src=XXX&gt;</code></li>\n</ul>\n<p>特别说明两点：</p>\n<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>\n<p>第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。</p>\n<p>这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？</p>\n<p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>\n<h1 id=\"常见通信方式\"><a href=\"#常见通信方式\" class=\"headerlink\" title=\"常见通信方式\"></a>常见通信方式</h1><ul>\n<li><strong>ajax:不支持跨域。</strong></li>\n<li><strong>WebSocket:不受同源策略的限制，支持跨域</strong></li>\n<li><strong>跨域资源共享(CORS):不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的 Ajax。</strong></li>\n</ul>\n<h1 id=\"常见的跨域方式\"><a href=\"#常见的跨域方式\" class=\"headerlink\" title=\"常见的跨域方式\"></a>常见的跨域方式</h1><h3 id=\"1-jsonp\"><a href=\"#1-jsonp\" class=\"headerlink\" title=\"1.jsonp\"></a>1.jsonp</h3><blockquote>\n<p><strong>利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。</strong></p>\n</blockquote>\n<p>原理：<br><strong>利用<script>标签进行跨域 只能实现 GET 请求</strong></p>\n<p>优缺点：<br>JSONP 优点是<strong>简单兼容性好</strong>，可用于解决主流浏览器的跨域数据访问的问题。缺点是<strong>仅支持 get 方法</strong>具有局限性,不安全可能会遭受 XSS 攻击。</p>\n<p>JSONP 的实现流程:</p>\n<ul>\n<li>声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。</li>\n<li>创建一个<script>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li>\n<li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show('我不爱你')。</li>\n<li>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li>\n</ul>\n<p>示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// index.html</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">jsonp</span>(<span class=\"params\">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> script = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;script&#x27;</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>[callback] = <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data)</span><br><span class=\"line\">      <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(script)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    params = &#123; ...params, callback &#125; <span class=\"comment\">// wd=b&amp;callback=show</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">      arrs.<span class=\"title function_\">push</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>=<span class=\"subst\">$&#123;params[key]&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    script.<span class=\"property\">src</span> = <span class=\"string\">`<span class=\"subst\">$&#123;url&#125;</span>?<span class=\"subst\">$&#123;arrs.join(<span class=\"string\">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(script)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">jsonp</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">url</span>: <span class=\"string\">&#x27;http://localhost:3000/say&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">params</span>: &#123; <span class=\"attr\">wd</span>: <span class=\"string\">&#x27;Iloveyou&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">callback</span>: <span class=\"string\">&#x27;show&#x27;</span>,</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-CORS（Cross-Origin-Resource-Sharing）跨域资源共享\"><a href=\"#2-CORS（Cross-Origin-Resource-Sharing）跨域资源共享\" class=\"headerlink\" title=\"2. CORS（Cross-Origin Resource Sharing）跨域资源共享\"></a>2. CORS（Cross-Origin Resource Sharing）跨域资源共享</h3><blockquote>\n<p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</strong></p>\n<p>CORS 为什么支持跨域：<strong>跨域时，浏览器会拦截 Ajax 请求，并在 http 头中加 Origin</strong>。跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。<strong>跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了</strong>。</p>\n</blockquote>\n<p><strong>跨域实际上是浏览器拦截了响应，实际的请求已经发送成功。</strong></p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。后端允许 CORS 跨域，前端设置代理链接和允许带上 cookie。</p>\n<blockquote>\n<p>后端 header 设置<br>Access-Control-Allow-Origin 不可以为 *，因为 *会和 Access-Control-Allow-Credentials:true 冲突，需配置指定的地址。如：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">access-control-allow-<span class=\"attr\">credentials</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">access-control-allow-<span class=\"attr\">origin</span>: <span class=\"attr\">http</span>:<span class=\"comment\">//localhost:9123</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>前端设置，以 vue+axios 举个例子</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此处是允许带上cookie</span></span><br><span class=\"line\">axios.<span class=\"property\">defaults</span>.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>我们在开发环境，不需要代理，是因为现在前后端分离的潮流，都是 node 服务器起的代理 proxyTable</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;/fd&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>:</span><br><span class=\"line\">      process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> === <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\">        ? <span class=\"string\">&quot;http://m.domian1.com&quot;</span></span><br><span class=\"line\">        : <span class=\"string\">&quot;http://test.domain.com&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">ws</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">pathRewrite</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;/fd&quot;</span>: <span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS</strong>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。只要服务器返回的相应中包含头部信息**Access-Control-Allow-Origin: domain-name，domain-name 为允许跨域的域名，也可以设置成***，浏览器就会允许本次跨域请求。</p>\n<p>跨源资源共享标准新增了一组 HTTP 标头字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 <strong>OPTIONS 方法发起一个预检请求（preflight request）</strong>，从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 Cookie 和 HTTP 认证相关数据）。</p>\n<p><strong>简单请求</strong><br>不会触发预检请求的称为简单请求（<strong>某些请求不会触发 CORS 预检请求</strong>）。当请求满足以下条件时就是一个简单请求：</p>\n<ul>\n<li>请求方法：GET、HEAD、POST。</li>\n<li>请求头：Accept、Accept-Language、Content-Language、Content-Type（需要注意额外的限制）、Range（只允许简单的范围标头值 如 bytes=256- 或 bytes=127-255）。</li>\n<li>Content-Type 仅支持：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n<li>如果请求是使用 XMLHttpRequest 对象发出的，在返回的 XMLHttpRequest.upload 对象属性上没有注册任何事件监听器；也就是说，给定一个 XMLHttpRequest 实例 xhr，没有调用 xhr.upload.addEventListener()，以监听该上传请求。</li>\n<li>请求中没有使用 ReadableStream 对象。</li>\n</ul>\n<p><strong>需预检请求</strong></p>\n<blockquote>\n<p>当一个请求不满足以上简单请求的条件时，浏览器会自动向服务端发送一个<strong>OPTIONS 请求</strong>，通过<strong>服务端返回的 Access-Control-Allow-* 判定请求是否被允许</strong>。</p>\n<p>与简单请求不同，“需预检的请求”要求<strong>必须首先使用 OPTIONS 方法发起一个预检请求到服务器</strong>，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>\n</blockquote>\n<p>CORS 引入了以下几个 Access-Control-Allow-* ：开头：</p>\n<ul>\n<li>Access-Control-Allow-Origin 表示允许的来源（* 该资源可以被任意外源访问。）</li>\n<li>Access-Control-Allow-Methods 表示允许的请求方法</li>\n<li>Access-Control-Allow-Headers 表示允许的请求头</li>\n<li>Access-Control-Allow-Credentials 表示允许携带认证信息</li>\n</ul>\n<p>当请求符合响应头的这些条件时，浏览器才会发送并响应正式的请求。</p>\n<p><strong>预检请求与重定向</strong><br>并不是所有浏览器都支持预检请求的重定向。如果一个预检请求发生了重定向，一部分浏览器将报告错误：</p>\n<blockquote>\n<p>The request was redirected to '<a href=\"https://example.com/foo\">https://example.com/foo</a>', which is disallowed for cross-origin requests that require preflight. Request requires preflight, which is disallowed to follow cross-origin redirects.</p>\n</blockquote>\n<h3 id=\"3-nginx-反向代理\"><a href=\"#3-nginx-反向代理\" class=\"headerlink\" title=\"3. nginx 反向代理\"></a>3. nginx 反向代理</h3><blockquote>\n<p>原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分，服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。<br>反向代理解决跨域问题的方案<strong>依赖同源的服务端对请求做一个转发处理，将请求从跨域请求转换成同源请求</strong>。<br>实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录</p>\n</blockquote>\n<p>涉及到的端反向代理只需要服务端/后端支持，几乎不涉及前端改动，只用切换接口即可。具体实现方式反向代理的实现方式为在页面同域下配置一套反向代理服务，页面请求同域的服务端，服务端请求上游的实际的服务端，之后将结果返回给前端。</p>\n<h4 id=\"1、-nginx-配置解决-iconfont-跨域\"><a href=\"#1、-nginx-配置解决-iconfont-跨域\" class=\"headerlink\" title=\"1、 nginx 配置解决 iconfont 跨域\"></a>1、 nginx 配置解决 iconfont 跨域</h4><p>浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、-nginx-反向代理接口跨域\"><a href=\"#2、-nginx-反向代理接口跨域\" class=\"headerlink\" title=\"2、 nginx 反向代理接口跨域\"></a>2、 nginx 反向代理接口跨域</h4><p>原理： <strong>同源策略是浏览器的安全策略</strong>，不是 HTTP 协议的一部分，<strong>服务器端调用 HTTP 接口只是使用 HTTP 协议</strong>，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。</p>\n<p>实现：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录</p>\n<p>nginx 配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#proxy服务器</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       81;</span><br><span class=\"line\">    server_name  www.domain1.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class=\"line\">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端配置:<code>xhr.withCredentials = true</code>.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前端开关：浏览器是否读写cookie</span></span><br><span class=\"line\">xhr.<span class=\"property\">withCredentials</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问nginx中的代理服务器</span></span><br><span class=\"line\">xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;get&#x27;</span>, <span class=\"string\">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.<span class=\"title function_\">send</span>()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-nodejs-中间件代理跨域\"><a href=\"#4-nodejs-中间件代理跨域\" class=\"headerlink\" title=\"4. nodejs 中间件代理跨域\"></a>4. nodejs 中间件代理跨域</h3><blockquote>\n<p>node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite 参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。</p>\n</blockquote>\n<p>vue 和 react 框架开发环境，就是用的该方式。</p>\n<h3 id=\"5-postMessage\"><a href=\"#5-postMessage\" class=\"headerlink\" title=\"5. postMessage\"></a>5. postMessage</h3><blockquote>\n<p>H5 中新增的`postMessage()``方法，可以用来做跨域通信。既然是 H5 中新增的，那就一定要提到。</p>\n</blockquote>\n<p>window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p>\n<p>从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 (en-US)。传递给 window.postMessage() 的参数（比如 message）将<strong>通过消息事件对象暴露给接收消息的窗口</strong>。</p>\n<p>任何窗口可以在任何其他窗口访问此方法，在任何时间，无论文档在窗口中的位置，向其发送消息。因此，用于接收消息的任何事件监听器必须首先使用 origin 和 source 属性来检查消息的发送者的身份。无法检查 origin 和 source 属性会导致跨站点脚本攻击。</p>\n<h3 id=\"6-WebSocket\"><a href=\"#6-WebSocket\" class=\"headerlink\" title=\"6. WebSocket\"></a>6. WebSocket</h3><blockquote>\n<p>WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。</p>\n</blockquote>\n<p>原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。</p>\n<h1 id=\"跨域时-cookie-处理\"><a href=\"#跨域时-cookie-处理\" class=\"headerlink\" title=\"跨域时 cookie 处理\"></a>跨域时 cookie 处理</h1><h3 id=\"客户端处理\"><a href=\"#客户端处理\" class=\"headerlink\" title=\"客户端处理\"></a>客户端处理</h3><ul>\n<li>JSONP 默认能带上 cookie，利用这个特性可以用做跨站请求伪造（CSRF）</li>\n<li>ajax 默认不带 cookie，需要设置相应属性：withCredentials</li>\n<li>axios 设置：axios.defaults.withCredentials=true</li>\n</ul>\n<h3 id=\"服务端处理\"><a href=\"#服务端处理\" class=\"headerlink\" title=\"服务端处理\"></a>服务端处理</h3><p>nginx 配置：</p>\n<ul>\n<li>Access-Control-Allow-Credentials：可选字段。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</li>\n<li>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为 _。这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为 _，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 a.b.com，则请求将成功执行。也就是说 Access-Control-Allow-Credentials 设置为 true 的情况下<br>Access-Control-Allow-Origin 不能设置为 *。</li>\n</ul>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><h3 id=\"1-LocalStorage-SessionStorage\"><a href=\"#1-LocalStorage-SessionStorage\" class=\"headerlink\" title=\"1. LocalStorage / SessionStorage\"></a>1. LocalStorage / SessionStorage</h3><p>跨域 LocalStorage 和 SessionStorage 同样受到同源策略的限制。而跨域读写的方式也可以使用前文提到的 postMessage。</p>\n<h3 id=\"2-跨域与监控\"><a href=\"#2-跨域与监控\" class=\"headerlink\" title=\"2. 跨域与监控\"></a>2. 跨域与监控</h3><p>前端项目在统计前端报错监控时会遇到上报的内容只有 Script Error 的问题。这个问题也是由同源策略引起。在 <script> 标签上添加 crossorigin=\"anonymous\" 并且返回的 JS 文件响应头加上 Access-Control-Allow-Origin: * 即可捕捉到完整的错误堆栈。</p>\n<h3 id=\"3-跨域与图片\"><a href=\"#3-跨域与图片\" class=\"headerlink\" title=\"3. 跨域与图片\"></a>3. 跨域与图片</h3><p>前端项目在图片处理时可能会遇到图片绘制到 Canvas 上之后却不能读取像素或导出 base64 的问题。这个问题也是由同源策略引起。解决方式和上文相同，给图片添加 crossorigin=\"anonymous\" 并在返回的图片文件响应头加上 Access-Control-Allow-Origin: * 即可解决。</p>\n"},{"title":"【跟着大佬学JavaScript】之lodash防抖节流合并","date":"2022-07-09T17:12:41.328Z","_content":"\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","source":"_posts/JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并.md","raw":"---\ntitle: 【跟着大佬学JavaScript】之lodash防抖节流合并\ndate:\ntags: [JavaScript, lodash]\ncategories: [前端, JavaScript, lodash源码分析, 防抖节流]\n---\n\n## 前言\n\n前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。\n\n初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。\n\n这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。\n\n## 原理\n\n前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。\n\n> **防抖的原理**：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。\n\n通俗点说：定义 wait=3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。\n\n> **节流的原理**：持续触发某事件，每隔一段时间，只执行一次。\n\n通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。\n\n简单来说：每隔单位时间（ 3 秒），只执行一次。\n\n## 代码分析\n\n### 一、引入代码部分\n\n首先看源码最前方的引入。\n\n```\nimport isObject from './isObject.js'\nimport root from './.internal/root.js'\n```\n\nisObject 方法，直接拿出来，\n\n```\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n```\n\nroot 的引入主要是 window。为了引出`window.requestAnimationFrame`。\n\n### 二、requestAnimationFrame 代码\n\n`window.requestAnimationFrame()`告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。\n\nlodash 这里使用`requestAnimationFrame`，主要是用户使用 debounce 函数未设置 wait 的情况下使用`requestAnimationFrame`。\n\n```\nconst useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')\nfunction startTimer(pendingFunc, wait) {\n    if (useRAF) {\n        window.cancelAnimationFrame(timerId)\n        return window.requestAnimationFrame(pendingFunc)\n    }\n    return setTimeout(pendingFunc, wait)\n}\n\nfunction cancelTimer(id) {\n    if (useRAF) {\n        return window.cancelAnimationFrame(id)\n    }\n    clearTimeout(id)\n}\n```\n\n由代码`const useRAF = (!wait && wait !== 0 && typeof window.requestAnimationFrame === 'function')`不难看出,函数**未传入 wait**并且**window.cancelAnimationFrame 函数存在**这两种情况下操作`window.requestAnimationFrame`\n\n### 三、由简入繁输出防抖函数\n\n- **首先**，我们来看下[lodash debounce API](https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options)  \n  这部分参数内容就直接摘抄在下方：\n  _ func (Function): 要防抖动的函数。\n  _ [wait=0] (number): 需要延迟的毫秒数。\n  _ [options=] (Object): 选项对象。\n  _ [options.leading=false] (boolean): 指定在延迟开始前调用。\n  _ [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  _ [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n- **然后**，我们一般防抖函数，需要的参数是：`func`、`wait`、`immediate`这三个参数，对应 lodash，我们需要拿出这四个部分：\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n- **接着**，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n\n```\n// 代码1\nfunction debounce(func, wait) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n\n    wait = +wait || 0; // 等待时间\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = undefined;\n    }\n\n    // 开启定时器\n    // 1.未传wait时使用requestAnimationFrame\n    // 2.直接使用定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      timerId = startTimer(invokeFunc, wait);\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n      timerId = undefined;\n    }\n\n    // 执行函数,并将原函数的返回值result输出\n    function invokeFunc() {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n\n      lastArgs = args;\n      lastThis = this;\n\n      if (timerId) {\n        cancelTimer(timerId);\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        看上述代码：\n        1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n        2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n\n- **再者**，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n\n```\n// 代码二\n\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 只有当我们有 `lastArgs` 时才调用，这意味着`func'已经被调用过一次。\n      if (lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n\n```\n\n        上述代码：\n            1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n            2. options目前只支持传入leading参数，也就是immediate。\n\n- **再往后**，我们将 options 中的 trailing 加上，也就是这四部分\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF =\n      !wait &&\n      wait !== 0 &&\n      typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastArgs = lastThis = timerId = result = lastCallTime = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function remainingWait(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      const timeWaiting = wait - timeSinceLastCall;\n\n      return timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    function shouldInvoke(time) {\n      const timeSinceLastCall = time - lastCallTime;\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 1、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n        上述代码：\n            1.leading和trailing不能同时为false。\n\n其实可以在代码中加上判断同时为`false`时，默认`wait=0`，直接执行`window.requestAnimationFrame`部分,而不是定时器。\n\n- **最后结合 maxWait**,也就是将防抖和节流合并的关键。\n  - func (Function): 要防抖动的函数。\n  - [wait=0] (number): 需要延迟的毫秒数。\n  - [options=] (Object): 选项对象。\n  - [options.leading=false] (boolean): 指定在延迟开始前调用。\n  - [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n  - [options.trailing=true] (boolean): 指定在延迟结束后调用。\n\n首先，我们可以先来看 lodash throttle 部分源码:\n\n```\nimport debounce from './debounce.js'\nimport isObject from './isObject.js\nfunction throttle(func, wait, options) {\n  let leading = true\n  let trailing = true\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function')\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading\n    trailing = 'trailing' in options ? !!options.trailing : trailing\n  }\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    'maxWait': wait\n  })\n}\n\nexport default throttle\n```\n\n**其实就是将 wait 传入了 debounce 函数的`option.maxWait`中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。**\n\n```\nfunction debounce(func, wait, options) {\n    let timerId, // setTimeout 生成的定时器句柄\n      lastThis, // 保存上一次 this\n      lastArgs, // 保存上一次执行 debounced 的 arguments\n      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result\n      lastCallTime,\n      maxWait; // 上一次调用 debounce 的时间\n\n    let leading = false; // 判断是否立即执行，默认false\n    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true\n\n    /**\n     * 节流部分参数\n     **/\n    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\n    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n    wait = +wait || 0;\n\n    // 从options中获取是否立即执行\n    if (isObject(options)) {\n      leading = !!options.leading;\n      trailing = \"trailing\" in options ? !!options.trailing : trailing;\n\n      /**\n       * 节流部分参数\n       **/\n      maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n      // 如果 maxWait < wait，那 maxWait 就没有意义了\n    }\n\n    // 没传 wait 时调用 window.requestAnimationFrame()\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === \"function\";\n\n    // 取消debounce\n    function cancel() {\n      if (timerId !== undefined) {\n        cancelTimer(timerId);\n      }\n      lastInvokeTime = 0;\n      leading = false;\n      maxing = false;\n      trailing = true;\n      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;\n    }\n\n    // 开启定时器\n    function startTimer(pendingFunc, wait) {\n      if (useRAF) {\n        window.cancelAnimationFrame(timerId);\n        return window.requestAnimationFrame(pendingFunc);\n      }\n      return setTimeout(pendingFunc, wait);\n    }\n\n    // 定时器回调函数，表示定时结束后的操作\n    function timerExpired(wait) {\n      const time = Date.now();\n      // 1、是否需要执行\n      // 执行事件结束后的那次回调，否则重启定时器\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发\n      timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    // 计算仍需等待的时间\n    function remainingWait(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n      // 剩余等待时间\n      const timeWaiting = wait - timeSinceLastCall;\n\n      // 是否设置了最大等待时间\n      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n      // 否：返回剩余等待时间\n      return maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    // 这里时触发后仍调用函数\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // 这意味着`func'已经被调用过一次。\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    // 取消定时器\n    function cancelTimer(id) {\n      if (useRAF) {\n        return window.cancelAnimationFrame(id);\n      }\n      clearTimeout(id);\n    }\n\n    function invokeFunc(time) {\n      const args = lastArgs;\n      const thisArg = lastThis;\n      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents\n\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents\n      return result;\n    }\n    // 判断此时是否立即执行 func 函数\n    // lastCallTime === undefined 第一次调用时\n    // timeSinceLastCall >= wait 超过超时时间 wait，处理事件结束后的那次回调\n    // timeSinceLastCall < 0 当前时间 - 上次调用时间小于 0，即更改了系统时间\n    // maxing && timeSinceLastInvoke >= maxWait 超过最大等待时间\n    function shouldInvoke(time) {\n      // 当前时间距离上一次调用 debounce 的时间差\n      const timeSinceLastCall = time - lastCallTime;\n      // 当前时间距离上一次执行 func 的时间差\n      const timeSinceLastInvoke = time - lastInvokeTime;\n\n      // 上述 4 种情况返回 true\n      return (\n        lastCallTime === undefined ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    }\n\n    // 立即执行函数\n    function leadingEdge(time) {\n      // 1、设置上一次执行 func 的时间\n      lastInvokeTime = time;\n      // 2、开启定时器，为了事件结束后的那次回调\n      timerId = startTimer(timerExpired, wait);\n      // 3、如果配置了 leading 执行传入函数 func\n      // leading 来源自 !!options.leading\n      return leading ? invokeFunc(time) : result;\n    }\n\n    const debounced = function (...args) {\n      const time = Date.now(); // 获取当前时间\n      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数\n\n      lastArgs = args;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        // 判断是否立即执行\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        // 如果设置了最大等待时间，则立即执行 func\n        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n        // 2、执行 func，并返回结果\n        if (maxing) {\n          // 循环定时器中处理调用\n          timerId = startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = startTimer(timerExpired, wait);\n      }\n      return result;\n    };\n\n    debounced.cancel = cancel;\n    return debounced;\n}\n```\n\n    上述代码：\n        尽管代码有点长，但是实际上只是增加了maxWait。\n\n下面我们分析下 maxWait 新增的那部分代码。\n\n## 分析 maxWait 新增部分\n\n```\n// 1.定义变量\nlet maxWait; // 上一次调用 debounce 的时间\nlet lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关\nlet maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关\n\n\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n\n// 3.计算仍需等待的时间\nfunction remainingWait(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n  // 剩余等待时间\n  const timeWaiting = wait - timeSinceLastCall;\n\n  // 是否设置了最大等待时间\n  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值\n  // 否：返回剩余等待时间\n  return maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n}\n\n// 4.判断是否立即执行\nfunction shouldInvoke(time) {\n  // 当前时间距离上一次调用 debounce 的时间差\n  const timeSinceLastCall = time - lastCallTime;\n  // 当前时间距离上一次执行 func 的时间差\n  const timeSinceLastInvoke = time - lastInvokeTime;\n\n  // 上述 4 种情况返回 true\n  return (\n    lastCallTime === undefined ||\n    timeSinceLastCall >= wait ||\n    timeSinceLastCall < 0 ||\n    (maxing && timeSinceLastInvoke >= maxWait)\n  );\n}\n\n// 5.有maxing时，应该如何处理函数\nif (isInvoking) {\n    // 判断是否立即执行\n    if (timerId === undefined) {\n      return leadingEdge(lastCallTime);\n    }\n    // 如果设置了最大等待时间，则立即执行 func\n    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。\n    // 2、执行 func，并返回结果\n    if (maxing) {\n      // 循环定时器中处理调用\n      timerId = startTimer(timerExpired, wait);\n      return invokeFunc(lastCallTime);\n    }\n}\n\n```\n\n**1.新增变量**就不多说了。\n\n**2.从 options 中取出`maxWait`**:\n\n```\n// 2.从options中取出maxWait\nif (isObject(options)) {\n  maxing = \"maxWait\" in options; // options 中是否有 maxWait 属性，节流函数预留\n  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的\n  // 如果 maxWait < wait，那 maxWait 就没有意义了\n}\n```\n\n- 1.这里主要是将`maxing`,判断是否传了`maxWait`参数。\n- 2.如果未传则`maxWait`还是为初始定义的`undefined`。\n- 3.如果传入了`maxWait`，则重新赋值`Math.max(+options.maxWait || 0, wait)`。这里主要就是取`maxWait`和`wait`中的大值。\n\n**3.计算仍需等待的时间**\n\n```\nreturn maxing\n    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n    : timeWaiting;\n```\n\n首先判断是否节流（maxing）：\n\n1. 是=>取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。\n2. 否=>取剩余等待时间\n\n```\nmaxWait - (time - lastInvokeTime)\n```\n\n这里是不是就是节流中\n\n```\n// 下次触发 func 剩余时间\nconst remaining = wait - (now - previous);\n```\n\n**4.判断是否立即执行**  \nlodash 代码：\n\n```\nmaxing && (time - lastInvokeTime) >= maxWait\n```\n\n就往下执行。\n\n这里是不是就是节流中\n\n```\nif (remaining <= 0 || remaining > wait)\n```\n\n就往下执行。\n\n**5.有 maxing 时，应该如何处理函数**  \nlodash 代码：如果是节流函数就执行\n\n```\n// 循环定时器中处理调用\ntimerId = startTimer(timerExpired, wait);\nreturn invokeFunc(lastCallTime);\n```\n\n节流函数中：\n\n```\ntimeout = setTimeout(function () {\n    timeout = null;\n    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间\n    showResult(context, args);\n}, remaining);\n```\n\n总之，lodash`maxWait`部分，尽管参数名多，但实际上就是**节流函数中，判断剩余时间`remaining`。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。**\n\n## 对外 3 个方法\n\n```\ndebounced.cancel = cancel // 取消函数延迟执行\ndebounced.flush = flush // 立即执行 func\ndebounced.pending = pending // 检查当前是否在计时中\n```\n\n## 演示地址\n\n可以去[Github 仓库](https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash)查看演示代码\n\n## 跟着大佬学系列\n\n主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。\n\n后续会一直更新，希望各位看官不要吝啬手中的赞。\n\n❤️ **感谢各位的支持！！！**\n\n❤️ **如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！**\n\n❤️ **喜欢或者有所启发，欢迎 star！！！**\n\n## 参考\n\n- [深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理](https://www.muyiy.cn/blog/7/7.4.html)\n- [lodash_debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)\n- [lodash_throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)\n\n## 原文地址\n\n[【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n](https://github.com/yihan12/Blog/issues/3)\n","slug":"JavaScript/JavaScript学习笔记/【跟着大佬学JavaScript】之lodash防抖节流合并","published":1,"updated":"2023-08-14T04:10:32.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwyb00ehm32v9edp9iz1","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面已经对防抖和节流有了介绍，这篇主要看 lodash 是如何将防抖和节流合并成一个函数的。</p>\n<p>初衷是深入 lodash，学习它内部的好代码并应用，同时也加深节流防抖的理解。这里会先从防抖开始一步步往后，由简入繁，直到最后实现整个函数。</p>\n<p>这里纯粹自己的理解，以及看了很多篇优质文章，希望能加深对节流防抖的理解，如果有不同意见或者看法，欢迎大家评论。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>前面虽然已经介绍过防抖和节流原理，这里为了加深印象，再搬过来。</p>\n<blockquote>\n<p><strong>防抖的原理</strong>：在 wait 时间内，持续触发某个事件。第一种情况：如果某个事件触发 wait 秒内又触发了该事件，就应该以新的事件 wait 等待时间为准，wait 秒后再执行此事件；第二种情况：如果某个事件触发 wait 秒后，未再触发该事件，则在 wait 秒后直接执行该事件。</p>\n</blockquote>\n<p>通俗点说：定义 wait&#x3D;3000，持续点击按钮，前后点击间隔都在 3 秒内，则在最后一次点击按钮后，等待 3 秒再执行 func 方法。如果点击完按钮，3 秒后未再次点击按钮，则 3 秒后直接执行 func 方法。</p>\n<blockquote>\n<p><strong>节流的原理</strong>：持续触发某事件，每隔一段时间，只执行一次。</p>\n</blockquote>\n<p>通俗点说，3 秒内多次调用函数，但是在 3 秒间隔内只执行一次，第一次执行后 3 秒 无视后面所有的函数调用请求，也不会延长时间间隔。3 秒间隔结束后则开始执行新的函数调用请求，然后在这新的 3 秒内依旧无视后面所有的函数调用请求，以此类推。</p>\n<p>简单来说：每隔单位时间（ 3 秒），只执行一次。</p>\n<h2 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h2><h3 id=\"一、引入代码部分\"><a href=\"#一、引入代码部分\" class=\"headerlink\" title=\"一、引入代码部分\"></a>一、引入代码部分</h3><p>首先看源码最前方的引入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import isObject from &#x27;./isObject.js&#x27;</span><br><span class=\"line\">import root from &#x27;./.internal/root.js&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>isObject 方法，直接拿出来，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isObject(value) &#123;</span><br><span class=\"line\">    const type = typeof value;</span><br><span class=\"line\">    return value != null &amp;&amp; (type === &quot;object&quot; || type === &quot;function&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>root 的引入主要是 window。为了引出<code>window.requestAnimationFrame</code>。</p>\n<h3 id=\"二、requestAnimationFrame-代码\"><a href=\"#二、requestAnimationFrame-代码\" class=\"headerlink\" title=\"二、requestAnimationFrame 代码\"></a>二、requestAnimationFrame 代码</h3><p><code>window.requestAnimationFrame()</code>告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画，差不多 16ms 执行一次。</p>\n<p>lodash 这里使用<code>requestAnimationFrame</code>，主要是用户使用 debounce 函数未设置 wait 的情况下使用<code>requestAnimationFrame</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#x27;function&#x27;)</span><br><span class=\"line\">function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId)</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setTimeout(pendingFunc, wait)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function cancelTimer(id) &#123;</span><br><span class=\"line\">    if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clearTimeout(id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由代码<code>const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &#39;function&#39;)</code>不难看出,函数<strong>未传入 wait</strong>并且<strong>window.cancelAnimationFrame 函数存在</strong>这两种情况下操作<code>window.requestAnimationFrame</code></p>\n<h3 id=\"三、由简入繁输出防抖函数\"><a href=\"#三、由简入繁输出防抖函数\" class=\"headerlink\" title=\"三、由简入繁输出防抖函数\"></a>三、由简入繁输出防抖函数</h3><ul>\n<li><p><strong>首先</strong>，我们来看下<a href=\"https://www.lodashjs.com/docs/lodash.debounce#_debouncefunc-wait0-options\">lodash debounce API</a><br>这部分参数内容就直接摘抄在下方：<br>_ func (Function): 要防抖动的函数。<br>_ [wait&#x3D;0] (number): 需要延迟的毫秒数。<br>_ [options&#x3D;] (Object): 选项对象。<br>_ [options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。<br>_ [options.maxWait] (number): 设置 func 允许被延迟的最大值。<br>_ [options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</p>\n</li>\n<li><p><strong>然后</strong>，我们一般防抖函数，需要的参数是：<code>func</code>、<code>wait</code>、<code>immediate</code>这三个参数，对应 lodash，我们需要拿出这四个部分：</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n<li><p><strong>接着</strong>，按照这个形式，先写出最简防抖方法。也就是这两部分参数的代码</p>\n<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">function debounce(func, wait) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result; // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0; // 等待时间</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    // 1.未传wait时使用requestAnimationFrame</span><br><span class=\"line\">    // 2.直接使用定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      timerId = startTimer(invokeFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 执行函数,并将原函数的返回值result输出</span><br><span class=\"line\">    function invokeFunc() &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (timerId) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    看上述代码：\n    1. 多了未传wait情况，使用`window.requestAnimationFrame`。\n    2. 将定时器，绑定this，arguments、result和取消定时器等分函数拿了出来。\n</code></pre>\n<ul>\n<li><strong>再者</strong>，将 options 的 leading 加上。也就是 immediate 立即执行，组成完整的防抖函数。引入参数是下面这部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 代码二</span><br><span class=\"line\"></span><br><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 只有当我们有 `lastArgs` 时才调用，这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1. 增加trailingEdge、trailingEdge以及invokeFunc函数\n        2. options目前只支持传入leading参数，也就是immediate。\n</code></pre>\n<ul>\n<li><strong>再往后</strong>，我们将 options 中的 trailing 加上，也就是这四部分<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF =</span><br><span class=\"line\">      !wait &amp;&amp;</span><br><span class=\"line\">      wait !== 0 &amp;&amp;</span><br><span class=\"line\">      typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      return timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 1、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    上述代码：\n        1.leading和trailing不能同时为false。\n</code></pre>\n<p>其实可以在代码中加上判断同时为<code>false</code>时，默认<code>wait=0</code>，直接执行<code>window.requestAnimationFrame</code>部分,而不是定时器。</p>\n<ul>\n<li><strong>最后结合 maxWait</strong>,也就是将防抖和节流合并的关键。<ul>\n<li>func (Function): 要防抖动的函数。</li>\n<li>[wait&#x3D;0] (number): 需要延迟的毫秒数。</li>\n<li>[options&#x3D;] (Object): 选项对象。</li>\n<li>[options.leading&#x3D;false] (boolean): 指定在延迟开始前调用。</li>\n<li>[options.maxWait] (number): 设置 func 允许被延迟的最大值。</li>\n<li>[options.trailing&#x3D;true] (boolean): 指定在延迟结束后调用。</li>\n</ul>\n</li>\n</ul>\n<p>首先，我们可以先来看 lodash throttle 部分源码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import debounce from &#x27;./debounce.js&#x27;</span><br><span class=\"line\">import isObject from &#x27;./isObject.js</span><br><span class=\"line\">function throttle(func, wait, options) &#123;</span><br><span class=\"line\">  let leading = true</span><br><span class=\"line\">  let trailing = true</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class=\"line\">    throw new TypeError(&#x27;Expected a function&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isObject(options)) &#123;</span><br><span class=\"line\">    leading = &#x27;leading&#x27; in options ? !!options.leading : leading</span><br><span class=\"line\">    trailing = &#x27;trailing&#x27; in options ? !!options.trailing : trailing</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return debounce(func, wait, &#123;</span><br><span class=\"line\">    leading,</span><br><span class=\"line\">    trailing,</span><br><span class=\"line\">    &#x27;maxWait&#x27;: wait</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default throttle</span><br></pre></td></tr></table></figure>\n\n<p><strong>其实就是将 wait 传入了 debounce 函数的<code>option.maxWait</code>中。所以最后，我们只需要将之前的代码加上 maxWait 参数部分。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(func, wait, options) &#123;</span><br><span class=\"line\">    let timerId, // setTimeout 生成的定时器句柄</span><br><span class=\"line\">      lastThis, // 保存上一次 this</span><br><span class=\"line\">      lastArgs, // 保存上一次执行 debounced 的 arguments</span><br><span class=\"line\">      result, // 函数 func 执行后的返回值，多次触发但未满足执行 func 条件时，返回 result</span><br><span class=\"line\">      lastCallTime,</span><br><span class=\"line\">      maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\"></span><br><span class=\"line\">    let leading = false; // 判断是否立即执行，默认false</span><br><span class=\"line\">    let trailing = true; // 是否响应事件结束后的那次回调，即最后一次触发，false 时忽略,默认为true</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 节流部分参数</span><br><span class=\"line\">     **/</span><br><span class=\"line\">    let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">    let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\">    wait = +wait || 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从options中获取是否立即执行</span><br><span class=\"line\">    if (isObject(options)) &#123;</span><br><span class=\"line\">      leading = !!options.leading;</span><br><span class=\"line\">      trailing = &quot;trailing&quot; in options ? !!options.trailing : trailing;</span><br><span class=\"line\"></span><br><span class=\"line\">      /**</span><br><span class=\"line\">       * 节流部分参数</span><br><span class=\"line\">       **/</span><br><span class=\"line\">      maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">      // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 没传 wait 时调用 window.requestAnimationFrame()</span><br><span class=\"line\">    const useRAF = !wait &amp;&amp; wait !== 0 &amp;&amp; typeof window.requestAnimationFrame === &quot;function&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消debounce</span><br><span class=\"line\">    function cancel() &#123;</span><br><span class=\"line\">      if (timerId !== undefined) &#123;</span><br><span class=\"line\">        cancelTimer(timerId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastInvokeTime = 0;</span><br><span class=\"line\">      leading = false;</span><br><span class=\"line\">      maxing = false;</span><br><span class=\"line\">      trailing = true;</span><br><span class=\"line\">      lastArgs = lastThis = timerId = result = lastCallTime = maxWait = undefined;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开启定时器</span><br><span class=\"line\">    function startTimer(pendingFunc, wait) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        window.cancelAnimationFrame(timerId);</span><br><span class=\"line\">        return window.requestAnimationFrame(pendingFunc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return setTimeout(pendingFunc, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 定时器回调函数，表示定时结束后的操作</span><br><span class=\"line\">    function timerExpired(wait) &#123;</span><br><span class=\"line\">      const time = Date.now();</span><br><span class=\"line\">      // 1、是否需要执行</span><br><span class=\"line\">      // 执行事件结束后的那次回调，否则重启定时器</span><br><span class=\"line\">      if (shouldInvoke(time)) &#123;</span><br><span class=\"line\">        return trailingEdge(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      // 2、否则 计算剩余等待时间，重启定时器，保证下一次时延的末尾触发</span><br><span class=\"line\">      timerId = startTimer(timerExpired, remainingWait(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算仍需等待的时间</span><br><span class=\"line\">    function remainingWait(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">      // 剩余等待时间</span><br><span class=\"line\">      const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 是否设置了最大等待时间</span><br><span class=\"line\">      // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">      // 否：返回剩余等待时间</span><br><span class=\"line\">      return maxing</span><br><span class=\"line\">        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">        : timeWaiting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这里时触发后仍调用函数</span><br><span class=\"line\">    function trailingEdge(time) &#123;</span><br><span class=\"line\">      timerId = undefined;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 这意味着`func&#x27;已经被调用过一次。</span><br><span class=\"line\">      if (trailing &amp;&amp; lastArgs) &#123;</span><br><span class=\"line\">        return invokeFunc(time);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lastArgs = lastThis = undefined;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取消定时器</span><br><span class=\"line\">    function cancelTimer(id) &#123;</span><br><span class=\"line\">      if (useRAF) &#123;</span><br><span class=\"line\">        return window.cancelAnimationFrame(id);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      clearTimeout(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function invokeFunc(time) &#123;</span><br><span class=\"line\">      const args = lastArgs;</span><br><span class=\"line\">      const thisArg = lastThis;</span><br><span class=\"line\">      lastArgs = lastThis = undefined; // 清空当前函数指向的this,argumnents</span><br><span class=\"line\"></span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      result = func.apply(thisArg, args); // 绑定当前函数指向的this,argumnents</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 判断此时是否立即执行 func 函数</span><br><span class=\"line\">    // lastCallTime === undefined 第一次调用时</span><br><span class=\"line\">    // timeSinceLastCall &gt;= wait 超过超时时间 wait，处理事件结束后的那次回调</span><br><span class=\"line\">    // timeSinceLastCall &lt; 0 当前时间 - 上次调用时间小于 0，即更改了系统时间</span><br><span class=\"line\">    // maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait 超过最大等待时间</span><br><span class=\"line\">    function shouldInvoke(time) &#123;</span><br><span class=\"line\">      // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">      const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">      // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">      const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 上述 4 种情况返回 true</span><br><span class=\"line\">      return (</span><br><span class=\"line\">        lastCallTime === undefined ||</span><br><span class=\"line\">        timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">        timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">        (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 立即执行函数</span><br><span class=\"line\">    function leadingEdge(time) &#123;</span><br><span class=\"line\">      // 1、设置上一次执行 func 的时间</span><br><span class=\"line\">      lastInvokeTime = time;</span><br><span class=\"line\">      // 2、开启定时器，为了事件结束后的那次回调</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      // 3、如果配置了 leading 执行传入函数 func</span><br><span class=\"line\">      // leading 来源自 !!options.leading</span><br><span class=\"line\">      return leading ? invokeFunc(time) : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const debounced = function (...args) &#123;</span><br><span class=\"line\">      const time = Date.now(); // 获取当前时间</span><br><span class=\"line\">      const isInvoking = shouldInvoke(time); // 判断此时是否立即执行 func 函数</span><br><span class=\"line\"></span><br><span class=\"line\">      lastArgs = args;</span><br><span class=\"line\">      lastThis = this;</span><br><span class=\"line\">      lastCallTime = time;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (isInvoking) &#123;</span><br><span class=\"line\">        // 判断是否立即执行</span><br><span class=\"line\">        if (timerId === undefined) &#123;</span><br><span class=\"line\">          return leadingEdge(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">        // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">        // 2、执行 func，并返回结果</span><br><span class=\"line\">        if (maxing) &#123;</span><br><span class=\"line\">          // 循环定时器中处理调用</span><br><span class=\"line\">          timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">          return invokeFunc(lastCallTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (timerId === undefined) &#123;</span><br><span class=\"line\">        timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    debounced.cancel = cancel;</span><br><span class=\"line\">    return debounced;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>上述代码：\n    尽管代码有点长，但是实际上只是增加了maxWait。\n</code></pre>\n<p>下面我们分析下 maxWait 新增的那部分代码。</p>\n<h2 id=\"分析-maxWait-新增部分\"><a href=\"#分析-maxWait-新增部分\" class=\"headerlink\" title=\"分析 maxWait 新增部分\"></a>分析 maxWait 新增部分</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.定义变量</span><br><span class=\"line\">let maxWait; // 上一次调用 debounce 的时间</span><br><span class=\"line\">let lastInvokeTime = 0; // 上一次执行 func 的时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\">let maxing = false; // 是否有最大等待时间，配合 maxWait 多用于节流相关</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.计算仍需等待的时间</span><br><span class=\"line\">function remainingWait(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\">  // 剩余等待时间</span><br><span class=\"line\">  const timeWaiting = wait - timeSinceLastCall;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 是否设置了最大等待时间</span><br><span class=\"line\">  // 是（节流）：返回「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值</span><br><span class=\"line\">  // 否：返回剩余等待时间</span><br><span class=\"line\">  return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.判断是否立即执行</span><br><span class=\"line\">function shouldInvoke(time) &#123;</span><br><span class=\"line\">  // 当前时间距离上一次调用 debounce 的时间差</span><br><span class=\"line\">  const timeSinceLastCall = time - lastCallTime;</span><br><span class=\"line\">  // 当前时间距离上一次执行 func 的时间差</span><br><span class=\"line\">  const timeSinceLastInvoke = time - lastInvokeTime;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 上述 4 种情况返回 true</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    lastCallTime === undefined ||</span><br><span class=\"line\">    timeSinceLastCall &gt;= wait ||</span><br><span class=\"line\">    timeSinceLastCall &lt; 0 ||</span><br><span class=\"line\">    (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.有maxing时，应该如何处理函数</span><br><span class=\"line\">if (isInvoking) &#123;</span><br><span class=\"line\">    // 判断是否立即执行</span><br><span class=\"line\">    if (timerId === undefined) &#123;</span><br><span class=\"line\">      return leadingEdge(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果设置了最大等待时间，则立即执行 func</span><br><span class=\"line\">    // 1、开启定时器，到时间后触发 trailingEdge 这个函数。</span><br><span class=\"line\">    // 2、执行 func，并返回结果</span><br><span class=\"line\">    if (maxing) &#123;</span><br><span class=\"line\">      // 循环定时器中处理调用</span><br><span class=\"line\">      timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">      return invokeFunc(lastCallTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.新增变量</strong>就不多说了。</p>\n<p><strong>2.从 options 中取出<code>maxWait</code></strong>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 2.从options中取出maxWait</span><br><span class=\"line\">if (isObject(options)) &#123;</span><br><span class=\"line\">  maxing = &quot;maxWait&quot; in options; // options 中是否有 maxWait 属性，节流函数预留</span><br><span class=\"line\">  maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait; // maxWait 为设置的 maxWait 和 wait 中最大的</span><br><span class=\"line\">  // 如果 maxWait &lt; wait，那 maxWait 就没有意义了</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1.这里主要是将<code>maxing</code>,判断是否传了<code>maxWait</code>参数。</li>\n<li>2.如果未传则<code>maxWait</code>还是为初始定义的<code>undefined</code>。</li>\n<li>3.如果传入了<code>maxWait</code>，则重新赋值<code>Math.max(+options.maxWait || 0, wait)</code>。这里主要就是取<code>maxWait</code>和<code>wait</code>中的大值。</li>\n</ul>\n<p><strong>3.计算仍需等待的时间</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return maxing</span><br><span class=\"line\">    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)</span><br><span class=\"line\">    : timeWaiting;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断是否节流（maxing）：</p>\n<ol>\n<li>是&#x3D;&gt;取「剩余等待时间」和「距上次执行 func 的剩余等待时间」中的最小值。</li>\n<li>否&#x3D;&gt;取剩余等待时间</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxWait - (time - lastInvokeTime)</span><br></pre></td></tr></table></figure>\n\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 下次触发 func 剩余时间</span><br><span class=\"line\">const remaining = wait - (now - previous);</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.判断是否立即执行</strong><br>lodash 代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxing &amp;&amp; (time - lastInvokeTime) &gt;= maxWait</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p>这里是不是就是节流中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (remaining &lt;= 0 || remaining &gt; wait)</span><br></pre></td></tr></table></figure>\n\n<p>就往下执行。</p>\n<p><strong>5.有 maxing 时，应该如何处理函数</strong><br>lodash 代码：如果是节流函数就执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 循环定时器中处理调用</span><br><span class=\"line\">timerId = startTimer(timerExpired, wait);</span><br><span class=\"line\">return invokeFunc(lastCallTime);</span><br></pre></td></tr></table></figure>\n\n<p>节流函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timeout = setTimeout(function () &#123;</span><br><span class=\"line\">    timeout = null;</span><br><span class=\"line\">    previous = options.leading === false ? 0 : getNow(); // 这里是将previous重新赋值当前时间</span><br><span class=\"line\">    showResult(context, args);</span><br><span class=\"line\">&#125;, remaining);</span><br></pre></td></tr></table></figure>\n\n<p>总之，lodash<code>maxWait</code>部分，尽管参数名多，但实际上就是<strong>节流函数中，判断剩余时间<code>remaining</code>。不需要等待，就直接立即执行，否则就到剩余时间就执行一次，依次类推。</strong></p>\n<h2 id=\"对外-3-个方法\"><a href=\"#对外-3-个方法\" class=\"headerlink\" title=\"对外 3 个方法\"></a>对外 3 个方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounced.cancel = cancel // 取消函数延迟执行</span><br><span class=\"line\">debounced.flush = flush // 立即执行 func</span><br><span class=\"line\">debounced.pending = pending // 检查当前是否在计时中</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"演示地址\"><a href=\"#演示地址\" class=\"headerlink\" title=\"演示地址\"></a>演示地址</h2><p>可以去<a href=\"https://github.com/yihan12/Blog/tree/main/demos/debounce_lodash\">Github 仓库</a>查看演示代码</p>\n<h2 id=\"跟着大佬学系列\"><a href=\"#跟着大佬学系列\" class=\"headerlink\" title=\"跟着大佬学系列\"></a>跟着大佬学系列</h2><p>主要是日常对每个进阶知识点的摸透，跟着大佬一起去深入了解 JavaScript 的语言艺术。</p>\n<p>后续会一直更新，希望各位看官不要吝啬手中的赞。</p>\n<p>❤️ <strong>感谢各位的支持！！！</strong></p>\n<p>❤️ <strong>如果有错误或者不严谨的地方，请务必给予指正，十分感谢！！！</strong></p>\n<p>❤️ <strong>喜欢或者有所启发，欢迎 star！！！</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.muyiy.cn/blog/7/7.4.html\">深入篇阿里 P6 必会 Lodash 防抖节流函数实现原理</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">lodash_debounce.js</a></li>\n<li><a href=\"https://github.com/lodash/lodash/blob/master/throttle.js\">lodash_throttle.js</a></li>\n</ul>\n<h2 id=\"原文地址\"><a href=\"#原文地址\" class=\"headerlink\" title=\"原文地址\"></a>原文地址</h2><p><a href=\"https://github.com/yihan12/Blog/issues/3\">【跟着大佬学 JavaScript】之 lodash 防抖节流合并\n</a></p>\n"},{"title":"JavaScript面试汇总","date":"2023-08-17T01:11:31.777Z","_content":"\n### 前言\n\n日常 js 面试题积累汇总。持续更新！\n\n### 1.JavaScript 的基本数据类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbel`（ES6 新增）、`BigInt`(ES10 新增)  \nObject 是 JavaScript 中所有对象的父对象  \n数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、和`String`  \n其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`  \n[js 数据类型](https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md)\n\n</p>\n</details>\n\n---\n\n### 2.JavaScript 的引用类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `Object `\n- `Function`\n- `Array`\n- `Date`\n- `RegExp`\n</p>\n</details>\n\n---\n\n### 3.Javascript 基本数据类型和引用类型的特点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.基本数据类型：值不可变；数据存放在栈区。  \n2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。\n\n</p>\n</details>\n\n---\n\n### 4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.`typeof`：不能判断 null 和区分 Array/Date/RegExp\n- 2.`instanceof`：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；\n- 3.`constructor`：无法检测 null 和 undefined；未必准确\n- 4.`Object.prototype.toString.call()`：无；全能方法；\n</p>\n</details>\n\n---\n\n### 5.JavaScript 基本数据类型和非基本数据类型的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.目前 JS 中有 6 种基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`和`Symbel`（ES6 新增）。还有一种复杂数据类型----`Object`,`Object`本质上是由一组无序的名值对组成的，`Object`、`Fuction`、`Array`则属于引用类型。\n- 2.基本数据类型是不可变的，而非基本数据类型是可变的。\n- 3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。\n- 4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。\n- 5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。\n</p>\n</details>\n\n---\n\n### 6.instanceof 操作符\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n判断对象属于某一个类，回去查找对象的 constructor 的 prototype\n\n</p>\n</details>\n\n---\n\n### 7.new 操作符的作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 新生了一个对象\n- 链接到原型(该对象继承该函数的原型，更改了原型链的指向)\n- 绑定 this\n- 返回对象\n\n```javascript\nfunction newCreate() {\n  // 创建一个空白对象\n  let obj = new Object()\n  // 获得构造函数\n  let Con = [].shift.call(arguments)\n  // 链接到原型\n  obj.__proto__ = Con.prototype\n  // 绑定this,执行构造函数\n  let result = Con.apply(obj, arguments)\n  // 确保new出来的是个对象\n  return typeof result === 'object' ? result : obj\n}\n```\n\n</p>\n</details>\n\n---\n\n### 8.作用域和作用域链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[静态作用域与动态作用域](https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md)\n\n#### 1.作用域\n\n- 种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。\n- 概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。\n- 使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。\n\n#### 2.作用域链\n\n- 一个变量的访问规则的链式操作\n- 可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量\n- 当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined\n</p>\n</details>\n\n---\n\n### 9.闭包\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.特点：\n\n- 内层作用域可以访问外层作用域的变量\n- 闭包就是可以读取其他函数内部变量的函数\n- 函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包\n- 闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量\n\n  2.优点\n\n- 使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值\n- 可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装\n- 解决 var 声明的循环语句变量无法长久保存的问题\n\n  3.缺点\n\n- 滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null\n- 由于函数闭包的变量都保存在内存中，会导致内存消耗大\n</p>\n</details>\n\n---\n\n### 10.null 和 undefined 的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`undefined`: 表示缺少值，即此处应该有值，但没有定义。\n\n- 声明一个变量,这个变量的值就自动被赋予了`undefined`;\n\n```javascript\nvar a\n// undefined\n```\n\n- 调用函数时，应该被提供的参数没有提供，该参数等于`undefined`;\n\n- 对象没有赋值的属性，该属性为`undefined`;\n\n- 函数没有返回值，默认返回`undefined`;\n\n`null`：表示没有对象，即此处不应该有值。\n\n- 作为函数的参数，表示该函数的参数不是对象;\n- 作为对象原型链的终点。\n\n其他方面的区别：  \n（1）数据类型的区别\n\n```javascript\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // Object\n```\n\n**注意：这是 JS 设计的一个失误**\n\n（2）转为数值的区别\n\n```javascript\nlet num1 = 5 + null // 5\nlet num2 = 5 + undefined // NaN\n```\n\n（3)`null !== undefined`\n\n```javascript\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\n```\n\n</p>\n</details>\n\n---\n\n### 11.原型和原型链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[原型和原型链](https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md)\n\n</p>\n</details>\n\n---\n\n### 12.var，let 和 const 有什么区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n  **变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n  `let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n</p>\n</details>\n\n---\n\n### 13.`call()`、`apply()`、`bind()`的区别和作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。\n\n区别：（接受参数的方式不同、改变 this 指向后的处理不同）  \n`call()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n`apply()`的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.apply(obj, [varl, var2， var3])\n```\n\n`bind()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n</p>\n</details>\n\n---\n\n### 14.`cookie`、`localStorage`、`sessionStorage`的异同点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n|      分类      |                                生命周期                                 |                存储容量                |                  储存位置                  |                 应用场景                 |   浏览器兼容性   |\n| :------------: | :---------------------------------------------------------------------: | :------------------------------------: | :----------------------------------------: | :--------------------------------------: | :--------------: |\n|     cookie     | 默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效) |                  4kb                   |        保存在客户端每次请求都会带上        |     用户的部分不重要信息或者登录信息     | 兼容性完全没问题 |\n|  localStorage  |                       理论上永久有效,除非主动清除                       | 4.98M(不同浏览器情况不同，safari2.49M) | 保存在客户端，不与服务端交互，节省网络流量 | 适合持久化缓存数据，比如页面的偏好配置等 | IE8+以上的浏览器 |\n| sessionStorage |           仅在当前网页会话下有效，关闭页面或浏览器后会被清除            |       4.98M(部分浏览器没有限制)        | 保存在客户端，不与服务端交互，节省网络流量 |          适合一次性临时数据缓存          | IE8+以上的浏览器 |\n\n注意点：\n\n- `localStorage`写入的时候如果超出容量会报错，但之前保存的数据不会丢失。\n- `localStorage`存储量快要满的时候，`getItem`的性能会急剧下降。\n- `webStorage(localStorage、sessionStorage)`在保存复杂数据类型时，较为依赖`JSON.stringify()`在移动端性能问题比较明显。\n</p>\n</details>\n\n---\n\n### 15.HTTP、HTTPS 有什么联系，端口号是多少？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。\n\n</p>\n</details>\n\n---\n\n### 16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。  \n在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL/TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。\n\n</p>\n</details>\n\n---\n\n### 17.HTTP/2\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。  \n> 提供更多的加密支持。  \n> 使用多路线路，允许多个消息在一个连接上同时交差。  \n> 增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。\n\n</p>\n</details>\n\n---\n\n### 18.HTTP 常见状态码\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。\n- 200 OK 表示正常返回信息。\n- 201 Created 表示请求成功并且服务器创建了新资源。\n- 202 Accepted 表示服务器已接受请求，但尚未处理。\n- 301 Moved Permanently 表示请求的网页已永久移动到新位置。\n- 302 Found 表示临时重定向。\n- 303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。\n- 304 Not Modified 表示自从上次请求后，请求网页未修改。\n- 400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。\n- 401 Unauthorized 表示请求未授权。\n- 403 Forbidden 表示禁止访问。\n- 404 Not Found 表示找不到如何与 URI 匹配的资源。\n- 500 Internet Server error 表示最常见的服务端的错误。\n- 503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。\n\n</p>\n</details>\n\n---\n\n### 19.无状态协议？如何克服无状态协议缺陷？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。  \n克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。\n\n</p>\n</details>\n\n---\n\n### 20.HTTP 请求报文和响应报文包括哪些部分？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n请求报文：\n\n- 请求行，包含请求方法、URI、HTTP 版本信息。\n- 请求首部字段。\n- 请求内容实体。\n\n响应报文：\n\n- 状态行，包括 HTTP 版本，状态码，状态码的原因短语。\n- 响应首部字段。\n- 响应内容实体。\n\n</p>\n</details>\n\n---\n\n### 21.HTTP 请求方式\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。\n- POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。\n- PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。\n- HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。\n- OPTIONS:查询相应 URI 支持的 HTTP 方法。\n\n</p>\n</details>\n\n---\n\n### 22.HTTP 首部字段包括哪些类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 通用首部字段(请求报文和响应报文都会使用的首部字段)。\n\n  > `Date`:创建报文的时间。  \n  > `Connection`:连接的管理。  \n  > `Cache-Control`:缓存机制。  \n  > `Transfer-Encoding`:报文主体的传输编码方式。\n\n- 请求首部字段（请求报文会使用的首部字段）。\n\n  > `Host`: 请求资源所在的服务器。  \n  > `Accept`: 可处理的媒体类型。  \n  > `Accept-Charset`: 可接受的字符集。  \n  > `Accept-Encoding`: 可接受的内容编码。  \n  > `Accept-Language`: 可接受的自然语言。\n\n- 响应首部字段（响应报文会使用的字段）。\n\n  > `Accept-Ranges`: 可接受的字节范围。  \n  > `Location`: 令客户端重新定向到的 URL。\n\n- 实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。\n  > `Allow`: 资源可支持的 HTTP 方法。  \n  > `Content-Type`: 实体主体的类型。  \n  > `Content-Encoding`: 实体主体使用的编码方式。  \n  > `Content-Language`: 实体主体的自然语言。  \n  > `Content-Length`: 实体主体的字节数。\n  > `Content-Range`: 实体主体的位置范围，一般用于发出部分请求时使用。\n\n</p>\n</details>\n\n---\n\n### 22.`GET`和`POST`的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `GET`一般用于获取/查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而`POST`一般用于更新资源信息，会修改服务器上的资源信息。\n- `GET`请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；`POST`把提交的数据放在 HTTP 的 requset body 中。\n- `GET`方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲`POST`是没有大小限制的。\n- 在 ASP 中，服务端获取`GET`请求参数用 Requset.QueryString;获取`POST`的请求参数用 Requset.Form。\n- `POST`比`GET`安全性更高：`GET`提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。\n\n</p>\n</details>\n\n---\n\n### 23.网站性能优化\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- [x] [网站性能优化实战](https://juejin.cn/post/6844903613790175240)\n- [x] [网站性能优化实战(二)](https://imweb.io/topic/5b4d417eee0c3b0779df96d9)\n- [x] [网站性能优化实战篇](https://segmentfault.com/a/1190000021098540)\n\n基本优化：\n\n- 图片压缩合并；\n- 代码精简、混淆；\n- 减少`iframe`使用；\n- 避免图片`src`为空；\n- 减少`HTTP`请求数；\n- 避免重定向；\n- 样式表放页头、脚本放底部；\n\n网站性能优化总结：  \n(一)网络传输性能优化————重定向——>拉取缓存——>DNS 查询——>建立 TCP 链接——>发起请求——>处理 HTML 元素——>元素加载完成\n\n- 浏览器缓存。\n- 资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！\n- 图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;\n- 网络传输性能检查工具————Page Speed。\n- 使用 CDN。\n\n(二)页面性能优化————处理 HTML 标记并构建 DOM 树——>处理 CSS 标记并构建 CSSOM 树——>将 DOM 和 CSSOM 合并成一个 render 渲染树——>根据渲染树来布局，以计算每个节点的几何信息——>将每个节点绘制在屏幕上\n\n- DOM 渲染层与 GPU 硬件加速。\n- 降低重绘和重排的频率和成本。\n\n总结：\n\n> CSS 读写分离：不用 js 操作元素样式。  \n> 通过切换 class 或使用 style.csstext 属性批量操作元素样式。  \n> DOM 元素离线更新。  \n> 将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。  \n> 压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。  \n> 图片在渲染前指定大小。  \n> 降低重绘和重排的频率和成本。\n\n</p>\n</details>\n\n---\n","source":"_posts/JavaScript/JavaScript面试/JavaScript面试.md","raw":"---\ntitle: JavaScript面试汇总\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, JavaScript面试]\n---\n\n### 前言\n\n日常 js 面试题积累汇总。持续更新！\n\n### 1.JavaScript 的基本数据类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbel`（ES6 新增）、`BigInt`(ES10 新增)  \nObject 是 JavaScript 中所有对象的父对象  \n数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、和`String`  \n其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`  \n[js 数据类型](https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md)\n\n</p>\n</details>\n\n---\n\n### 2.JavaScript 的引用类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `Object `\n- `Function`\n- `Array`\n- `Date`\n- `RegExp`\n</p>\n</details>\n\n---\n\n### 3.Javascript 基本数据类型和引用类型的特点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.基本数据类型：值不可变；数据存放在栈区。  \n2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。\n\n</p>\n</details>\n\n---\n\n### 4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.`typeof`：不能判断 null 和区分 Array/Date/RegExp\n- 2.`instanceof`：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；\n- 3.`constructor`：无法检测 null 和 undefined；未必准确\n- 4.`Object.prototype.toString.call()`：无；全能方法；\n</p>\n</details>\n\n---\n\n### 5.JavaScript 基本数据类型和非基本数据类型的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 1.目前 JS 中有 6 种基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`、`String`和`Symbel`（ES6 新增）。还有一种复杂数据类型----`Object`,`Object`本质上是由一组无序的名值对组成的，`Object`、`Fuction`、`Array`则属于引用类型。\n- 2.基本数据类型是不可变的，而非基本数据类型是可变的。\n- 3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。\n- 4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。\n- 5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。\n</p>\n</details>\n\n---\n\n### 6.instanceof 操作符\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n判断对象属于某一个类，回去查找对象的 constructor 的 prototype\n\n</p>\n</details>\n\n---\n\n### 7.new 操作符的作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 新生了一个对象\n- 链接到原型(该对象继承该函数的原型，更改了原型链的指向)\n- 绑定 this\n- 返回对象\n\n```javascript\nfunction newCreate() {\n  // 创建一个空白对象\n  let obj = new Object()\n  // 获得构造函数\n  let Con = [].shift.call(arguments)\n  // 链接到原型\n  obj.__proto__ = Con.prototype\n  // 绑定this,执行构造函数\n  let result = Con.apply(obj, arguments)\n  // 确保new出来的是个对象\n  return typeof result === 'object' ? result : obj\n}\n```\n\n</p>\n</details>\n\n---\n\n### 8.作用域和作用域链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[静态作用域与动态作用域](https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md)\n\n#### 1.作用域\n\n- 种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。\n- 概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。\n- 使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。\n\n#### 2.作用域链\n\n- 一个变量的访问规则的链式操作\n- 可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量\n- 当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined\n</p>\n</details>\n\n---\n\n### 9.闭包\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n1.特点：\n\n- 内层作用域可以访问外层作用域的变量\n- 闭包就是可以读取其他函数内部变量的函数\n- 函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包\n- 闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量\n\n  2.优点\n\n- 使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值\n- 可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装\n- 解决 var 声明的循环语句变量无法长久保存的问题\n\n  3.缺点\n\n- 滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null\n- 由于函数闭包的变量都保存在内存中，会导致内存消耗大\n</p>\n</details>\n\n---\n\n### 10.null 和 undefined 的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n`undefined`: 表示缺少值，即此处应该有值，但没有定义。\n\n- 声明一个变量,这个变量的值就自动被赋予了`undefined`;\n\n```javascript\nvar a\n// undefined\n```\n\n- 调用函数时，应该被提供的参数没有提供，该参数等于`undefined`;\n\n- 对象没有赋值的属性，该属性为`undefined`;\n\n- 函数没有返回值，默认返回`undefined`;\n\n`null`：表示没有对象，即此处不应该有值。\n\n- 作为函数的参数，表示该函数的参数不是对象;\n- 作为对象原型链的终点。\n\n其他方面的区别：  \n（1）数据类型的区别\n\n```javascript\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // Object\n```\n\n**注意：这是 JS 设计的一个失误**\n\n（2）转为数值的区别\n\n```javascript\nlet num1 = 5 + null // 5\nlet num2 = 5 + undefined // NaN\n```\n\n（3)`null !== undefined`\n\n```javascript\nconsole.log(null == undefined) // true\nconsole.log(null === undefined) // false\n```\n\n</p>\n</details>\n\n---\n\n### 11.原型和原型链\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n[原型和原型链](https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md)\n\n</p>\n</details>\n\n---\n\n### 12.var，let 和 const 有什么区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- **相同点**：`var`,`let`,`const`声明的变量，是不能被`delete`的;\n- **区别**：\n  **变量提升**：`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；  \n  `let`,`const`不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。\n\n**暂时性死区**：`var`不存在暂时性死区；`let`、`const`存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。\n\n**重复声明**：`var`允许重复声明；`lat`、`const`在同一作用域不允许重复声明。\n\n**修改声明的变量**：`var`和`let`可以修改声明的变量；`const`声明一个只读常量，一旦声明，常量的值就不能改变。\n\n</p>\n</details>\n\n---\n\n### 13.`call()`、`apply()`、`bind()`的区别和作用\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。\n\n区别：（接受参数的方式不同、改变 this 指向后的处理不同）  \n`call()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n`apply()`的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。\n\n```javascript\nFunction.apply(obj, [varl, var2， var3])\n```\n\n`bind()`从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。\n\n```javascript\nFunction.call(obj, varl, var2， var3)\n```\n\n</p>\n</details>\n\n---\n\n### 14.`cookie`、`localStorage`、`sessionStorage`的异同点\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n|      分类      |                                生命周期                                 |                存储容量                |                  储存位置                  |                 应用场景                 |   浏览器兼容性   |\n| :------------: | :---------------------------------------------------------------------: | :------------------------------------: | :----------------------------------------: | :--------------------------------------: | :--------------: |\n|     cookie     | 默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效) |                  4kb                   |        保存在客户端每次请求都会带上        |     用户的部分不重要信息或者登录信息     | 兼容性完全没问题 |\n|  localStorage  |                       理论上永久有效,除非主动清除                       | 4.98M(不同浏览器情况不同，safari2.49M) | 保存在客户端，不与服务端交互，节省网络流量 | 适合持久化缓存数据，比如页面的偏好配置等 | IE8+以上的浏览器 |\n| sessionStorage |           仅在当前网页会话下有效，关闭页面或浏览器后会被清除            |       4.98M(部分浏览器没有限制)        | 保存在客户端，不与服务端交互，节省网络流量 |          适合一次性临时数据缓存          | IE8+以上的浏览器 |\n\n注意点：\n\n- `localStorage`写入的时候如果超出容量会报错，但之前保存的数据不会丢失。\n- `localStorage`存储量快要满的时候，`getItem`的性能会急剧下降。\n- `webStorage(localStorage、sessionStorage)`在保存复杂数据类型时，较为依赖`JSON.stringify()`在移动端性能问题比较明显。\n</p>\n</details>\n\n---\n\n### 15.HTTP、HTTPS 有什么联系，端口号是多少？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。\n\n</p>\n</details>\n\n---\n\n### 16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\nHTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。  \n在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL/TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。\n\n</p>\n</details>\n\n---\n\n### 17.HTTP/2\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n> 引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。  \n> 提供更多的加密支持。  \n> 使用多路线路，允许多个消息在一个连接上同时交差。  \n> 增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。\n\n</p>\n</details>\n\n---\n\n### 18.HTTP 常见状态码\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。\n- 200 OK 表示正常返回信息。\n- 201 Created 表示请求成功并且服务器创建了新资源。\n- 202 Accepted 表示服务器已接受请求，但尚未处理。\n- 301 Moved Permanently 表示请求的网页已永久移动到新位置。\n- 302 Found 表示临时重定向。\n- 303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。\n- 304 Not Modified 表示自从上次请求后，请求网页未修改。\n- 400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。\n- 401 Unauthorized 表示请求未授权。\n- 403 Forbidden 表示禁止访问。\n- 404 Not Found 表示找不到如何与 URI 匹配的资源。\n- 500 Internet Server error 表示最常见的服务端的错误。\n- 503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。\n\n</p>\n</details>\n\n---\n\n### 19.无状态协议？如何克服无状态协议缺陷？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。  \n克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。\n\n</p>\n</details>\n\n---\n\n### 20.HTTP 请求报文和响应报文包括哪些部分？\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n请求报文：\n\n- 请求行，包含请求方法、URI、HTTP 版本信息。\n- 请求首部字段。\n- 请求内容实体。\n\n响应报文：\n\n- 状态行，包括 HTTP 版本，状态码，状态码的原因短语。\n- 响应首部字段。\n- 响应内容实体。\n\n</p>\n</details>\n\n---\n\n### 21.HTTP 请求方式\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。\n- POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。\n- PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。\n- HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。\n- OPTIONS:查询相应 URI 支持的 HTTP 方法。\n\n</p>\n</details>\n\n---\n\n### 22.HTTP 首部字段包括哪些类型\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- 通用首部字段(请求报文和响应报文都会使用的首部字段)。\n\n  > `Date`:创建报文的时间。  \n  > `Connection`:连接的管理。  \n  > `Cache-Control`:缓存机制。  \n  > `Transfer-Encoding`:报文主体的传输编码方式。\n\n- 请求首部字段（请求报文会使用的首部字段）。\n\n  > `Host`: 请求资源所在的服务器。  \n  > `Accept`: 可处理的媒体类型。  \n  > `Accept-Charset`: 可接受的字符集。  \n  > `Accept-Encoding`: 可接受的内容编码。  \n  > `Accept-Language`: 可接受的自然语言。\n\n- 响应首部字段（响应报文会使用的字段）。\n\n  > `Accept-Ranges`: 可接受的字节范围。  \n  > `Location`: 令客户端重新定向到的 URL。\n\n- 实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。\n  > `Allow`: 资源可支持的 HTTP 方法。  \n  > `Content-Type`: 实体主体的类型。  \n  > `Content-Encoding`: 实体主体使用的编码方式。  \n  > `Content-Language`: 实体主体的自然语言。  \n  > `Content-Length`: 实体主体的字节数。\n  > `Content-Range`: 实体主体的位置范围，一般用于发出部分请求时使用。\n\n</p>\n</details>\n\n---\n\n### 22.`GET`和`POST`的区别\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- `GET`一般用于获取/查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而`POST`一般用于更新资源信息，会修改服务器上的资源信息。\n- `GET`请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；`POST`把提交的数据放在 HTTP 的 requset body 中。\n- `GET`方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲`POST`是没有大小限制的。\n- 在 ASP 中，服务端获取`GET`请求参数用 Requset.QueryString;获取`POST`的请求参数用 Requset.Form。\n- `POST`比`GET`安全性更高：`GET`提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。\n\n</p>\n</details>\n\n---\n\n### 23.网站性能优化\n\n<details><summary><b></b></summary>\n<p>\n\n#### 答案:\n\n- [x] [网站性能优化实战](https://juejin.cn/post/6844903613790175240)\n- [x] [网站性能优化实战(二)](https://imweb.io/topic/5b4d417eee0c3b0779df96d9)\n- [x] [网站性能优化实战篇](https://segmentfault.com/a/1190000021098540)\n\n基本优化：\n\n- 图片压缩合并；\n- 代码精简、混淆；\n- 减少`iframe`使用；\n- 避免图片`src`为空；\n- 减少`HTTP`请求数；\n- 避免重定向；\n- 样式表放页头、脚本放底部；\n\n网站性能优化总结：  \n(一)网络传输性能优化————重定向——>拉取缓存——>DNS 查询——>建立 TCP 链接——>发起请求——>处理 HTML 元素——>元素加载完成\n\n- 浏览器缓存。\n- 资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！\n- 图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;\n- 网络传输性能检查工具————Page Speed。\n- 使用 CDN。\n\n(二)页面性能优化————处理 HTML 标记并构建 DOM 树——>处理 CSS 标记并构建 CSSOM 树——>将 DOM 和 CSSOM 合并成一个 render 渲染树——>根据渲染树来布局，以计算每个节点的几何信息——>将每个节点绘制在屏幕上\n\n- DOM 渲染层与 GPU 硬件加速。\n- 降低重绘和重排的频率和成本。\n\n总结：\n\n> CSS 读写分离：不用 js 操作元素样式。  \n> 通过切换 class 或使用 style.csstext 属性批量操作元素样式。  \n> DOM 元素离线更新。  \n> 将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。  \n> 压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。  \n> 图片在渲染前指定大小。  \n> 降低重绘和重排的频率和成本。\n\n</p>\n</details>\n\n---\n","slug":"JavaScript/JavaScript面试/JavaScript面试","published":1,"updated":"2023-08-17T01:20:30.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39jlwyc00ekm32vgq1o10bv","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常 js 面试题积累汇总。持续更新！</p>\n<h3 id=\"1-JavaScript-的基本数据类型\"><a href=\"#1-JavaScript-的基本数据类型\" class=\"headerlink\" title=\"1.JavaScript 的基本数据类型\"></a>1.JavaScript 的基本数据类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbel</code>（ES6 新增）、<code>BigInt</code>(ES10 新增)<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、和<code>String</code><br>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code><br><a href=\"https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md\">js 数据类型</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"2-JavaScript-的引用类型\"><a href=\"#2-JavaScript-的引用类型\" class=\"headerlink\" title=\"2.JavaScript 的引用类型\"></a>2.JavaScript 的引用类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>Object </code></li>\n<li><code>Function</code></li>\n<li><code>Array</code></li>\n<li><code>Date</code></li>\n<li><code>RegExp</code></p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"3-Javascript-基本数据类型和引用类型的特点\"><a href=\"#3-Javascript-基本数据类型和引用类型的特点\" class=\"headerlink\" title=\"3.Javascript 基本数据类型和引用类型的特点\"></a>3.Javascript 基本数据类型和引用类型的特点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.基本数据类型：值不可变；数据存放在栈区。<br>2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\"><a href=\"#4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\" class=\"headerlink\" title=\"4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\"></a>4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.<code>typeof</code>：不能判断 null 和区分 Array&#x2F;Date&#x2F;RegExp</li>\n<li>2.<code>instanceof</code>：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；</li>\n<li>3.<code>constructor</code>：无法检测 null 和 undefined；未必准确</li>\n<li>4.<code>Object.prototype.toString.call()</code>：无；全能方法；</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"5-JavaScript-基本数据类型和非基本数据类型的区别\"><a href=\"#5-JavaScript-基本数据类型和非基本数据类型的区别\" class=\"headerlink\" title=\"5.JavaScript 基本数据类型和非基本数据类型的区别\"></a>5.JavaScript 基本数据类型和非基本数据类型的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.目前 JS 中有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbel</code>（ES6 新增）。还有一种复杂数据类型—-<code>Object</code>,<code>Object</code>本质上是由一组无序的名值对组成的，<code>Object</code>、<code>Fuction</code>、<code>Array</code>则属于引用类型。</li>\n<li>2.基本数据类型是不可变的，而非基本数据类型是可变的。</li>\n<li>3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。</li>\n<li>4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。</li>\n<li>5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"6-instanceof-操作符\"><a href=\"#6-instanceof-操作符\" class=\"headerlink\" title=\"6.instanceof 操作符\"></a>6.instanceof 操作符</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-5\"><a href=\"#答案-5\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>判断对象属于某一个类，回去查找对象的 constructor 的 prototype</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"7-new-操作符的作用\"><a href=\"#7-new-操作符的作用\" class=\"headerlink\" title=\"7.new 操作符的作用\"></a>7.new 操作符的作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-6\"><a href=\"#答案-6\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>新生了一个对象</li>\n<li>链接到原型(该对象继承该函数的原型，更改了原型链的指向)</li>\n<li>绑定 this</li>\n<li>返回对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">newCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个空白对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()</span><br><span class=\"line\">  <span class=\"comment\">// 获得构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">Con</span> = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 链接到原型</span></span><br><span class=\"line\">  obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Con</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\">  <span class=\"comment\">// 绑定this,执行构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title class_\">Con</span>.<span class=\"title function_\">apply</span>(obj, <span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 确保new出来的是个对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"8-作用域和作用域链\"><a href=\"#8-作用域和作用域链\" class=\"headerlink\" title=\"8.作用域和作用域链\"></a>8.作用域和作用域链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-7\"><a href=\"#答案-7\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md\">静态作用域与动态作用域</a></p>\n<h4 id=\"1-作用域\"><a href=\"#1-作用域\" class=\"headerlink\" title=\"1.作用域\"></a>1.作用域</h4><ul>\n<li>种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。</li>\n<li>概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。</li>\n<li>使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。</li>\n</ul>\n<h4 id=\"2-作用域链\"><a href=\"#2-作用域链\" class=\"headerlink\" title=\"2.作用域链\"></a>2.作用域链</h4><ul>\n<li>一个变量的访问规则的链式操作</li>\n<li>可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量</li>\n<li>当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"9-闭包\"><a href=\"#9-闭包\" class=\"headerlink\" title=\"9.闭包\"></a>9.闭包</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-8\"><a href=\"#答案-8\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.特点：</p>\n<ul>\n<li><p>内层作用域可以访问外层作用域的变量</p>\n</li>\n<li><p>闭包就是可以读取其他函数内部变量的函数</p>\n</li>\n<li><p>函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包</p>\n</li>\n<li><p>闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量</p>\n<p>2.优点</p>\n</li>\n<li><p>使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值</p>\n</li>\n<li><p>可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装</p>\n</li>\n<li><p>解决 var 声明的循环语句变量无法长久保存的问题</p>\n<p>3.缺点</p>\n</li>\n<li><p>滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null</p>\n</li>\n<li><p>由于函数闭包的变量都保存在内存中，会导致内存消耗大</p>\n</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"10-null-和-undefined-的区别\"><a href=\"#10-null-和-undefined-的区别\" class=\"headerlink\" title=\"10.null 和 undefined 的区别\"></a>10.null 和 undefined 的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-9\"><a href=\"#答案-9\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>undefined</code>: 表示缺少值，即此处应该有值，但没有定义。</p>\n<ul>\n<li>声明一个变量,这个变量的值就自动被赋予了<code>undefined</code>;</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>调用函数时，应该被提供的参数没有提供，该参数等于<code>undefined</code>;</p>\n</li>\n<li><p>对象没有赋值的属性，该属性为<code>undefined</code>;</p>\n</li>\n<li><p>函数没有返回值，默认返回<code>undefined</code>;</p>\n</li>\n</ul>\n<p><code>null</code>：表示没有对象，即此处不应该有值。</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象;</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n<p>其他方面的区别：<br>（1）数据类型的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这是 JS 设计的一个失误</strong></p>\n<p>（2）转为数值的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">5</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">5</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>（3)<code>null !== undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"11-原型和原型链\"><a href=\"#11-原型和原型链\" class=\"headerlink\" title=\"11.原型和原型链\"></a>11.原型和原型链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-10\"><a href=\"#答案-10\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md\">原型和原型链</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"12-var，let-和-const-有什么区别\"><a href=\"#12-var，let-和-const-有什么区别\" class=\"headerlink\" title=\"12.var，let 和 const 有什么区别\"></a>12.var，let 和 const 有什么区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-11\"><a href=\"#答案-11\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：<br><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</li>\n</ul>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"13-call-、apply-、bind-的区别和作用\"><a href=\"#13-call-、apply-、bind-的区别和作用\" class=\"headerlink\" title=\"13.call()、apply()、bind()的区别和作用\"></a>13.<code>call()</code>、<code>apply()</code>、<code>bind()</code>的区别和作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-12\"><a href=\"#答案-12\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。</p>\n</blockquote>\n<p>区别：（接受参数的方式不同、改变 this 指向后的处理不同）<br><code>call()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n<p><code>apply()</code>的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">apply</span>(obj, [varl, var2， var3])</span><br></pre></td></tr></table></figure>\n\n<p><code>bind()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"14-cookie、localStorage、sessionStorage的异同点\"><a href=\"#14-cookie、localStorage、sessionStorage的异同点\" class=\"headerlink\" title=\"14.cookie、localStorage、sessionStorage的异同点\"></a>14.<code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>的异同点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-13\"><a href=\"#答案-13\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"center\">生命周期</th>\n<th align=\"center\">存储容量</th>\n<th align=\"center\">储存位置</th>\n<th align=\"center\">应用场景</th>\n<th align=\"center\">浏览器兼容性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cookie</td>\n<td align=\"center\">默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效)</td>\n<td align=\"center\">4kb</td>\n<td align=\"center\">保存在客户端每次请求都会带上</td>\n<td align=\"center\">用户的部分不重要信息或者登录信息</td>\n<td align=\"center\">兼容性完全没问题</td>\n</tr>\n<tr>\n<td align=\"center\">localStorage</td>\n<td align=\"center\">理论上永久有效,除非主动清除</td>\n<td align=\"center\">4.98M(不同浏览器情况不同，safari2.49M)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合持久化缓存数据，比如页面的偏好配置等</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n<tr>\n<td align=\"center\">sessionStorage</td>\n<td align=\"center\">仅在当前网页会话下有效，关闭页面或浏览器后会被清除</td>\n<td align=\"center\">4.98M(部分浏览器没有限制)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合一次性临时数据缓存</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><code>localStorage</code>写入的时候如果超出容量会报错，但之前保存的数据不会丢失。</li>\n<li><code>localStorage</code>存储量快要满的时候，<code>getItem</code>的性能会急剧下降。</li>\n<li><code>webStorage(localStorage、sessionStorage)</code>在保存复杂数据类型时，较为依赖<code>JSON.stringify()</code>在移动端性能问题比较明显。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"15-HTTP、HTTPS-有什么联系，端口号是多少？\"><a href=\"#15-HTTP、HTTPS-有什么联系，端口号是多少？\" class=\"headerlink\" title=\"15.HTTP、HTTPS 有什么联系，端口号是多少？\"></a>15.HTTP、HTTPS 有什么联系，端口号是多少？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-14\"><a href=\"#答案-14\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\"><a href=\"#16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\" class=\"headerlink\" title=\"16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\"></a>16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-15\"><a href=\"#答案-15\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。<br>在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL&#x2F;TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"17-HTTP-2\"><a href=\"#17-HTTP-2\" class=\"headerlink\" title=\"17.HTTP&#x2F;2\"></a>17.HTTP&#x2F;2</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-16\"><a href=\"#答案-16\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。<br>提供更多的加密支持。<br>使用多路线路，允许多个消息在一个连接上同时交差。<br>增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n<h3 id=\"18-HTTP-常见状态码\"><a href=\"#18-HTTP-常见状态码\" class=\"headerlink\" title=\"18.HTTP 常见状态码\"></a>18.HTTP 常见状态码</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-17\"><a href=\"#答案-17\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。</li>\n<li>200 OK 表示正常返回信息。</li>\n<li>201 Created 表示请求成功并且服务器创建了新资源。</li>\n<li>202 Accepted 表示服务器已接受请求，但尚未处理。</li>\n<li>301 Moved Permanently 表示请求的网页已永久移动到新位置。</li>\n<li>302 Found 表示临时重定向。</li>\n<li>303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 表示自从上次请求后，请求网页未修改。</li>\n<li>400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 表示请求未授权。</li>\n<li>403 Forbidden 表示禁止访问。</li>\n<li>404 Not Found 表示找不到如何与 URI 匹配的资源。</li>\n<li>500 Internet Server error 表示最常见的服务端的错误。</li>\n<li>503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"19-无状态协议？如何克服无状态协议缺陷？\"><a href=\"#19-无状态协议？如何克服无状态协议缺陷？\" class=\"headerlink\" title=\"19.无状态协议？如何克服无状态协议缺陷？\"></a>19.无状态协议？如何克服无状态协议缺陷？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-18\"><a href=\"#答案-18\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。<br>克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"20-HTTP-请求报文和响应报文包括哪些部分？\"><a href=\"#20-HTTP-请求报文和响应报文包括哪些部分？\" class=\"headerlink\" title=\"20.HTTP 请求报文和响应报文包括哪些部分？\"></a>20.HTTP 请求报文和响应报文包括哪些部分？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-19\"><a href=\"#答案-19\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>请求报文：</p>\n<ul>\n<li>请求行，包含请求方法、URI、HTTP 版本信息。</li>\n<li>请求首部字段。</li>\n<li>请求内容实体。</li>\n</ul>\n<p>响应报文：</p>\n<ul>\n<li>状态行，包括 HTTP 版本，状态码，状态码的原因短语。</li>\n<li>响应首部字段。</li>\n<li>响应内容实体。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"21-HTTP-请求方式\"><a href=\"#21-HTTP-请求方式\" class=\"headerlink\" title=\"21.HTTP 请求方式\"></a>21.HTTP 请求方式</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-20\"><a href=\"#答案-20\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。</li>\n<li>POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。</li>\n<li>PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。</li>\n<li>HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li>DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。</li>\n<li>OPTIONS:查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-HTTP-首部字段包括哪些类型\"><a href=\"#22-HTTP-首部字段包括哪些类型\" class=\"headerlink\" title=\"22.HTTP 首部字段包括哪些类型\"></a>22.HTTP 首部字段包括哪些类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-21\"><a href=\"#答案-21\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><p>通用首部字段(请求报文和响应报文都会使用的首部字段)。</p>\n<blockquote>\n<p><code>Date</code>:创建报文的时间。<br><code>Connection</code>:连接的管理。<br><code>Cache-Control</code>:缓存机制。<br><code>Transfer-Encoding</code>:报文主体的传输编码方式。</p>\n</blockquote>\n</li>\n<li><p>请求首部字段（请求报文会使用的首部字段）。</p>\n<blockquote>\n<p><code>Host</code>: 请求资源所在的服务器。<br><code>Accept</code>: 可处理的媒体类型。<br><code>Accept-Charset</code>: 可接受的字符集。<br><code>Accept-Encoding</code>: 可接受的内容编码。<br><code>Accept-Language</code>: 可接受的自然语言。</p>\n</blockquote>\n</li>\n<li><p>响应首部字段（响应报文会使用的字段）。</p>\n<blockquote>\n<p><code>Accept-Ranges</code>: 可接受的字节范围。<br><code>Location</code>: 令客户端重新定向到的 URL。</p>\n</blockquote>\n</li>\n<li><p>实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。</p>\n<blockquote>\n<p><code>Allow</code>: 资源可支持的 HTTP 方法。<br><code>Content-Type</code>: 实体主体的类型。<br><code>Content-Encoding</code>: 实体主体使用的编码方式。<br><code>Content-Language</code>: 实体主体的自然语言。<br><code>Content-Length</code>: 实体主体的字节数。<br><code>Content-Range</code>: 实体主体的位置范围，一般用于发出部分请求时使用。</p>\n</blockquote>\n</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-GET和POST的区别\"><a href=\"#22-GET和POST的区别\" class=\"headerlink\" title=\"22.GET和POST的区别\"></a>22.<code>GET</code>和<code>POST</code>的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-22\"><a href=\"#答案-22\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>GET</code>一般用于获取&#x2F;查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而<code>POST</code>一般用于更新资源信息，会修改服务器上的资源信息。</li>\n<li><code>GET</code>请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；<code>POST</code>把提交的数据放在 HTTP 的 requset body 中。</li>\n<li><code>GET</code>方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲<code>POST</code>是没有大小限制的。</li>\n<li>在 ASP 中，服务端获取<code>GET</code>请求参数用 Requset.QueryString;获取<code>POST</code>的请求参数用 Requset.Form。</li>\n<li><code>POST</code>比<code>GET</code>安全性更高：<code>GET</code>提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"23-网站性能优化\"><a href=\"#23-网站性能优化\" class=\"headerlink\" title=\"23.网站性能优化\"></a>23.网站性能优化</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-23\"><a href=\"#答案-23\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://juejin.cn/post/6844903613790175240\">网站性能优化实战</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://imweb.io/topic/5b4d417eee0c3b0779df96d9\">网站性能优化实战(二)</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://segmentfault.com/a/1190000021098540\">网站性能优化实战篇</a></li>\n</ul>\n<p>基本优化：</p>\n<ul>\n<li>图片压缩合并；</li>\n<li>代码精简、混淆；</li>\n<li>减少<code>iframe</code>使用；</li>\n<li>避免图片<code>src</code>为空；</li>\n<li>减少<code>HTTP</code>请求数；</li>\n<li>避免重定向；</li>\n<li>样式表放页头、脚本放底部；</li>\n</ul>\n<p>网站性能优化总结：<br>(一)网络传输性能优化————重定向——&gt;拉取缓存——&gt;DNS 查询——&gt;建立 TCP 链接——&gt;发起请求——&gt;处理 HTML 元素——&gt;元素加载完成</p>\n<ul>\n<li>浏览器缓存。</li>\n<li>资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！</li>\n<li>图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;</li>\n<li>网络传输性能检查工具————Page Speed。</li>\n<li>使用 CDN。</li>\n</ul>\n<p>(二)页面性能优化————处理 HTML 标记并构建 DOM 树——&gt;处理 CSS 标记并构建 CSSOM 树——&gt;将 DOM 和 CSSOM 合并成一个 render 渲染树——&gt;根据渲染树来布局，以计算每个节点的几何信息——&gt;将每个节点绘制在屏幕上</p>\n<ul>\n<li>DOM 渲染层与 GPU 硬件加速。</li>\n<li>降低重绘和重排的频率和成本。</li>\n</ul>\n<p>总结：</p>\n<blockquote>\n<p>CSS 读写分离：不用 js 操作元素样式。<br>通过切换 class 或使用 style.csstext 属性批量操作元素样式。<br>DOM 元素离线更新。<br>将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。<br>压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。<br>图片在渲染前指定大小。<br>降低重绘和重排的频率和成本。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>日常 js 面试题积累汇总。持续更新！</p>\n<h3 id=\"1-JavaScript-的基本数据类型\"><a href=\"#1-JavaScript-的基本数据类型\" class=\"headerlink\" title=\"1.JavaScript 的基本数据类型\"></a>1.JavaScript 的基本数据类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbel</code>（ES6 新增）、<code>BigInt</code>(ES10 新增)<br>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、和<code>String</code><br>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code><br><a href=\"https://github.com/yihan12/day-to-day/blob/master/javascript%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md\">js 数据类型</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"2-JavaScript-的引用类型\"><a href=\"#2-JavaScript-的引用类型\" class=\"headerlink\" title=\"2.JavaScript 的引用类型\"></a>2.JavaScript 的引用类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-1\"><a href=\"#答案-1\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>Object </code></li>\n<li><code>Function</code></li>\n<li><code>Array</code></li>\n<li><code>Date</code></li>\n<li><code>RegExp</code></p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"3-Javascript-基本数据类型和引用类型的特点\"><a href=\"#3-Javascript-基本数据类型和引用类型的特点\" class=\"headerlink\" title=\"3.Javascript 基本数据类型和引用类型的特点\"></a>3.Javascript 基本数据类型和引用类型的特点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-2\"><a href=\"#答案-2\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.基本数据类型：值不可变；数据存放在栈区。<br>2.引用数据类型：值是可变的；同时保存在栈内存和堆内存。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\"><a href=\"#4-检验-JavaScript-的数据类型的方法有哪些，以及使用它们的缺点\" class=\"headerlink\" title=\"4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点\"></a>4.检验 JavaScript 的数据类型的方法有哪些，以及使用它们的缺点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-3\"><a href=\"#答案-3\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.<code>typeof</code>：不能判断 null 和区分 Array&#x2F;Date&#x2F;RegExp</li>\n<li>2.<code>instanceof</code>：无法检测 null 和 undefined；未必准确（是否处于处于原型链上的方法不准确）；无法判断字面量方式创建的基本数据类型；</li>\n<li>3.<code>constructor</code>：无法检测 null 和 undefined；未必准确</li>\n<li>4.<code>Object.prototype.toString.call()</code>：无；全能方法；</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"5-JavaScript-基本数据类型和非基本数据类型的区别\"><a href=\"#5-JavaScript-基本数据类型和非基本数据类型的区别\" class=\"headerlink\" title=\"5.JavaScript 基本数据类型和非基本数据类型的区别\"></a>5.JavaScript 基本数据类型和非基本数据类型的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-4\"><a href=\"#答案-4\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>1.目前 JS 中有 6 种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>和<code>Symbel</code>（ES6 新增）。还有一种复杂数据类型—-<code>Object</code>,<code>Object</code>本质上是由一组无序的名值对组成的，<code>Object</code>、<code>Fuction</code>、<code>Array</code>则属于引用类型。</li>\n<li>2.基本数据类型是不可变的，而非基本数据类型是可变的。</li>\n<li>3.基本数据类型是不可变的，因为一旦它们创建就无法更改。但是非基本数据类型可更改，意味着一旦创建对象，就可以更改它。</li>\n<li>4.将基本数据类型与其值进行比较，这意味着如果两个值具有相同的数据类型，并具有相同的值，那么它们是严格相等的。</li>\n<li>5.非基本数据类型不与值进行比较。例如，如果两个对象具有相同的属性和值，则它们严格不相等。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"6-instanceof-操作符\"><a href=\"#6-instanceof-操作符\" class=\"headerlink\" title=\"6.instanceof 操作符\"></a>6.instanceof 操作符</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-5\"><a href=\"#答案-5\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>判断对象属于某一个类，回去查找对象的 constructor 的 prototype</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"7-new-操作符的作用\"><a href=\"#7-new-操作符的作用\" class=\"headerlink\" title=\"7.new 操作符的作用\"></a>7.new 操作符的作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-6\"><a href=\"#答案-6\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>新生了一个对象</li>\n<li>链接到原型(该对象继承该函数的原型，更改了原型链的指向)</li>\n<li>绑定 this</li>\n<li>返回对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">newCreate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建一个空白对象</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()</span><br><span class=\"line\">  <span class=\"comment\">// 获得构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title class_\">Con</span> = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 链接到原型</span></span><br><span class=\"line\">  obj.<span class=\"property\">__proto__</span> = <span class=\"title class_\">Con</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\">  <span class=\"comment\">// 绑定this,执行构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"title class_\">Con</span>.<span class=\"title function_\">apply</span>(obj, <span class=\"variable language_\">arguments</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 确保new出来的是个对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> result === <span class=\"string\">&#x27;object&#x27;</span> ? result : obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"8-作用域和作用域链\"><a href=\"#8-作用域和作用域链\" class=\"headerlink\" title=\"8.作用域和作用域链\"></a>8.作用域和作用域链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-7\"><a href=\"#答案-7\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202101/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F.md\">静态作用域与动态作用域</a></p>\n<h4 id=\"1-作用域\"><a href=\"#1-作用域\" class=\"headerlink\" title=\"1.作用域\"></a>1.作用域</h4><ul>\n<li>种类：JS 中有三种作用域，全局作用域，函数作用域，ES6 新推出的块级作用域。</li>\n<li>概念：一个变量的可访问规则，在函数创建的时候就已经创建好作用域，整个 JS 文件执行有一个最外层的全局作用域（window）。</li>\n<li>使用：本作用域内部的所有变量都可以在本作用域内部访问，外部无法访问。内部可访问上级作用域变量，本作用域内部所使用的 var 声明的变量会有一个作用域提升的过程，let、const 声明的变量没有变量提升。</li>\n</ul>\n<h4 id=\"2-作用域链\"><a href=\"#2-作用域链\" class=\"headerlink\" title=\"2.作用域链\"></a>2.作用域链</h4><ul>\n<li>一个变量的访问规则的链式操作</li>\n<li>可以把它理解成包含自身变量对象和上级变量对象的列表，可以通过[[Scope]]属性查找上级变量</li>\n<li>当访问一个变量时，现在本作用域内查找，如果没有，就回去上一级作用域查找，直到全局作用域 window 下面，都没有返回 undefined</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"9-闭包\"><a href=\"#9-闭包\" class=\"headerlink\" title=\"9.闭包\"></a>9.闭包</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-8\"><a href=\"#答案-8\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>1.特点：</p>\n<ul>\n<li><p>内层作用域可以访问外层作用域的变量</p>\n</li>\n<li><p>闭包就是可以读取其他函数内部变量的函数</p>\n</li>\n<li><p>函数 A 返回一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就称为闭包</p>\n</li>\n<li><p>闭包函数引用的变量是存储在堆上的，所以说，当闭包函数弹出调用栈后，闭包返回的函数依然能够调用到闭包函数的变量</p>\n<p>2.优点</p>\n</li>\n<li><p>使用闭包能够形成独立的空间，延长变量的生命周期，保存中间状态值</p>\n</li>\n<li><p>可以封装一些私有变量，外部无法直接访问（例如用户登录状态计数器）创建立即执行函数（闭包）实现 js 模块化封装</p>\n</li>\n<li><p>解决 var 声明的循环语句变量无法长久保存的问题</p>\n<p>3.缺点</p>\n</li>\n<li><p>滥用闭包会导致内存泄漏，因为闭包中引用的包裹函数的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数，将不再使用的闭包引用变量设置为 null</p>\n</li>\n<li><p>由于函数闭包的变量都保存在内存中，会导致内存消耗大</p>\n</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"10-null-和-undefined-的区别\"><a href=\"#10-null-和-undefined-的区别\" class=\"headerlink\" title=\"10.null 和 undefined 的区别\"></a>10.null 和 undefined 的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-9\"><a href=\"#答案-9\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><code>undefined</code>: 表示缺少值，即此处应该有值，但没有定义。</p>\n<ul>\n<li>声明一个变量,这个变量的值就自动被赋予了<code>undefined</code>;</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>调用函数时，应该被提供的参数没有提供，该参数等于<code>undefined</code>;</p>\n</li>\n<li><p>对象没有赋值的属性，该属性为<code>undefined</code>;</p>\n</li>\n<li><p>函数没有返回值，默认返回<code>undefined</code>;</p>\n</li>\n</ul>\n<p><code>null</code>：表示没有对象，即此处不应该有值。</p>\n<ul>\n<li>作为函数的参数，表示该函数的参数不是对象;</li>\n<li>作为对象原型链的终点。</li>\n</ul>\n<p>其他方面的区别：<br>（1）数据类型的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>) <span class=\"comment\">// Object</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这是 JS 设计的一个失误</strong></p>\n<p>（2）转为数值的区别</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> num1 = <span class=\"number\">5</span> + <span class=\"literal\">null</span> <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> num2 = <span class=\"number\">5</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>（3)<code>null !== undefined</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> == <span class=\"literal\">undefined</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">null</span> === <span class=\"literal\">undefined</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"11-原型和原型链\"><a href=\"#11-原型和原型链\" class=\"headerlink\" title=\"11.原型和原型链\"></a>11.原型和原型链</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-10\"><a href=\"#答案-10\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p><a href=\"https://github.com/yihan12/day-to-day/blob/master/202012/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3.md\">原型和原型链</a></p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"12-var，let-和-const-有什么区别\"><a href=\"#12-var，let-和-const-有什么区别\" class=\"headerlink\" title=\"12.var，let 和 const 有什么区别\"></a>12.var，let 和 const 有什么区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-11\"><a href=\"#答案-11\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><strong>相同点</strong>：<code>var</code>,<code>let</code>,<code>const</code>声明的变量，是不能被<code>delete</code>的;</li>\n<li><strong>区别</strong>：<br><strong>变量提升</strong>：<code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为 undefined；<br><code>let</code>,<code>const</code>不存在变量提升，即它们声明的变量一定要在声明后使用，否则会报错。</li>\n</ul>\n<p><strong>暂时性死区</strong>：<code>var</code>不存在暂时性死区；<code>let</code>、<code>const</code>存在暂时性死区，只有等声明变量后，才可以获取和使用该变量。</p>\n<p><strong>重复声明</strong>：<code>var</code>允许重复声明；<code>lat</code>、<code>const</code>在同一作用域不允许重复声明。</p>\n<p><strong>修改声明的变量</strong>：<code>var</code>和<code>let</code>可以修改声明的变量；<code>const</code>声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"13-call-、apply-、bind-的区别和作用\"><a href=\"#13-call-、apply-、bind-的区别和作用\" class=\"headerlink\" title=\"13.call()、apply()、bind()的区别和作用\"></a>13.<code>call()</code>、<code>apply()</code>、<code>bind()</code>的区别和作用</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-12\"><a href=\"#答案-12\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>作用：(改变 this 的指向)都是在函数执行的时候，改变函数的运行环境，也就是改变函数的执行上下文；第一个参数都是改变运行环境的变量；如果第一个函数没有或者为 null、undefined,则默认指向全局 window。</p>\n</blockquote>\n<p>区别：（接受参数的方式不同、改变 this 指向后的处理不同）<br><code>call()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n<p><code>apply()</code>的第二个参数是数组，数组的每一个成员会依次传递给调用函数（参数数组）;改变指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">apply</span>(obj, [varl, var2， var3])</span><br></pre></td></tr></table></figure>\n\n<p><code>bind()</code>从第二个函数开始，第一个参数会依次传递给调用函数(参数列表);改变指向后原函数不会立即执行，会返回一个永久改变 this 指向的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"title function_\">call</span>(obj, varl, var2， var3)</span><br></pre></td></tr></table></figure>\n\n</p>\n</details>\n\n<hr>\n<h3 id=\"14-cookie、localStorage、sessionStorage的异同点\"><a href=\"#14-cookie、localStorage、sessionStorage的异同点\" class=\"headerlink\" title=\"14.cookie、localStorage、sessionStorage的异同点\"></a>14.<code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>的异同点</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-13\"><a href=\"#答案-13\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"center\">生命周期</th>\n<th align=\"center\">存储容量</th>\n<th align=\"center\">储存位置</th>\n<th align=\"center\">应用场景</th>\n<th align=\"center\">浏览器兼容性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">cookie</td>\n<td align=\"center\">默认保存在内存中,随浏览器关闭失效(如果设置过期时间，在到过期时间会失效)</td>\n<td align=\"center\">4kb</td>\n<td align=\"center\">保存在客户端每次请求都会带上</td>\n<td align=\"center\">用户的部分不重要信息或者登录信息</td>\n<td align=\"center\">兼容性完全没问题</td>\n</tr>\n<tr>\n<td align=\"center\">localStorage</td>\n<td align=\"center\">理论上永久有效,除非主动清除</td>\n<td align=\"center\">4.98M(不同浏览器情况不同，safari2.49M)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合持久化缓存数据，比如页面的偏好配置等</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n<tr>\n<td align=\"center\">sessionStorage</td>\n<td align=\"center\">仅在当前网页会话下有效，关闭页面或浏览器后会被清除</td>\n<td align=\"center\">4.98M(部分浏览器没有限制)</td>\n<td align=\"center\">保存在客户端，不与服务端交互，节省网络流量</td>\n<td align=\"center\">适合一次性临时数据缓存</td>\n<td align=\"center\">IE8+以上的浏览器</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><code>localStorage</code>写入的时候如果超出容量会报错，但之前保存的数据不会丢失。</li>\n<li><code>localStorage</code>存储量快要满的时候，<code>getItem</code>的性能会急剧下降。</li>\n<li><code>webStorage(localStorage、sessionStorage)</code>在保存复杂数据类型时，较为依赖<code>JSON.stringify()</code>在移动端性能问题比较明显。</p>\n</details></li>\n</ul>\n<hr>\n<h3 id=\"15-HTTP、HTTPS-有什么联系，端口号是多少？\"><a href=\"#15-HTTP、HTTPS-有什么联系，端口号是多少？\" class=\"headerlink\" title=\"15.HTTP、HTTPS 有什么联系，端口号是多少？\"></a>15.HTTP、HTTPS 有什么联系，端口号是多少？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-14\"><a href=\"#答案-14\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TLS），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\"><a href=\"#16-HTTP、HTTPS-有什么联系，端口号是多少？为什么-HTTPS-更安全\" class=\"headerlink\" title=\"16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?\"></a>16.HTTP、HTTPS 有什么联系，端口号是多少？为什么 HTTPS 更安全?</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-15\"><a href=\"#答案-15\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>HTTP:是客户端和服务端之间数据传输的格式规范，表示超文本传输协议。HTTP 通常承载于 TCP 之上，在 HTTP 和 TCP 之间添加了一个安全协议层（SSL 或 TSL），这个时候，就变成了我们常说的 HTTPS。HTTP 默认端口号 80，HTTPS 默认端口号 443。<br>在网络请求中，需要很多服务器，路由器的转发。其中的节点都可能篡改信息，而如果使用 HTTPS，密钥在终点站才有。HTTPS 之所以安全，是因为它利用 SSL&#x2F;TLS 协议传输。它包含证书、卸载、流量转发、负载均衡、页面适配、浏览器适配、refer 传递等技术、保障了传输过程中的安全性。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"17-HTTP-2\"><a href=\"#17-HTTP-2\" class=\"headerlink\" title=\"17.HTTP&#x2F;2\"></a>17.HTTP&#x2F;2</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-16\"><a href=\"#答案-16\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><blockquote>\n<p>引入服务器端推送（server push）的概念,它允许服务器端在客户端需要数据之前主动将数据发送到客户端缓存中，从而提高性能。<br>提供更多的加密支持。<br>使用多路线路，允许多个消息在一个连接上同时交差。<br>增加了头压缩（header compression），因此请求非常小，请求和响应的 header 都只会占用很小的带宽。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n<h3 id=\"18-HTTP-常见状态码\"><a href=\"#18-HTTP-常见状态码\" class=\"headerlink\" title=\"18.HTTP 常见状态码\"></a>18.HTTP 常见状态码</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-17\"><a href=\"#答案-17\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>100 Continue 表示继续，一般在发送 post 请求时，已发送了 HTTP header 之后，服务端将会缓存此信息，表示确认，之后发送具体参数信息。</li>\n<li>200 OK 表示正常返回信息。</li>\n<li>201 Created 表示请求成功并且服务器创建了新资源。</li>\n<li>202 Accepted 表示服务器已接受请求，但尚未处理。</li>\n<li>301 Moved Permanently 表示请求的网页已永久移动到新位置。</li>\n<li>302 Found 表示临时重定向。</li>\n<li>303 See Other 表示临时重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 表示自从上次请求后，请求网页未修改。</li>\n<li>400 Bad Request 表示服务器无法理解请求格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 表示请求未授权。</li>\n<li>403 Forbidden 表示禁止访问。</li>\n<li>404 Not Found 表示找不到如何与 URI 匹配的资源。</li>\n<li>500 Internet Server error 表示最常见的服务端的错误。</li>\n<li>503 Service Unavailable 表示服务端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"19-无状态协议？如何克服无状态协议缺陷？\"><a href=\"#19-无状态协议？如何克服无状态协议缺陷？\" class=\"headerlink\" title=\"19.无状态协议？如何克服无状态协议缺陷？\"></a>19.无状态协议？如何克服无状态协议缺陷？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-18\"><a href=\"#答案-18\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>无状态协议对于事务处理没有记忆功能，缺少状态意味着如果后续需要处理，需要前面提供信息。<br>克服无状态协议缺陷的办法就是通过 cookie 和会话保存信息。</p>\n</p>\n</details>\n\n<hr>\n<h3 id=\"20-HTTP-请求报文和响应报文包括哪些部分？\"><a href=\"#20-HTTP-请求报文和响应报文包括哪些部分？\" class=\"headerlink\" title=\"20.HTTP 请求报文和响应报文包括哪些部分？\"></a>20.HTTP 请求报文和响应报文包括哪些部分？</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-19\"><a href=\"#答案-19\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><p>请求报文：</p>\n<ul>\n<li>请求行，包含请求方法、URI、HTTP 版本信息。</li>\n<li>请求首部字段。</li>\n<li>请求内容实体。</li>\n</ul>\n<p>响应报文：</p>\n<ul>\n<li>状态行，包括 HTTP 版本，状态码，状态码的原因短语。</li>\n<li>响应首部字段。</li>\n<li>响应内容实体。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"21-HTTP-请求方式\"><a href=\"#21-HTTP-请求方式\" class=\"headerlink\" title=\"21.HTTP 请求方式\"></a>21.HTTP 请求方式</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-20\"><a href=\"#答案-20\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li>GET:请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL，给服务器传递参数数据。</li>\n<li>POST：传输信息给服务器，主要功能与 GET 方法类似，但传递的数据量通常不受限。</li>\n<li>PUT:传输文件，报文主体包含文件内容，保存到对应 URI 的位置。</li>\n<li>HEAD:获得报文首部，与 get 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li>DELETE：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。</li>\n<li>OPTIONS:查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-HTTP-首部字段包括哪些类型\"><a href=\"#22-HTTP-首部字段包括哪些类型\" class=\"headerlink\" title=\"22.HTTP 首部字段包括哪些类型\"></a>22.HTTP 首部字段包括哪些类型</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-21\"><a href=\"#答案-21\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><p>通用首部字段(请求报文和响应报文都会使用的首部字段)。</p>\n<blockquote>\n<p><code>Date</code>:创建报文的时间。<br><code>Connection</code>:连接的管理。<br><code>Cache-Control</code>:缓存机制。<br><code>Transfer-Encoding</code>:报文主体的传输编码方式。</p>\n</blockquote>\n</li>\n<li><p>请求首部字段（请求报文会使用的首部字段）。</p>\n<blockquote>\n<p><code>Host</code>: 请求资源所在的服务器。<br><code>Accept</code>: 可处理的媒体类型。<br><code>Accept-Charset</code>: 可接受的字符集。<br><code>Accept-Encoding</code>: 可接受的内容编码。<br><code>Accept-Language</code>: 可接受的自然语言。</p>\n</blockquote>\n</li>\n<li><p>响应首部字段（响应报文会使用的字段）。</p>\n<blockquote>\n<p><code>Accept-Ranges</code>: 可接受的字节范围。<br><code>Location</code>: 令客户端重新定向到的 URL。</p>\n</blockquote>\n</li>\n<li><p>实体首部字段（请求报文和响应报文的实体部分使用的首部字段）。</p>\n<blockquote>\n<p><code>Allow</code>: 资源可支持的 HTTP 方法。<br><code>Content-Type</code>: 实体主体的类型。<br><code>Content-Encoding</code>: 实体主体使用的编码方式。<br><code>Content-Language</code>: 实体主体的自然语言。<br><code>Content-Length</code>: 实体主体的字节数。<br><code>Content-Range</code>: 实体主体的位置范围，一般用于发出部分请求时使用。</p>\n</blockquote>\n</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"22-GET和POST的区别\"><a href=\"#22-GET和POST的区别\" class=\"headerlink\" title=\"22.GET和POST的区别\"></a>22.<code>GET</code>和<code>POST</code>的区别</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-22\"><a href=\"#答案-22\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><code>GET</code>一般用于获取&#x2F;查询资源，应该时安全幂等（对于同一 URL 的多个请求应该返回同样的结果）的；而<code>POST</code>一般用于更新资源信息，会修改服务器上的资源信息。</li>\n<li><code>GET</code>请求的数据会附在 URI 之后（就是把数据放在 HTTP 协议头中）；<code>POST</code>把提交的数据放在 HTTP 的 requset body 中。</li>\n<li><code>GET</code>方式提交的数据最多时 1024 字节，这个限制取决于操作系统的支持；理论上讲<code>POST</code>是没有大小限制的。</li>\n<li>在 ASP 中，服务端获取<code>GET</code>请求参数用 Requset.QueryString;获取<code>POST</code>的请求参数用 Requset.Form。</li>\n<li><code>POST</code>比<code>GET</code>安全性更高：<code>GET</code>提交数据，用户名和密码将明文出现在 URL 上；登录页面有可能被浏览器缓存；其他人可以查看浏览器历史记录；还可能造成 Cross-site request forgery 攻击。</li>\n</ul>\n</p>\n</details>\n\n<hr>\n<h3 id=\"23-网站性能优化\"><a href=\"#23-网站性能优化\" class=\"headerlink\" title=\"23.网站性能优化\"></a>23.网站性能优化</h3><details><summary><b></b></summary>\n<p>\n\n<h4 id=\"答案-23\"><a href=\"#答案-23\" class=\"headerlink\" title=\"答案:\"></a>答案:</h4><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://juejin.cn/post/6844903613790175240\">网站性能优化实战</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://imweb.io/topic/5b4d417eee0c3b0779df96d9\">网站性能优化实战(二)</a></li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <a href=\"https://segmentfault.com/a/1190000021098540\">网站性能优化实战篇</a></li>\n</ul>\n<p>基本优化：</p>\n<ul>\n<li>图片压缩合并；</li>\n<li>代码精简、混淆；</li>\n<li>减少<code>iframe</code>使用；</li>\n<li>避免图片<code>src</code>为空；</li>\n<li>减少<code>HTTP</code>请求数；</li>\n<li>避免重定向；</li>\n<li>样式表放页头、脚本放底部；</li>\n</ul>\n<p>网站性能优化总结：<br>(一)网络传输性能优化————重定向——&gt;拉取缓存——&gt;DNS 查询——&gt;建立 TCP 链接——&gt;发起请求——&gt;处理 HTML 元素——&gt;元素加载完成</p>\n<ul>\n<li>浏览器缓存。</li>\n<li>资源打包压缩（webpack）：注意不要对图片文件进行 Gzip 压缩！</li>\n<li>图片资源优化：不在 HTML 里缩放图像；使用雪碧图（CSS sprite）；使用字体图标（iconfont）；使用 WebP;</li>\n<li>网络传输性能检查工具————Page Speed。</li>\n<li>使用 CDN。</li>\n</ul>\n<p>(二)页面性能优化————处理 HTML 标记并构建 DOM 树——&gt;处理 CSS 标记并构建 CSSOM 树——&gt;将 DOM 和 CSSOM 合并成一个 render 渲染树——&gt;根据渲染树来布局，以计算每个节点的几何信息——&gt;将每个节点绘制在屏幕上</p>\n<ul>\n<li>DOM 渲染层与 GPU 硬件加速。</li>\n<li>降低重绘和重排的频率和成本。</li>\n</ul>\n<p>总结：</p>\n<blockquote>\n<p>CSS 读写分离：不用 js 操作元素样式。<br>通过切换 class 或使用 style.csstext 属性批量操作元素样式。<br>DOM 元素离线更新。<br>将没用的元素设为不可见：减小重绘的压力，必要的时候再将元素显示。<br>压缩 DOM 的深度，一个渲染层不要用过深的子元素，少用 DOM 完成页面样式，多用伪元素，或者 box-shadow 取代。<br>图片在渲染前指定大小。<br>降低重绘和重排的频率和成本。</p>\n</blockquote>\n</p>\n</details>\n\n<hr>\n"},{"title":"深浅拷贝","date":"2024-11-09T02:29:44.807Z","_content":"\n# 数据类型\n\n- 基本类型 栈内存\n- 引用类型 堆内存 变量 指向实际堆内存中实际对象的引用\n\n# 浅拷贝\n\n- 只拷贝一层\n- 引用类型只拷贝内存地址\n- 修改一个对象属性，另外一个对象属性会发生改变\n\n## 实现方式\n\n- `Object.asign()`\n- `Array.prototype.slice()`\n- `Array.prototype.concat()`\n- 扩展运算符\n\n# 深拷贝\n\n> 开辟新的栈，两个对象属性完全相同，对应两个不同地址。修改一个对象属性，另外一个对象属性不会发生改变\n\n## 实现方式\n\n- `_.cloneDeep()` lodash 深拷贝\n- `jQuery.extend()`\n- `JSON.stringify()` 会忽略 undefined symbol 函数\n- 手写循环递归\n\n# 区别\n\n- 浅拷贝 只复制属性指向某个对象的指针，不复制对象本身，新旧对象共享同一块内存 修改对象属性会改变原对象\n- 深拷贝 创造一个一模一样的对象，新旧对象不共享内存，修改对象属性不会改变原对象\n","source":"_posts/JavaScript/JavaScript面试/深浅拷贝.md","raw":"---\ntitle: 深浅拷贝\ndate:\ntags: [JavaScript, JavaScript面试]\ncategories: [前端, JavaScript, 深浅拷贝]\n---\n\n# 数据类型\n\n- 基本类型 栈内存\n- 引用类型 堆内存 变量 指向实际堆内存中实际对象的引用\n\n# 浅拷贝\n\n- 只拷贝一层\n- 引用类型只拷贝内存地址\n- 修改一个对象属性，另外一个对象属性会发生改变\n\n## 实现方式\n\n- `Object.asign()`\n- `Array.prototype.slice()`\n- `Array.prototype.concat()`\n- 扩展运算符\n\n# 深拷贝\n\n> 开辟新的栈，两个对象属性完全相同，对应两个不同地址。修改一个对象属性，另外一个对象属性不会发生改变\n\n## 实现方式\n\n- `_.cloneDeep()` lodash 深拷贝\n- `jQuery.extend()`\n- `JSON.stringify()` 会忽略 undefined symbol 函数\n- 手写循环递归\n\n# 区别\n\n- 浅拷贝 只复制属性指向某个对象的指针，不复制对象本身，新旧对象共享同一块内存 修改对象属性会改变原对象\n- 深拷贝 创造一个一模一样的对象，新旧对象不共享内存，修改对象属性不会改变原对象\n","slug":"JavaScript/JavaScript面试/深浅拷贝","published":1,"updated":"2024-11-09T02:41:53.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm39k9n0f00009k2vfmhvdzl2","content":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li>基本类型 栈内存</li>\n<li>引用类型 堆内存 变量 指向实际堆内存中实际对象的引用</li>\n</ul>\n<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><ul>\n<li>只拷贝一层</li>\n<li>引用类型只拷贝内存地址</li>\n<li>修改一个对象属性，另外一个对象属性会发生改变</li>\n</ul>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><ul>\n<li><code>Object.asign()</code></li>\n<li><code>Array.prototype.slice()</code></li>\n<li><code>Array.prototype.concat()</code></li>\n<li>扩展运算符</li>\n</ul>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><blockquote>\n<p>开辟新的栈，两个对象属性完全相同，对应两个不同地址。修改一个对象属性，另外一个对象属性不会发生改变</p>\n</blockquote>\n<h2 id=\"实现方式-1\"><a href=\"#实现方式-1\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><ul>\n<li><code>_.cloneDeep()</code> lodash 深拷贝</li>\n<li><code>jQuery.extend()</code></li>\n<li><code>JSON.stringify()</code> 会忽略 undefined symbol 函数</li>\n<li>手写循环递归</li>\n</ul>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li>浅拷贝 只复制属性指向某个对象的指针，不复制对象本身，新旧对象共享同一块内存 修改对象属性会改变原对象</li>\n<li>深拷贝 创造一个一模一样的对象，新旧对象不共享内存，修改对象属性不会改变原对象</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><ul>\n<li>基本类型 栈内存</li>\n<li>引用类型 堆内存 变量 指向实际堆内存中实际对象的引用</li>\n</ul>\n<h1 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h1><ul>\n<li>只拷贝一层</li>\n<li>引用类型只拷贝内存地址</li>\n<li>修改一个对象属性，另外一个对象属性会发生改变</li>\n</ul>\n<h2 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><ul>\n<li><code>Object.asign()</code></li>\n<li><code>Array.prototype.slice()</code></li>\n<li><code>Array.prototype.concat()</code></li>\n<li>扩展运算符</li>\n</ul>\n<h1 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h1><blockquote>\n<p>开辟新的栈，两个对象属性完全相同，对应两个不同地址。修改一个对象属性，另外一个对象属性不会发生改变</p>\n</blockquote>\n<h2 id=\"实现方式-1\"><a href=\"#实现方式-1\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h2><ul>\n<li><code>_.cloneDeep()</code> lodash 深拷贝</li>\n<li><code>jQuery.extend()</code></li>\n<li><code>JSON.stringify()</code> 会忽略 undefined symbol 函数</li>\n<li>手写循环递归</li>\n</ul>\n<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><ul>\n<li>浅拷贝 只复制属性指向某个对象的指针，不复制对象本身，新旧对象共享同一块内存 修改对象属性会改变原对象</li>\n<li>深拷贝 创造一个一模一样的对象，新旧对象不共享内存，修改对象属性不会改变原对象</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm39jlww80003m32vbzhi89ms","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwm001mm32v1uneaock"},{"post_id":"cm39jlww80003m32vbzhi89ms","category_id":"cm39jlwwj0019m32v9gsp64hd","_id":"cm39jlwwm001qm32vab82asyt"},{"post_id":"cm39jlwwf000om32v6ytjfw9y","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwws002im32v16u00t78"},{"post_id":"cm39jlwwf000om32v6ytjfw9y","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwws002mm32vf1r97ub9"},{"post_id":"cm39jlwwf000om32v6ytjfw9y","category_id":"cm39jlwwp0025m32v06kw9vre","_id":"cm39jlwwt002pm32v781e9t7k"},{"post_id":"cm39jlwwa0009m32vcf4pbwmd","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwu002tm32vbqe42d0o"},{"post_id":"cm39jlwwa0009m32vcf4pbwmd","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwu002xm32ve6xsgr18"},{"post_id":"cm39jlwwa0009m32vcf4pbwmd","category_id":"cm39jlwwq002cm32v3ow6d22g","_id":"cm39jlwwv0030m32v5uvi7htq"},{"post_id":"cm39jlww60001m32vhosu9xma","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwx003bm32v2uzu2bfc"},{"post_id":"cm39jlww60001m32vhosu9xma","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwy003fm32v6ztm9681"},{"post_id":"cm39jlww60001m32vhosu9xma","category_id":"cm39jlwwu002zm32vbkorhian","_id":"cm39jlwwy003im32vgyrbbofm"},{"post_id":"cm39jlwwh000wm32v0kb0e4fl","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwwz003mm32v1a4p92s8"},{"post_id":"cm39jlwwh000wm32v0kb0e4fl","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwwz003pm32v5ft7hb3d"},{"post_id":"cm39jlwwh000wm32v0kb0e4fl","category_id":"cm39jlwww0035m32v9go64do9","_id":"cm39jlwx0003tm32vghnpdo9i"},{"post_id":"cm39jlwwb000am32v2b3taob7","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx1003wm32vd4fi38lz"},{"post_id":"cm39jlwwb000am32v2b3taob7","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx20040m32v9n99504n"},{"post_id":"cm39jlwwb000am32v2b3taob7","category_id":"cm39jlwwy003km32v4frjee1v","_id":"cm39jlwx20043m32vf3f41zo5"},{"post_id":"cm39jlwwc000dm32vfv527vp1","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx4004fm32vf3wv9vld"},{"post_id":"cm39jlwwc000dm32vfv527vp1","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx4004gm32vcm8z5wfi"},{"post_id":"cm39jlwwc000dm32vfv527vp1","category_id":"cm39jlwx20045m32v7qs48vhm","_id":"cm39jlwx4004im32vc78k58iy"},{"post_id":"cm39jlwwc000em32v3xofc0lb","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx7004vm32vbfig7hkh"},{"post_id":"cm39jlwwc000em32v3xofc0lb","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx7004ym32v8ijw1sdj"},{"post_id":"cm39jlwwc000em32v3xofc0lb","category_id":"cm39jlwx6004om32v6ygdgp59","_id":"cm39jlwx70051m32v4ig5hc10"},{"post_id":"cm39jlwwd000im32vftbg0gdv","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwx80058m32v2kj69yfb"},{"post_id":"cm39jlwwd000im32vftbg0gdv","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwx8005am32v8kbxbxpd"},{"post_id":"cm39jlwwd000im32vftbg0gdv","category_id":"cm39jlwx70050m32v69yd0zum","_id":"cm39jlwx8005bm32v21dp0kzf"},{"post_id":"cm39jlwwa0007m32vfoid4330","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxa005km32vb2lgecdv"},{"post_id":"cm39jlwwa0007m32vfoid4330","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwxa005mm32v6o6dggc2"},{"post_id":"cm39jlwwa0007m32vfoid4330","category_id":"cm39jlwx8005dm32v6lk07vmk","_id":"cm39jlwxa005qm32v8c6d28io"},{"post_id":"cm39jlwwe000km32v8ewddogt","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxb005xm32vbgc29br3"},{"post_id":"cm39jlwwe000km32v8ewddogt","category_id":"cm39jlwwe000lm32vak1n75su","_id":"cm39jlwxb005ym32vgit99ul1"},{"post_id":"cm39jlwwe000km32v8ewddogt","category_id":"cm39jlwxa005pm32vabczgucb","_id":"cm39jlwxc0061m32vg38c5gou"},{"post_id":"cm39jlwwf000qm32v5jitbynh","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxf006om32vhsyc2x4v"},{"post_id":"cm39jlwwf000qm32v5jitbynh","category_id":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwxg006pm32vbizr2li2"},{"post_id":"cm39jlwwf000qm32v5jitbynh","category_id":"cm39jlwxe006hm32v8tmhf6a9","_id":"cm39jlwxg006sm32v8ovh6ych"},{"post_id":"cm39jlwwg000um32vd0n75jif","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxh006zm32v4d9e6qds"},{"post_id":"cm39jlwwg000um32vd0n75jif","category_id":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwxh0071m32v4ytb93z0"},{"post_id":"cm39jlwwg000um32vd0n75jif","category_id":"cm39jlwxg006rm32vditsgj2i","_id":"cm39jlwxh0075m32vfpb26zg6"},{"post_id":"cm39jlwwl001im32v2hsqeyi5","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxr0091m32veh9e210h"},{"post_id":"cm39jlwwl001im32v2hsqeyi5","category_id":"cm39jlwx5004mm32veddh1xd2","_id":"cm39jlwxr0094m32v422v0xq4"},{"post_id":"cm39jlwwl001im32v2hsqeyi5","category_id":"cm39jlwxq008um32v3ni321fs","_id":"cm39jlwxr0096m32v8iva8m2m"},{"post_id":"cm39jlwwl001km32vc5q96x5v","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxs009am32vbey85gdh"},{"post_id":"cm39jlwwl001km32vc5q96x5v","category_id":"cm39jlwx5004mm32veddh1xd2","_id":"cm39jlwxs009bm32v9lsr49qx"},{"post_id":"cm39jlwwl001km32vc5q96x5v","category_id":"cm39jlwxq008um32v3ni321fs","_id":"cm39jlwxs009em32vbevxhu7z"},{"post_id":"cm39jlwwm001om32vcywbabj5","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxs009gm32v3bhm3nel"},{"post_id":"cm39jlwwm001om32vcywbabj5","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxt009km32v8m2kdtlz"},{"post_id":"cm39jlwwm001om32vcywbabj5","category_id":"cm39jlwxr0090m32v4ifc0xs6","_id":"cm39jlwxt009lm32v42aw1pt1"},{"post_id":"cm39jlwwm001sm32vhc8f9kr0","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxt009nm32veos7cvok"},{"post_id":"cm39jlwwm001sm32vhc8f9kr0","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxt009qm32v413t3fng"},{"post_id":"cm39jlwwm001sm32vhc8f9kr0","category_id":"cm39jlwxr0097m32v488ga7ej","_id":"cm39jlwxt009sm32vac0c7fi9"},{"post_id":"cm39jlwwn001vm32v6gnt55vv","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxu009vm32vdr5072bu"},{"post_id":"cm39jlwwn001vm32v6gnt55vv","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxu009wm32vcv6be7sa"},{"post_id":"cm39jlwwn001vm32v6gnt55vv","category_id":"cm39jlwxs009cm32v1rwf53wd","_id":"cm39jlwxu009zm32vgr9g7pnr"},{"post_id":"cm39jlwwo0021m32vhzjeg88v","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxu00a1m32v9kz48pjn"},{"post_id":"cm39jlwwo0021m32vhzjeg88v","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxv00a5m32v6dehay33"},{"post_id":"cm39jlwwo0021m32vhzjeg88v","category_id":"cm39jlwxt009mm32vf1a814sy","_id":"cm39jlwxv00a6m32vd61mab2l"},{"post_id":"cm39jlwwo0024m32v58hqcafm","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxv00a8m32vg996hqom"},{"post_id":"cm39jlwwo0024m32v58hqcafm","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxv00aam32v11594ybx"},{"post_id":"cm39jlwwo0024m32v58hqcafm","category_id":"cm39jlwxt009um32v3zoz0xe9","_id":"cm39jlwxv00acm32vdjpi2riv"},{"post_id":"cm39jlwwp0027m32vcy031zwg","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxv00aem32vak5h3tf4"},{"post_id":"cm39jlwwp0027m32vcy031zwg","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwxv00afm32v9uy9copp"},{"post_id":"cm39jlwwp0027m32vcy031zwg","category_id":"cm39jlwxu009ym32v3fbr1j34","_id":"cm39jlwxw00ahm32vfhppb02m"},{"post_id":"cm39jlwwp002am32v31iq3b39","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxw00aim32vc2qj3633"},{"post_id":"cm39jlwwp002am32v31iq3b39","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxw00akm32vcib392v4"},{"post_id":"cm39jlwwp002am32v31iq3b39","category_id":"cm39jlwxu00a4m32v813104dx","_id":"cm39jlwxw00alm32va1a6bl60"},{"post_id":"cm39jlwwq002dm32v43vzdi54","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxw00anm32veee59gnh"},{"post_id":"cm39jlwwq002dm32v43vzdi54","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxw00aom32vbgi08s31"},{"post_id":"cm39jlwwq002dm32v43vzdi54","category_id":"cm39jlwxv00a7m32vaafbbed4","_id":"cm39jlwxw00apm32vgqiz03sw"},{"post_id":"cm39jlwwr002gm32vfpo1etqm","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxw00arm32vbfnv5krd"},{"post_id":"cm39jlwwr002gm32vfpo1etqm","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxw00asm32vdceb59s0"},{"post_id":"cm39jlwwr002gm32vfpo1etqm","category_id":"cm39jlwxv00adm32vaw0ng5f5","_id":"cm39jlwxx00aum32vcc2mc0uu"},{"post_id":"cm39jlwws002jm32vhnudha68","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxx00avm32vb6hab0sz"},{"post_id":"cm39jlwws002jm32vhnudha68","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxx00axm32v728j5au3"},{"post_id":"cm39jlwws002jm32vhnudha68","category_id":"cm39jlwxv00agm32vdqat3gvh","_id":"cm39jlwxx00aym32vc7e9cfh3"},{"post_id":"cm39jlwwt002rm32v6n1n4gvq","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxx00b0m32vb2w5ee9f"},{"post_id":"cm39jlwwt002rm32v6n1n4gvq","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxx00b1m32vejgd6tl9"},{"post_id":"cm39jlwwt002rm32v6n1n4gvq","category_id":"cm39jlwxw00amm32vf4h7fwu3","_id":"cm39jlwxx00b3m32va48m7qoa"},{"post_id":"cm39jlwwu002ym32v48nfcby4","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxy00b4m32vd3hm6bdf"},{"post_id":"cm39jlwwu002ym32v48nfcby4","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwxy00b6m32vhh226ewy"},{"post_id":"cm39jlwwu002ym32v48nfcby4","category_id":"cm39jlwxw00atm32vbip29i5j","_id":"cm39jlwxy00b7m32v0e61b019"},{"post_id":"cm39jlwww0034m32v1rjufsry","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxy00b9m32v8shhdsn5"},{"post_id":"cm39jlwww0034m32v1rjufsry","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwxy00bam32veonp655e"},{"post_id":"cm39jlwww0034m32v1rjufsry","category_id":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwxy00bcm32vdqdag5y9"},{"post_id":"cm39jlwwx003dm32vgit07oot","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwxz00bem32vdqwih11r"},{"post_id":"cm39jlwwx003dm32vgit07oot","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwxz00bfm32v01pd2vx7"},{"post_id":"cm39jlwwx003dm32vgit07oot","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwxz00bgm32vays5032d"},{"post_id":"cm39jlwwh0010m32v7bfg3gaf","category_id":"cm39jlwwx003cm32vgfpi3quy","_id":"cm39jlwxz00bjm32v7i8uf2wp"},{"post_id":"cm39jlwwh0010m32v7bfg3gaf","category_id":"cm39jlwxj007jm32v296f9t5p","_id":"cm39jlwxz00bkm32v0rpu6uzv"},{"post_id":"cm39jlwwh0010m32v7bfg3gaf","category_id":"cm39jlwxy00bdm32v5ute259e","_id":"cm39jlwxz00bmm32v9opng2oa"},{"post_id":"cm39jlwwz003qm32v5qx782sj","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy000bpm32v3f979gqa"},{"post_id":"cm39jlwwz003qm32v5qx782sj","category_id":"cm39jlwxl007tm32v61d1g345","_id":"cm39jlwy000bqm32v8tld92pq"},{"post_id":"cm39jlwwz003qm32v5qx782sj","category_id":"cm39jlwxz00blm32v68ds7aaj","_id":"cm39jlwy000brm32v588acaci"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy000bum32v380p30b8"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy000bvm32v3htkhmag"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","category_id":"cm39jlwxl007zm32v0c3n9dsj","_id":"cm39jlwy000bwm32vdewvgc5b"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","category_id":"cm39jlwy000bom32v8ojwg060","_id":"cm39jlwy100bym32va0y8cbks"},{"post_id":"cm39jlwx1003vm32v0l8m5e29","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy100bzm32v3cdo9j5a"},{"post_id":"cm39jlwx1003vm32v0l8m5e29","category_id":"cm39jlwxl007tm32v61d1g345","_id":"cm39jlwy100c1m32v6k818jo3"},{"post_id":"cm39jlwx1003vm32v0l8m5e29","category_id":"cm39jlwxz00blm32v68ds7aaj","_id":"cm39jlwy100c2m32vg6ca89g3"},{"post_id":"cm39jlwx1003zm32vcqv0ejvh","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy200c4m32v8u489t82"},{"post_id":"cm39jlwx1003zm32vcqv0ejvh","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy200c5m32v5ba7b45u"},{"post_id":"cm39jlwx1003zm32vcqv0ejvh","category_id":"cm39jlwy000btm32v6dq2hbwi","_id":"cm39jlwy200c7m32vhgnnct8n"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy200c8m32vb3qj690j"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy200c9m32v4ndacoel"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","category_id":"cm39jlwxl007zm32v0c3n9dsj","_id":"cm39jlwy200cbm32vd1t80c3p"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","category_id":"cm39jlwy000bxm32vdsqwdeq6","_id":"cm39jlwy200ccm32v7m5udqpg"},{"post_id":"cm39jlwx20042m32v2x8h3ote","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy300cem32v091eax63"},{"post_id":"cm39jlwx20042m32v2x8h3ote","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy300cfm32v321l3her"},{"post_id":"cm39jlwx20042m32v2x8h3ote","category_id":"cm39jlwy100c0m32v1rs6gcer","_id":"cm39jlwy300chm32v89pjek7i"},{"post_id":"cm39jlwx20047m32v8sor1sha","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy300cim32vdz6i8a63"},{"post_id":"cm39jlwx20047m32v8sor1sha","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy400ckm32vayra88ck"},{"post_id":"cm39jlwx20047m32v8sor1sha","category_id":"cm39jlwy100c3m32v9cqjdcra","_id":"cm39jlwy400clm32v4hj1fjqx"},{"post_id":"cm39jlwx30048m32v6a2o4sns","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy400cmm32v1zqxcd23"},{"post_id":"cm39jlwx30048m32v6a2o4sns","category_id":"cm39jlwx80054m32vb4r5f2er","_id":"cm39jlwy400com32v0otu364l"},{"post_id":"cm39jlwx30048m32v6a2o4sns","category_id":"cm39jlwy200c6m32vb6fhel0m","_id":"cm39jlwy400cpm32vd0os2vfn"},{"post_id":"cm39jlwwj0018m32v4hss4x4f","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy400crm32v9ir9dz39"},{"post_id":"cm39jlwwj0018m32v4hss4x4f","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy400csm32v4l3jfkwv"},{"post_id":"cm39jlwwj0018m32v4hss4x4f","category_id":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy400cum32v5qfyhlod"},{"post_id":"cm39jlwwj0018m32v4hss4x4f","category_id":"cm39jlwy200cam32v80540883","_id":"cm39jlwy500cvm32vcnpt3vqa"},{"post_id":"cm39jlwwk001cm32vd79n8hyk","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy500cxm32veyen6riz"},{"post_id":"cm39jlwwk001cm32vd79n8hyk","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy500cym32v1rgq97xt"},{"post_id":"cm39jlwwk001cm32vd79n8hyk","category_id":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy500czm32v8iaj4g60"},{"post_id":"cm39jlwwk001cm32vd79n8hyk","category_id":"cm39jlwy300cdm32v8j08enaj","_id":"cm39jlwy500d1m32v9hlua8e2"},{"post_id":"cm39jlwwk001em32v2o373t03","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy500d2m32vertbacyc"},{"post_id":"cm39jlwwk001em32v2o373t03","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy600d4m32v70u2gkef"},{"post_id":"cm39jlwwk001em32v2o373t03","category_id":"cm39jlwxo008km32v3bol6tgl","_id":"cm39jlwy600d5m32v748y9lhi"},{"post_id":"cm39jlwwk001em32v2o373t03","category_id":"cm39jlwy300cgm32v5v6ue1qn","_id":"cm39jlwy600d7m32v9z5qhc9h"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy600d8m32v5a0v3my4"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwy600dam32vb7dv78m5"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","category_id":"cm39jlwxs009im32vfca7f7eo","_id":"cm39jlwy600dbm32v2kh94zde"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","category_id":"cm39jlwy300cjm32v2lv6gsh9","_id":"cm39jlwy700dcm32v0xfa0vku"},{"post_id":"cm39jlwws002nm32vcz7sbb91","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy700dem32vhv3a09jf"},{"post_id":"cm39jlwws002nm32vcz7sbb91","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy700dfm32v27i81lxb"},{"post_id":"cm39jlwws002nm32vcz7sbb91","category_id":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy700dgm32v6eef3t45"},{"post_id":"cm39jlwws002nm32vcz7sbb91","category_id":"cm39jlwy400cnm32vfei01hhn","_id":"cm39jlwy800dhm32vdrbqfhhs"},{"post_id":"cm39jlwwu002vm32v4vk333j9","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800dim32v4oki3wsg"},{"post_id":"cm39jlwwu002vm32v4vk333j9","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800djm32vdq67cqv3"},{"post_id":"cm39jlwwu002vm32v4vk333j9","category_id":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy800dkm32vdjexgj1o"},{"post_id":"cm39jlwwu002vm32v4vk333j9","category_id":"cm39jlwy400cqm32v96ct6lgk","_id":"cm39jlwy800dlm32v9z0thuga"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800dmm32v0zth1cwd"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800dnm32vdoel28d9"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","category_id":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy800dom32v8izr0viv"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","category_id":"cm39jlwy400ctm32vghdv8eho","_id":"cm39jlwy800dpm32vfkcb7b80"},{"post_id":"cm39jlwww0037m32vc3coar4e","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800dqm32v5qds2zb3"},{"post_id":"cm39jlwww0037m32vc3coar4e","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800drm32v22558v51"},{"post_id":"cm39jlwww0037m32vc3coar4e","category_id":"cm39jlwxw00ajm32vhwtr8zsf","_id":"cm39jlwy800dsm32vhr1scfh4"},{"post_id":"cm39jlwww0037m32vc3coar4e","category_id":"cm39jlwy500cwm32v3ou0aa4h","_id":"cm39jlwy800dtm32v6spabr20"},{"post_id":"cm39jlwwx003am32vby1zbpjc","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800dum32vfs7t4ala"},{"post_id":"cm39jlwwx003am32vby1zbpjc","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800dvm32v1fvp9po7"},{"post_id":"cm39jlwwx003am32vby1zbpjc","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy800dwm32va6c2552e"},{"post_id":"cm39jlwwx003am32vby1zbpjc","category_id":"cm39jlwy500d0m32vavew05qz","_id":"cm39jlwy800dxm32vbseeap09"},{"post_id":"cm39jlwwy003hm32v17zp14xs","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800dym32vg65x490f"},{"post_id":"cm39jlwwy003hm32v17zp14xs","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800dzm32vdn4j1hnw"},{"post_id":"cm39jlwwy003hm32v17zp14xs","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy800e0m32vacpm4v73"},{"post_id":"cm39jlwwy003hm32v17zp14xs","category_id":"cm39jlwy500d3m32v8un3havz","_id":"cm39jlwy800e1m32vhuby3qgc"},{"post_id":"cm39jlwwy003jm32v7tti87s1","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800e2m32v5lehfjuo"},{"post_id":"cm39jlwwy003jm32v7tti87s1","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800e3m32v979g8fa6"},{"post_id":"cm39jlwwy003jm32v7tti87s1","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy800e4m32v8p879y4d"},{"post_id":"cm39jlwwy003jm32v7tti87s1","category_id":"cm39jlwy600d6m32ve1beggfz","_id":"cm39jlwy800e5m32v99hkhr7i"},{"post_id":"cm39jlwwz003om32vhgds1o2r","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy800e6m32v7kud0e6m"},{"post_id":"cm39jlwwz003om32vhgds1o2r","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy800e7m32vfqy825vk"},{"post_id":"cm39jlwwz003om32vhgds1o2r","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy900e8m32vhkr0anxt"},{"post_id":"cm39jlwwz003om32vhgds1o2r","category_id":"cm39jlwy600d9m32vcou58p93","_id":"cm39jlwy900e9m32v2ept5x1u"},{"post_id":"cm39jlwx0003um32v1g74ev3o","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwy900eam32v3b87fxvs"},{"post_id":"cm39jlwx0003um32v1g74ev3o","category_id":"cm39jlwxe006dm32vhyo175cg","_id":"cm39jlwy900ebm32veh63fg4l"},{"post_id":"cm39jlwx0003um32v1g74ev3o","category_id":"cm39jlwxy00b5m32v8p5820jy","_id":"cm39jlwy900ecm32vhp0ea8u1"},{"post_id":"cm39jlwx0003um32v1g74ev3o","category_id":"cm39jlwy700ddm32ves1y26wk","_id":"cm39jlwy900edm32v7rsygtqg"},{"post_id":"cm39jlwya00eem32vgrxe47tj","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwyc00epm32v3jh42zx2"},{"post_id":"cm39jlwya00eem32vgrxe47tj","category_id":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwyd00esm32v1o0e61e5"},{"post_id":"cm39jlwya00eem32vgrxe47tj","category_id":"cm39jlwyb00eim32v3xam6xei","_id":"cm39jlwyd00eum32v3gug4ch7"},{"post_id":"cm39jlwyb00efm32v6cmf7qv3","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwyd00ewm32v0z1z8vw4"},{"post_id":"cm39jlwyb00efm32v6cmf7qv3","category_id":"cm39jlwws002km32vetcx8bbl","_id":"cm39jlwyd00exm32v4tl43wlp"},{"post_id":"cm39jlwyb00efm32v6cmf7qv3","category_id":"cm39jlwyc00emm32v9j8cfc0b","_id":"cm39jlwyd00ezm32vguwm2rhz"},{"post_id":"cm39jlwyc00ekm32vgq1o10bv","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwyd00f0m32v1hnh4fx5"},{"post_id":"cm39jlwyc00ekm32vgq1o10bv","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwyd00f1m32v2hgj2moe"},{"post_id":"cm39jlwyc00ekm32vgq1o10bv","category_id":"cm39jlwyd00evm32v3t0dhhu4","_id":"cm39jlwyd00f2m32vflh98cxp"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39jlwyd00f3m32vg7h04czj"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39jlwyd00f4m32vbn6j25wr"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","category_id":"cm39jlwyc00erm32v4kwl3oul","_id":"cm39jlwyd00f5m32v6s4780vu"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","category_id":"cm39jlwyd00eym32vc1qmes93","_id":"cm39jlwye00f6m32vcy68fgaz"},{"post_id":"cm39k9n0f00009k2vfmhvdzl2","category_id":"cm39jlww80004m32vbfdbe8rg","_id":"cm39k9n0p00049k2vets7dvwm"},{"post_id":"cm39k9n0f00009k2vfmhvdzl2","category_id":"cm39jlwx0003rm32v3lx2alna","_id":"cm39k9n0p00059k2vgkl90cpu"},{"post_id":"cm39k9n0f00009k2vfmhvdzl2","category_id":"cm39k9n0j00029k2vbafh2xs8","_id":"cm39k9n0p00069k2vdr2vh3pn"}],"PostTag":[{"post_id":"cm39jlwwc000dm32vfv527vp1","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwd000hm32v0zqsdc5x"},{"post_id":"cm39jlwwc000dm32vfv527vp1","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwe000jm32vf7v86fwn"},{"post_id":"cm39jlww60001m32vhosu9xma","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwf000nm32vg9d58u8w"},{"post_id":"cm39jlww60001m32vhosu9xma","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwf000pm32v7gn28gnu"},{"post_id":"cm39jlwwc000em32v3xofc0lb","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwg000sm32vedq1h5hv"},{"post_id":"cm39jlwwc000em32v3xofc0lb","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwh000vm32vemfpdka8"},{"post_id":"cm39jlwwd000im32vftbg0gdv","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwh000ym32v5ppb5v2u"},{"post_id":"cm39jlwwd000im32vftbg0gdv","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwi0011m32vgnpicsw1"},{"post_id":"cm39jlwwe000km32v8ewddogt","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwi0014m32v32xt58zt"},{"post_id":"cm39jlwwe000km32v8ewddogt","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwj0017m32vbszndjs8"},{"post_id":"cm39jlwwf000om32v6ytjfw9y","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwk001am32vdjns76je"},{"post_id":"cm39jlwwf000om32v6ytjfw9y","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwk001dm32v71hhbarj"},{"post_id":"cm39jlww80003m32vbzhi89ms","tag_id":"cm39jlwwd000gm32v015kepbn","_id":"cm39jlwwl001gm32v95rf4mpd"},{"post_id":"cm39jlww80003m32vbzhi89ms","tag_id":"cm39jlwwf000mm32vd599btu5","_id":"cm39jlwwl001jm32vebl73es6"},{"post_id":"cm39jlwwh000wm32v0kb0e4fl","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwm001nm32vfb5tbofo"},{"post_id":"cm39jlwwh000wm32v0kb0e4fl","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwm001rm32v6sotcf1r"},{"post_id":"cm39jlwwa0007m32vfoid4330","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwn001um32v6ccq81je"},{"post_id":"cm39jlwwa0007m32vfoid4330","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwn001xm32v64524fxh"},{"post_id":"cm39jlwwa0009m32vcf4pbwmd","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwo0020m32vcctscdi0"},{"post_id":"cm39jlwwa0009m32vcf4pbwmd","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwo0023m32vbjmb6e34"},{"post_id":"cm39jlwwb000am32v2b3taob7","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwwp0026m32vedyv8q77"},{"post_id":"cm39jlwwb000am32v2b3taob7","tag_id":"cm39jlwwb000cm32v7q0p32pd","_id":"cm39jlwwp0029m32v2yvaft93"},{"post_id":"cm39jlwwf000qm32v5jitbynh","tag_id":"cm39jlwwl001hm32vgcoub0xi","_id":"cm39jlwwq002bm32vhbeh2rn2"},{"post_id":"cm39jlwwg000um32vd0n75jif","tag_id":"cm39jlwwl001hm32vgcoub0xi","_id":"cm39jlwwq002em32v567ybhef"},{"post_id":"cm39jlwwh0010m32v7bfg3gaf","tag_id":"cm39jlwwn001wm32vaami7vm5","_id":"cm39jlwws002hm32vdqis4iyi"},{"post_id":"cm39jlwwh0010m32v7bfg3gaf","tag_id":"cm39jlwwo0022m32vg4bv58am","_id":"cm39jlwws002lm32vcsfmfpgb"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwwt002qm32v0ysxdphd"},{"post_id":"cm39jlwwi0012m32v2yvc6zkp","tag_id":"cm39jlwwq002fm32v2vgj4nsf","_id":"cm39jlwwu002um32v3pvqbgug"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwwv0033m32v57hu246i"},{"post_id":"cm39jlwwj0016m32vd5tr1dey","tag_id":"cm39jlwwq002fm32v2vgj4nsf","_id":"cm39jlwww0036m32v4rzz4xu9"},{"post_id":"cm39jlwwj0018m32v4hss4x4f","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwwx0039m32vevicf38g"},{"post_id":"cm39jlwwk001cm32vd79n8hyk","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwwy003gm32vb6jiavai"},{"post_id":"cm39jlwwk001em32v2o373t03","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwwz003nm32v0l5rhmf5"},{"post_id":"cm39jlwwl001im32v2hsqeyi5","tag_id":"cm39jlwwz003lm32v8sfa8h2e","_id":"cm39jlwx20041m32v54myaaez"},{"post_id":"cm39jlwwl001im32v2hsqeyi5","tag_id":"cm39jlwx0003sm32v0iyg0kke","_id":"cm39jlwx20044m32v30d6ey49"},{"post_id":"cm39jlwwl001km32vc5q96x5v","tag_id":"cm39jlwwz003lm32v8sfa8h2e","_id":"cm39jlwx3004bm32veamu4uxr"},{"post_id":"cm39jlwwl001km32vc5q96x5v","tag_id":"cm39jlwx0003sm32v0iyg0kke","_id":"cm39jlwx3004cm32v13om2gpl"},{"post_id":"cm39jlwwm001om32vcywbabj5","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwx5004km32v9ua36jux"},{"post_id":"cm39jlwwm001om32vcywbabj5","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39jlwx5004lm32v7idxdhbx"},{"post_id":"cm39jlwwm001sm32vhc8f9kr0","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwx6004qm32v3simd7ky"},{"post_id":"cm39jlwwm001sm32vhc8f9kr0","tag_id":"cm39jlwx6004nm32va2jc4i9p","_id":"cm39jlwx6004rm32v3zeydz0g"},{"post_id":"cm39jlwwn001vm32v6gnt55vv","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwx7004xm32v04da8myb"},{"post_id":"cm39jlwwn001vm32v6gnt55vv","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39jlwx7004zm32v4cnec92m"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwx80055m32vahym5wwg"},{"post_id":"cm39jlwwn001ym32vebfs6bm7","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39jlwx80056m32v1z12a1sp"},{"post_id":"cm39jlwwo0021m32vhzjeg88v","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwx9005em32v6s0wexqa"},{"post_id":"cm39jlwwo0021m32vhzjeg88v","tag_id":"cm39jlwx80057m32v0514dy2x","_id":"cm39jlwx9005fm32vbdppg6d4"},{"post_id":"cm39jlwwo0024m32v58hqcafm","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxa005lm32v5btubxm9"},{"post_id":"cm39jlwwo0024m32v58hqcafm","tag_id":"cm39jlwx6004nm32va2jc4i9p","_id":"cm39jlwxa005nm32vdzno6g26"},{"post_id":"cm39jlwwp0027m32vcy031zwg","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwxb005tm32v52a59ci9"},{"post_id":"cm39jlwwp0027m32vcy031zwg","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39jlwxb005um32v8rk85497"},{"post_id":"cm39jlwwp002am32v31iq3b39","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxc0062m32v4grqc9sg"},{"post_id":"cm39jlwwp002am32v31iq3b39","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxc0063m32v8350fx27"},{"post_id":"cm39jlwwq002dm32v43vzdi54","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxd0068m32v0eeugi2h"},{"post_id":"cm39jlwwq002dm32v43vzdi54","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxd0069m32v74kra5ix"},{"post_id":"cm39jlwwr002gm32vfpo1etqm","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxe006em32vhrxefii9"},{"post_id":"cm39jlwwr002gm32vfpo1etqm","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxe006fm32v53f3839b"},{"post_id":"cm39jlwws002jm32vhnudha68","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxe006jm32v8whc3o8a"},{"post_id":"cm39jlwws002jm32vhnudha68","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxf006lm32v0i3u2etk"},{"post_id":"cm39jlwws002nm32vcz7sbb91","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxg006tm32vh7f820s8"},{"post_id":"cm39jlwws002nm32vcz7sbb91","tag_id":"cm39jlwxf006mm32v65jy3k5n","_id":"cm39jlwxg006um32v9cvo9iwh"},{"post_id":"cm39jlwwt002rm32v6n1n4gvq","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxh0070m32v9c7y5pby"},{"post_id":"cm39jlwwt002rm32v6n1n4gvq","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxh0072m32v4ayxgcqd"},{"post_id":"cm39jlwwu002vm32v4vk333j9","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxi0078m32v2fqg3r67"},{"post_id":"cm39jlwwu002vm32v4vk333j9","tag_id":"cm39jlwxf006mm32v65jy3k5n","_id":"cm39jlwxi0079m32veww65vkc"},{"post_id":"cm39jlwwu002ym32v48nfcby4","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxj007em32v2w430bih"},{"post_id":"cm39jlwwu002ym32v48nfcby4","tag_id":"cm39jlwxb005vm32vax0wd3wm","_id":"cm39jlwxj007fm32vbk18cjy7"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxk007km32vgv9hhm2g"},{"post_id":"cm39jlwwv0031m32vcobe0kk3","tag_id":"cm39jlwxf006mm32v65jy3k5n","_id":"cm39jlwxk007lm32v4t8de75j"},{"post_id":"cm39jlwww0034m32v1rjufsry","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxk007pm32v0v7agrci"},{"post_id":"cm39jlwww0034m32v1rjufsry","tag_id":"cm39jlwxf006mm32v65jy3k5n","_id":"cm39jlwxk007rm32vhj120km7"},{"post_id":"cm39jlwww0037m32vc3coar4e","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxl007vm32vfhbdhict"},{"post_id":"cm39jlwww0037m32vc3coar4e","tag_id":"cm39jlwxf006mm32v65jy3k5n","_id":"cm39jlwxl007xm32v3vkw27yf"},{"post_id":"cm39jlwwx003am32vby1zbpjc","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxm0081m32v7ff25uuz"},{"post_id":"cm39jlwwx003am32vby1zbpjc","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxm0083m32vhtcp1cfj"},{"post_id":"cm39jlwwx003dm32vgit07oot","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxm0087m32ve6jqbmkt"},{"post_id":"cm39jlwwx003dm32vgit07oot","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxn0089m32v2v3q8e59"},{"post_id":"cm39jlwwy003hm32v17zp14xs","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxn008dm32vd6xl753r"},{"post_id":"cm39jlwwy003hm32v17zp14xs","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxn008fm32v4uyl6cpg"},{"post_id":"cm39jlwwy003jm32v7tti87s1","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxo008jm32vfn888ejg"},{"post_id":"cm39jlwwy003jm32v7tti87s1","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxo008lm32vdeb7b9yf"},{"post_id":"cm39jlwwz003om32vhgds1o2r","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxp008pm32v5c8l60cm"},{"post_id":"cm39jlwwz003om32vhgds1o2r","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxq008rm32v38lye37l"},{"post_id":"cm39jlwwz003qm32v5qx782sj","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwxq008tm32vd1bv59y8"},{"post_id":"cm39jlwwz003qm32v5qx782sj","tag_id":"cm39jlwxp008om32v2fcfefg8","_id":"cm39jlwxq008vm32veew9g5zk"},{"post_id":"cm39jlwx0003um32v1g74ev3o","tag_id":"cm39jlwxe006im32v9nymbyni","_id":"cm39jlwxr008zm32v4glw2b70"},{"post_id":"cm39jlwx0003um32v1g74ev3o","tag_id":"cm39jlwxl007ym32v5bbp6l3s","_id":"cm39jlwxr0092m32v3zxccgqe"},{"post_id":"cm39jlwx1003vm32v0l8m5e29","tag_id":"cm39jlww90005m32v4471gcmt","_id":"cm39jlwxr0095m32vh3jp3fyw"},{"post_id":"cm39jlwx1003vm32v0l8m5e29","tag_id":"cm39jlwxp008om32v2fcfefg8","_id":"cm39jlwxs0098m32v9mtufa5l"},{"post_id":"cm39jlwx1003zm32vcqv0ejvh","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxs009fm32v3p4z8xwh"},{"post_id":"cm39jlwx1003zm32vcqv0ejvh","tag_id":"cm39jlwxs0099m32vgk8q677p","_id":"cm39jlwxs009hm32vdjbv93k8"},{"post_id":"cm39jlwx20042m32v2x8h3ote","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxt009pm32v7k9uexca"},{"post_id":"cm39jlwx20042m32v2x8h3ote","tag_id":"cm39jlwxt009jm32vcf5h0xzi","_id":"cm39jlwxt009rm32vc2pl5jt8"},{"post_id":"cm39jlwx20047m32v8sor1sha","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxu00a0m32vax6rc883"},{"post_id":"cm39jlwx20047m32v8sor1sha","tag_id":"cm39jlwxt009tm32v6s45e1u2","_id":"cm39jlwxu00a2m32vdyx92y8d"},{"post_id":"cm39jlwx30048m32v6a2o4sns","tag_id":"cm39jlwx4004jm32vasdkcfm5","_id":"cm39jlwxv00a9m32vb9kv9c58"},{"post_id":"cm39jlwx30048m32v6a2o4sns","tag_id":"cm39jlwxu00a3m32v69n9eltx","_id":"cm39jlwxv00abm32vct6h3qcp"},{"post_id":"cm39jlwya00eem32vgrxe47tj","tag_id":"cm39jlwwl001hm32vgcoub0xi","_id":"cm39jlwyb00egm32v7nhyewb0"},{"post_id":"cm39jlwyb00efm32v6cmf7qv3","tag_id":"cm39jlwwl001hm32vgcoub0xi","_id":"cm39jlwyc00ejm32v164f144q"},{"post_id":"cm39jlwyc00ekm32vgq1o10bv","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwyc00enm32veaw38hm7"},{"post_id":"cm39jlwyc00ekm32vgq1o10bv","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39jlwyc00eom32vbjj62ikh"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39jlwyc00eqm32vatht4wjs"},{"post_id":"cm39jlwyb00ehm32v9edp9iz1","tag_id":"cm39jlwyc00elm32v45ax9rag","_id":"cm39jlwyd00etm32vdd6ahlm6"},{"post_id":"cm39k9n0f00009k2vfmhvdzl2","tag_id":"cm39jlwwp0028m32v67a3hqwq","_id":"cm39k9n0j00019k2v2dizaq7q"},{"post_id":"cm39k9n0f00009k2vfmhvdzl2","tag_id":"cm39jlwx3004dm32vdvsb8igz","_id":"cm39k9n0o00039k2veokc3s9i"}],"Tag":[{"name":"前端","_id":"cm39jlww90005m32v4471gcmt"},{"name":"Echarts","_id":"cm39jlwwb000cm32v7q0p32pd"},{"name":"js","_id":"cm39jlwwd000gm32v015kepbn"},{"name":"正则","_id":"cm39jlwwf000mm32vd599btu5"},{"name":"浏览器","_id":"cm39jlwwl001hm32vgcoub0xi"},{"name":"Bug","_id":"cm39jlwwn001wm32vaami7vm5"},{"name":"兼容性","_id":"cm39jlwwo0022m32vg4bv58am"},{"name":"JavaScript","_id":"cm39jlwwp0028m32v67a3hqwq"},{"name":"ES6","_id":"cm39jlwwq002fm32v2vgj4nsf"},{"name":"Vue","_id":"cm39jlwwz003lm32v8sfa8h2e"},{"name":"源码剖析","_id":"cm39jlwx0003sm32v0iyg0kke"},{"name":"JavaScript面试","_id":"cm39jlwx3004dm32vdvsb8igz"},{"name":"leetcode","_id":"cm39jlwx4004jm32vasdkcfm5"},{"name":"栈","_id":"cm39jlwx6004nm32va2jc4i9p"},{"name":"数组","_id":"cm39jlwx80057m32v0514dy2x"},{"name":"字符串","_id":"cm39jlwxb005vm32vax0wd3wm"},{"name":"算法","_id":"cm39jlwxe006im32v9nymbyni"},{"name":"分治法","_id":"cm39jlwxf006mm32v65jy3k5n"},{"name":"动态规划","_id":"cm39jlwxl007ym32v5bbp6l3s"},{"name":"tinymce","_id":"cm39jlwxp008om32v2fcfefg8"},{"name":"选择排序","_id":"cm39jlwxs0099m32vgk8q677p"},{"name":"冒泡排序","_id":"cm39jlwxt009jm32vcf5h0xzi"},{"name":"插入排序","_id":"cm39jlwxt009tm32v6s45e1u2"},{"name":"希尔排序","_id":"cm39jlwxu00a3m32v69n9eltx"},{"name":"lodash","_id":"cm39jlwyc00elm32v45ax9rag"}]}}